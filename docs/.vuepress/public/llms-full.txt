# UniWebView Complete Content

## Guide Documentation

### Introduction

# Introduction

> UniWebView is a Unity plugin for iOS and Android, enabling web view integration with features like OAuth 2.0, JavaScript support, and cross-platform compatibility.

## What can UniWebView do

UniWebView is a Unity 3D plugin for adding a web view component to your Unity 3D mobile games on iOS and Android. It provides a set of abstract, cross-platforms, and high-level APIs in C#. That means you can implement your web view in your game without any knowledge of the underlying native platform.

It boosts your development process dramatically when you need to show an announcement or notice, add a leader board for player rankings, or display any interactive web pages to your users.

## Feature List

#### Web Content Browsing

- [HTTP and HTTPS pages](/api/#load)
- [Local Files](loading-local-files.md)
- [Presenting and Dismissing](transition.md)
- [Size and Position](position-and-size.md)
- [Loading Events](/api/#events-summary)
- [Safe Browsing Mode](safe-browsing.md)

#### Interacting with Web Page

- [Embedded Toolbar](embedded-toolbar.md)
- [Full JavaScript Support](using-javascript.md)
- [URL Messaging System](messaging-system.md)
- [Channel Between Unity and JavaScript](channel-message.md)

#### Other Tasks

- [OAuth 2.0 Support](oauth2.md)
- [Videos, inline or full-screen](playing-videos.md)
- [Image Picking & Uploading](uploading.md)
- [Render As Texture](render-as-texture.md)
- [User Agent & Cookie](/api/#setuseragent)
- [Allow clicks to pass through](transparency-through.md)
- [Full Log & Debugging](debugging.md)

And much more. Please check the [full API Reference](/api).

## Supported Platforms

UniWebView v6 supports running on:

- **Unity 2020.1** or above
- **iOS 9.0** or above
- **Android 5.0** (API Level 21) or above

## How It Works

UniWebView wraps the technology under the hood to render a general-purpose web view:

- On iOS, [WKWebView](https://developer.apple.com/reference/webkit/wkwebview)
- On Android, [WebView](https://developer.android.com/reference/android/webkit/WebView.html)

It also provides a "Safe Browsing" mode, to help you get a system-level experience of web content, which uses:

- On iOS, [SFSafariViewController](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller)
- On Android, [Custom Tabs](https://developers.google.com/web/android/custom-tabs)

UniWebView supports the standard OAuth 2.0 with the [Authorization Code Flow](https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow), which is the most common way to use OAuth 2.0 in a client app:

- On iOS, [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession)
- On Android, [Custom Tabs](https://developers.google.com/web/android/custom-tabs)

UniWebView also contains Unity Editor support on macOS for debugging purposes. You can bring up a standalone web view directly in the Play Mode of Unity Editor if you are developing your Unity game on macOS.

:::warning WINDOWS EDITOR
If you are working on a Windows PC, you can still build and use UniWebView on mobile devices, but you cannot see the result directly in the Windows Unity Editor. UniWebView does not come with Unity Editor support on Windows.
:::

:::tip MAC OS TARGET
UniWebView on macOS Editor is a full-featured variety of its iOS version. Although UniWebView is designed for mobile platforms, it does not prevent you from putting it into a standalone macOS game.
:::

## About Version 5

The start of the UniWebView project can be traced back to 2013. Until now, we shipped more than 120 versions to make sure the package works well with the latest technology. UniWebView version 5 is a huge step further. We worked even harder to bring more important features (like OAuth 2.0 support), rewrote the toolbar to extend it to Android, improved the performance on both platforms, and added a bunch of new features.

At the same time, we managed to keep the code compatibility for most of the APIs as they were in v4. That means upgrading from version 4 to version 5 is painless. For most of the projects, just reimport the new version and you can get all the new things immediately.

Already using UniWebView 4? Please take a look at the [Version Highlight](./version-highlight.md) to see how it gets evolved from the previous versions. To upgrade to the latest version, take a brief look at the [Migration Guide](./migration-guide-v4-to-v5.md). We also recommend you read our documentation to bring the potential power of UniWebView to your project.

> This documentation is for version 5. If you are still using v4, you can find its documentation on [this site](https://docs-v4.uniwebview.com) instead.

## Next Step

If you are ready, follow the [Installation](./installation.md) and subsequent guides to know the basic usage of UniWebView.

Please feel free to browse this documentation site and UniWebView's [APIs](/api). You can find more information on UniWebView's [official site](https://uniwebview.com) too.


---

### Adapting to AAR File

# Adapting to AAR File

> Upgrade to UniWebView 3.7.0+ by replacing UniWebView.jar with UniWebView.aar and updating the manifest.

The latest UniWebView uses AAR library instead of Jar file. If you were using UniWebView 3.6.x or earlier, and want to upgrade to 3.7.0 or later, you may need to follow these simple steps below, to keep your project working fine.

1. Remove `UniWebView.jar` from `Assets/Plugins/Android`.
2. Revert changes in your `AndroidManifest.xml`:
   - If you are using UniWebView's `AndroidManifest.xml` from a previous version without any modification, you could just delete it.
   - If you followed previous [installation guide to merge](/guide/installation.html#uniwebview-3-6-x-and-earlier) your manifest file for UniWebView, you need to revert the changes. Most importantly, you need to remove the `<activity android:name="com.onevcat.uniwebview.UniWebViewFileChooserActivity" />` declaration.
3. Import the new package and add `UniWebView.aar` to you project.


---

### Built-in Toolbar

# Built-in Toolbar

> The deprecated built-in toolbar in UniWebView has been replaced by the Embedded Toolbar; use the migration guide to switch.

::: danger DEPRECATED
This guide and the built-in toolbar is deprecated.

The built-in toolbar is fully replaced by the [Embedded Toolbar](./embedded-toolbar.md). Check and use that instead. If you are using the built-in toolbar, try to check the [migration guide](./migration-guide-v4-to-v5.md) and switch to the Embedded Toolbar as soon as possible.
:::

::: warning NOTICE
This guide is only for general-purpose web view on iOS. For Safe Browsing Mode, it is always presented with a toolbar,
containing navigation controls and the close button.

For the general-purpose web view running on Android, users may choose
to use system navigation buttons or gestures.
:::

### Show a toolbar

You can display a toolbar containing "Go Back", "Go Forward" and "Done" buttons on iOS. It makes easier if you want to
have a way to navigate between pages or close it. By default, the toolbar presents at the top or bottom of the screen,
with an iOS system toolbar:

```csharp
webView.SetShowToolbar(
  true,  // Show or hide?         true  = show
  false, // With animation?       false = no animation
  true,  // Is it on top?         true  = top
  true,  // Should adjust insets? true  = avoid overlapping to web view
);
```

It gives you a nice-looking toolbar:

![](/images/toolbar-default.png)

### Customization

#### Buttons Text

The text of all buttons are customizable:

```csharp
webView.SetToolbarGoBackButtonText("后退");
webView.SetToolbarGoForwardButtonText("前进");

webView.SetToolbarDoneButtonText("完成");
```

#### Tint Color and Text Color

The background color and text color is also customizable, with an opaque color:

```csharp
webView.SetToolbarTintColor(new Color(0.0f, 0.59f, 0.34f));
webView.SetToolbarTextColor(Color.white);
```

---

You finally get this after these customizations:

![](/images/toolbar-customized.png)


---

### Channel Message Security

# Channel Message Security

Channel Messages provide a communication bridge between web content and Unity. Meanwhile, it exposes another layer that the attackers might use. This guide covers security considerations and best practices for production applications.

## Security Overview

While the Channel Message system provides a flexible communication bridge, implementing proper security measures is your responsibility and it depends on how secure you'd like the system becomes. 

This guide recommends the following security practices:

- **Origin Validation**: Implement checks to verify message sources and prevent unauthorized communication
- **Input Sanitization**: Always validate and sanitize incoming data to protect against injection attacks
- **Message Authentication**: Consider using cryptographic signatures for sensitive operations
- **Replay Protection**: Implement nonce-based systems when replay attacks are a concern
- **Safe Data Handling**: Follow secure coding practices to prevent XSS and other vulnerabilities

It is not a must at all to use the Channel Message system. However, if your implementation involves sensitive information such as user personal data or payment details, or if it must meet higher security compliance standards, the default configuration may not provide sufficient protection. 

In the following section, we have listed some common practices that can enhance security for your reference.

## Basic Security Principles

### 1. Validate All Input

Never trust data from web content. Always validate and sanitize incoming messages:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    // Validate action names
    if (string.IsNullOrEmpty(message.action)) {
        Debug.LogWarning("Received message with empty action");
        return UniWebViewChannelMessageResponse.Error("Invalid action");
    }

    // Whitelist allowed actions
    var allowedActions = new HashSet<string> {
        "saveProgress", "loadGameData", "updateSettings"
    };

    if (!allowedActions.Contains(message.action)) {
        Debug.LogWarning($"Unauthorized action attempted: {message.action}");
        return UniWebViewChannelMessageResponse.Error("Action not allowed");
    }

    // Validate data structure
    if (message.action == "saveProgress") {
        if (!message.TryGetData<SaveProgressData>(out var data)) {
            return UniWebViewChannelMessageResponse.Error("Invalid data format");
        }

        if (data.playerId <= 0 || string.IsNullOrEmpty(data.levelName)) {
            return UniWebViewChannelMessageResponse.Error("Missing required fields");
        }

        // Process validated data...
    }

    return null;
};
```

### 2. Implement URL Validation

For sensitive operations, verify that messages come from trusted origins. Also, always use HTTPs to ensure the connection is safe:

```csharp
public class SecureChannelHandler {
    private readonly HashSet<string> trustedOrigins = new HashSet<string> {
        "https://yourgame.com",
        "https://cdn.yourgame.com",
        "https://api.yourgame.com"
    };

    public UniWebViewChannelMessageResponse HandleMessage(UniWebView webView, UniWebViewChannelMessage message) {
        // Get current URL
        string currentUrl = webView.Url;

        if (!IsOriginTrusted(currentUrl)) {
            Debug.LogWarning($"Message from untrusted origin: {currentUrl}");
            return UniWebViewChannelMessageResponse.Error("Untrusted origin");
        }

        // Handle trusted message...
        return ProcessTrustedMessage(message);
    }

    private bool IsOriginTrusted(string url) {
        if (string.IsNullOrEmpty(url)) return false;

        try {
            var uri = new System.Uri(url);
            var origin = $"{uri.Scheme}://{uri.Host}";
            return trustedOrigins.Contains(origin);
        } catch {
            return false;
        }
    }
}
```

### 3. Secure Sensitive Data

Never expose sensitive information unnecessarily:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "getUserInfo") {
        var userInfo = GetUserInfo();

        // Return only safe, public information
        var safeUserInfo = new {
            displayName = userInfo.displayName,
            level = userInfo.level,
            publicAchievements = userInfo.publicAchievements
            // DON'T include: passwords, tokens, private data
        };

        return UniWebViewChannelMessageResponse.Success(safeUserInfo);
    }

    return null;
};
```

## Advanced Security Features

### Message Authentication with Digital Signatures

For high-security applications, implement cryptographic message verification. Using a private key on your server to sign the message, and verify it in Unity side with the public key.

Here is some basic concept and pseudo code about how to perform it.

```csharp
using System.Security.Cryptography;
using System.Text;

public class SignedMessageHandler {
    private RSA publicKey;

    public void Initialize() {
        // Load your public key (private key stays on your server)
        publicKey = LoadPublicKey();
    }

    public UniWebViewChannelMessageResponse HandleSignedMessage(UniWebView webView, UniWebViewChannelMessage message) {
        if (message.action == "secureTransaction") {
            if (!message.TryGetData<SignedMessage>(out var signedData)) {
                return UniWebViewChannelMessageResponse.Error("Invalid message format");
            }

            // Verify signature
            if (!VerifySignature(signedData.payload, signedData.signature)) {
                Debug.LogWarning("Message signature verification failed");
                return UniWebViewChannelMessageResponse.Error("Invalid signature");
            }

            // Process verified message
            return ProcessSecureTransaction(signedData.payload);
        }

        return null;
    }

    private bool VerifySignature(string payload, string signature) {
        try {
            byte[] payloadBytes = Encoding.UTF8.GetBytes(payload);
            byte[] signatureBytes = System.Convert.FromBase64String(signature);

            return publicKey.VerifyData(payloadBytes, signatureBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        } catch {
            return false;
        }
    }
}

[System.Serializable]
public class SignedMessage {
    public string payload;    // The actual message data
    public string signature;  // Base64-encoded signature
    public long timestamp;    // Message timestamp
    public string nonce;      // Unique nonce to prevent replay
}
```

### Nonce-Based Replay Protection

Prevent replay attacks by tracking used nonces:

```csharp
public class ReplayProtectionHandler {
    private readonly HashSet<string> usedNonces = new HashSet<string>();
    private readonly Queue<(string nonce, DateTime timestamp)> nonceHistory = new Queue<(string, DateTime)>();
    private readonly TimeSpan nonceLifetime = TimeSpan.FromMinutes(10);

    public UniWebViewChannelMessageResponse HandleMessage(UniWebView webView, UniWebViewChannelMessage message) {
        if (message.TryGetData<NonceMessage>(out var nonceData)) {
            // Clean expired nonces
            CleanExpiredNonces();

            // Check for replay
            if (usedNonces.Contains(nonceData.nonce)) {
                Debug.LogWarning($"Replay attack detected: nonce {nonceData.nonce} already used");
                return UniWebViewChannelMessageResponse.Error("Message replay detected");
            }

            // Validate timestamp (prevent very old messages)
            var messageTime = DateTimeOffset.FromUnixTimeMilliseconds(message.timestamp).DateTime;
            if (DateTime.UtcNow - messageTime > nonceLifetime) {
                Debug.LogWarning("Message too old, rejecting");
                return UniWebViewChannelMessageResponse.Error("Message expired");
            }

            // Record nonce
            usedNonces.Add(nonceData.nonce);
            nonceHistory.Enqueue((nonceData.nonce, DateTime.UtcNow));

            // Process unique message
            return ProcessUniqueMessage(nonceData);
        }

        return null;
    }

    private void CleanExpiredNonces() {
        var cutoffTime = DateTime.UtcNow - nonceLifetime;

        while (nonceHistory.Count > 0 && nonceHistory.Peek().timestamp < cutoffTime) {
            var expired = nonceHistory.Dequeue();
            usedNonces.Remove(expired.nonce);
        }
    }
}

[System.Serializable]
public class NonceMessage {
    public string nonce;      // Unique identifier (UUID recommended)
    public string action;     // The actual action
    public object data;       // Message payload
}
```

## JavaScript Security Best Practices

### 1. Generate Secure Nonces

```javascript
// Generate cryptographically secure nonces
function generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}

// Use nonces in sensitive messages
function sendSecureMessage(action, data) {
    const message = {
        nonce: generateNonce(),
        timestamp: Date.now(),
        action: action,
        data: data
    };

    return window.uniwebview.request('secureAction', message);
}
```

### 2. Input Validation

```javascript
// Validate data before sending
function sendUserData(userData) {
    // Client-side validation (note: always validate server-side too)
    if (!userData.username || userData.username.length < 3) {
        throw new Error('Username must be at least 3 characters');
    }

    if (!isValidEmail(userData.email)) {
        throw new Error('Invalid email format');
    }

    // Sanitize input
    const sanitizedData = {
        username: sanitizeString(userData.username),
        email: sanitizeString(userData.email),
        preferences: sanitizeObject(userData.preferences)
    };

    return window.uniwebview.send('updateUser', sanitizedData);
}

function sanitizeString(str) {
    return str.replace(/[<>\"'&]/g, '');
}
```

### 3. Handle Errors Securely

```javascript
// Don't expose sensitive information in error handling
window.uniwebview.request('sensitiveOperation', data)
    .then(result => {
        processResult(result);
    })
    .catch(error => {
        // Log detailed errors for debugging (remove in production)
        console.error('Operation failed:', error);

        // Show user-friendly error messages
        showUserError('Operation could not be completed. Please try again.');
    });
```

## Production Security Checklist

### Before Deployment

- [ ] **Input Validation**: All message data is validated and sanitized
- [ ] **Action Whitelist**: Only explicitly allowed actions are processed
- [ ] **Origin Verification**: Messages from untrusted origins are rejected
- [ ] **Error Handling**: Sensitive information is not leaked in error messages
- [ ] **Logging**: Security events are logged for monitoring
- [ ] **HTTPS Only**: All web content is served over HTTPS
- [ ] **CSP Headers**: Content Security Policy headers are configured
- [ ] **Rate Limiting**: Implement rate limiting for message processing

### For High-Security Applications

- [ ] **Message Signing**: Cryptographic signatures verify message authenticity
- [ ] **Replay Protection**: Nonce-based system prevents message replay
- [ ] **Key Management**: Secure key storage and rotation procedures
- [ ] **Audit Trail**: Comprehensive logging of all security-relevant events
- [ ] **Penetration Testing**: Security testing by qualified professionals


## Common Security Pitfalls

### 1. Trusting Client-Side Validation

```csharp
// BAD: Only client-side validation
// JavaScript: if (amount > 0) window.uniwebview.send('purchase', {amount});

// GOOD: Always validate server-side
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "purchase") {
        var purchase = message.GetData<PurchaseData>();

        // Always validate on Unity side
        if (purchase.amount <= 0 || purchase.amount > 999.99m) {
            return UniWebViewChannelMessageResponse.Error("Invalid amount");
        }

        // Process valid purchase...
    }
    return null;
};
```

### 2. Exposing Internal APIs

```csharp
// BAD: Exposing internal system functions
if (message.action == "executeSQL") {
    // Never allow direct database access from web content!
}

// GOOD: Provide safe, specific APIs
if (message.action == "getHighScores") {
    var scores = GetTopScores(limit: 10); // Safe, limited operation
    return UniWebViewChannelMessageResponse.Success(scores);
}
```

### 3. Information Leakage in Errors

```csharp
// BAD: Detailed error messages
catch (System.Exception e) {
    return UniWebViewChannelMessageResponse.Error(e.ToString()); // Exposes stack traces!
}

// GOOD: Safe error messages
catch (System.Exception e) {
    Debug.LogError($"Channel message error: {e}"); // Log internally
    return UniWebViewChannelMessageResponse.Error("Operation failed"); // Safe public message
}
```

Remember: Security is a multi-layered approach. Implement appropriate measures based on your application's security requirements and threat model.

---

### Channel Message System

# Channel Message System

The Channel Message system provides a modern, efficient way for web pages to communicate with Unity. It offers three distinct communication patterns designed for different use cases.

## Overview

While UniWebView's traditional `uniwebview://` URL scheme messaging continues to work perfectly for simple scenarios, the Channel Message system introduces enhanced capabilities:

- **Better Performance**: Direct bridge communication without URL scheme overhead
- **Bidirectional Communication**: Unity can respond with data back to JavaScript
- **Structured Data**: Native JSON support for complex data types
- **Multiple Patterns**: Choose between fire-and-forget, synchronous, and asynchronous communication

## Communication Patterns

### Send (Fire-and-Forget)

Use `send` when you want to notify Unity about something but don't need a response.

**JavaScript**
```javascript
// Send a simple string
window.uniwebview.send('playerDied', 'Player fell into lava');

// Send structured data
window.uniwebview.send('updateScore', {
    score: 1500,
    level: 3,
    bonus: true
});
```

**Unity**
```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "playerDied") {
        var reason = message.GetData<string>();
        Debug.Log($"Player died: {reason}");

        // For send messages, always return null
        return null;
    }

    if (message.action == "updateScore") {
        var scoreData = message.GetData<ScoreData>();
        UpdateGameScore(scoreData.score, scoreData.level);
        return null;
    }

    return null;
};
```

In the example above, `GetData<T>` is used to extract a strong typed data from the `message`. It requires the data type being a valid `Serializable` with the correct fields:

```csharp
[System.Serializable]
public class ScoreData {
    public int score;
    public int level;
    public bool bonus;
}
```

### Call (Synchronous)

Use `call` when you need immediate data from Unity. The JavaScript execution waits for Unity's response.

**JavaScript**
```javascript
// Get user information synchronously
const userInfo = window.uniwebview.call('getUserInfo', {
    userId: '12345'
});

console.log(`Welcome ${userInfo.userName}!`);

// Get a simple value
const isVipUser = window.uniwebview.call('checkVipStatus');
if (isVipUser) {
    showVipFeatures();
}
```

**Unity**
```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "getUserInfo") {
        var request = message.GetData<UserInfoRequest>();
        var user = GetUserById(request.userId);

        // Return data immediately
        return UniWebViewChannelMessageResponse.Success(user);
    }

    if (message.action == "checkVipStatus") {
        bool isVip = PlayerPrefs.GetInt("isVip", 0) == 1;
        return UniWebViewChannelMessageResponse.Success(isVip);
    }

    return null;
};

[System.Serializable]
public class UserInfoRequest {
    public string userId;
}

[System.Serializable]
public class UserInfo {
    public string userName;
    public int userId;
    public string[] permissions;
}
```

In a sync calling, you need to return either a `UniWebViewChannelMessageResponse.Success` or a `UniWebViewChannelMessageResponse.Error` immediately. When an error is returned, the JavaScript side will have an exception and the web page can `try catch` it. See the [Error Handling](#error-handling) section below to know more about it.

### Request (Asynchronous)

Use `request` when the operation takes time (network calls, file operations, etc.). JavaScript receives a Promise that resolves when Unity responds.

**JavaScript**
```javascript
// Load game data asynchronously
window.uniwebview.request('loadGameData', {
    saveSlot: 1
}).then(gameData => {
    console.log(`Loaded level ${gameData.level} with score ${gameData.score}`);
    initializeGame(gameData);
}).catch(error => {
    console.error('Failed to load game:', error);
    showErrorMessage(error);
});

// With timeout (5 seconds)
window.uniwebview.request('syncToCloud', playerData, 5000)
    .then(() => console.log('Sync successful'))
    .catch(error => console.log('Sync failed:', error));
```

**Unity**
```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "loadGameData") {
        var request = message.GetData<LoadGameRequest>();

        // Start async operation
        StartCoroutine(LoadGameDataAsync(message, request.saveSlot));

        // Return null immediately for async requests
        return null;
    }

    if (message.action == "syncToCloud") {
        var playerData = message.GetData<PlayerData>();
        StartCoroutine(SyncToCloudAsync(message, playerData));
        return null;
    }

    return null;
};

private IEnumerator LoadGameDataAsync(UniWebViewChannelMessage message, int saveSlot) {
    // Simulate loading delay
    yield return new WaitForSeconds(1f);

    var gameData = LoadGameFromSlot(saveSlot);

    if (gameData != null) {
        // Respond with success
        message.Respond(gameData);
    } else {
        // Respond with error
        message.RespondError("Save slot not found");
    }
}

private IEnumerator SyncToCloudAsync(UniWebViewChannelMessage message, PlayerData data) {
    // Attempt cloud sync
    bool success = yield return StartCoroutine(PerformCloudSync(data));

    if (success) {
        message.Respond("Sync completed successfully");
    } else {
        message.RespondError("Network connection failed");
    }
}
```

## Error Handling

### JavaScript Error Handling

An error raised in Unity side will result in a catchable error in JavaScript:

```javascript
// For Request messages (Promise-based)
window.uniwebview.request('riskyOperation')
    .then(result => {
        console.log('Success:', result);
    })
    .catch(error => {
        console.error('Error:', error);
        // error contains the object passed to RespondError()
    });

// Call messages return data directly (no Promise)
try {
    const result = window.uniwebview.call('getData');
    processData(result);
} catch (error) {
    // Handle synchronous errors
    console.error('Call failed:', error);
}
```

### Unity Error Handling

When using either `UniWebViewChannelMessageResponse.Error` or `message.RespondError`, you can choose the error to be a plain string or an object. If you call these methods with a string, a JavaScript [`Error`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Error) object will be thrown in JavaScript; if you call with an object, the object will be thrown:

```csharp
webView.OnChannelMessageReceived += (view, message) => {

    // Sync Call
    return UniWebViewChannelMessageResponse.Error(new {
        reason = "Processing failed",
        details = e.Message
    });
    // JavaScript:
    catch (error) {
        error.reason // "Processing failed"
        error.details // $e.Message
    }

    // Async Request
    message.RespondError("A perfect error reason.")
    // JavaScript:
    .catch(error => {
        error // type is Error
        error.message // A perfect error reason.
    });
};
```

## Best Practices

### Choose the Right Pattern

- **Send**: User interactions, analytics events, simple notifications
- **Call**: Getting current state, validation checks, immediate data retrieval
- **Request**: File operations, network requests, database queries, any time-consuming operations

### Data Validation

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    // Always validate action names
    switch (message.action) {
        case "saveGame":
            if (!message.TryGetData<SaveGameData>(out var saveData)) {
                return UniWebViewChannelMessageResponse.Error("Invalid save data format");
            }

            if (string.IsNullOrEmpty(saveData.playerName)) {
                return UniWebViewChannelMessageResponse.Error("Player name is required");
            }

            // Process valid data...
            break;

        default:
            Debug.LogWarning($"Unknown action: {message.action}");
            break;
    }

    return null;
};
```

### Performance Considerations

```csharp
// Use message type properties to optimize handling
webView.OnChannelMessageReceived += (view, message) => {
    if (message.isFireAndForget) {
        // Handle fire-and-forget messages quickly
        ProcessQuickly(message);
        return null;
    }

    if (message.isSyncCall) {
        // Return immediately for sync calls
        return GetImmediateResponse(message);
    }

    if (message.isAsyncRequest) {
        // Start async processing
        StartAsyncOperation(message);
        return null;
    }

    return null;
};
```

### Calling Thread

To achieve better performance, UniWebView does not change the thread that the OS uses to call the JavaScript. That means, on iOS, the `OnChannelMessageReceived` is called on the main thread; but on Android, it is called in a background thread. If you are trying to access any Unity GameObject or its properties on Android, you may encounter this error:

> `<UniWebView>` Error in channel message handler: get_isActiveAndEnabled can only be called from the main thread.
>
> Constructors and field initializers will be executed from the loading thread when loading a scene.
> Don't use this function in the constructor or field initializers, instead move initialization code to the Awake or Start function.

To solve this, you can choose either:

1. You can choose to use the `UniWebViewMainThreadDispatcher` to dispatch the method to main thread.

```csharp
Text label;

webView.OnChannelMessageReceived += (view, message) => {
    // This causes thread issue on Android
    // label.text = message.action;
    
    // Wrap it in a dispatcher.
    UniWebViewMainThreadDispatcher.Instance.ExecuteOnMainThread(
        () => label.text = message.action
    );
}
```

2. Or, if you do not want to introduce the dispatcher, you can separate the data and the UI or GameObject actions, only accessing the data in `Update`:

```csharp
string action = ""
Text label;

webView.OnChannelMessageReceived += (view, message) => {
    // This causes thread issue on Android
    // label.text = message.action;
    
    // Instead, just set `action` string and update it later.
    action = message.action;

    // ...
};

void Update() {
    label.text = action
}
```

### Debugging

Enable verbose logging to see all channel message activity:

```csharp
void Start() {
    // Enable detailed logging
    UniWebViewLogger.Instance.LogLevel = UniWebViewLogger.Level.Verbose;
}
```

The logger will output information about:
- Message types and actions received
- Response validation
- Error conditions
- Performance warnings

### Consider Security

If your implementation involves sensitive information such as user personal data or payment details, or if it must meet higher security compliance standards, the default configuration may not provide sufficient protection. 

We strongly recommend reviewing the [Security Consideration](./channel-message-security.md) guide for best practices and advanced topics regarding validation, message signing and key management.


---

### Debugging

# Debugging

> Use UniWebView's debugging tools, including the logger, web log forwarding, and web page inspection on iOS, Android, and macOS.

## UniWebView Logger

UniWebView could provide detail logs. It helps you to understand what happens in UniWebView.

There are 5 log levels, following the order of verbosity, they are:

- **Verbose**: The most detailed logging level. It prints out almost all events.
- **Debug**: Good for the general debugging purpose. It prints most of the events.
- **Info**: Fewer logs than Debug level, but will cover quite a few important events.
- **Critical**: This is the **default value** of the built-in logger. It only prints out error messages you need to notice.
- **Off**: Turning off the logger.

`UniWebViewLogger` class takes the responsibility to print log out to console on all platforms. You can set the log level by the code below:

```csharp
// Set the log level to Verbose
UniWebViewLogger.Instance.LogLevel = UniWebViewLogger.Level.Verbose;
```

The log message from UniWebView will start with a tag for each platform: `<UniWebView>`, `<UniWebView-iOS>`,
`<UniWebView-Android>`, `<UniWebView-macOS>`. It would be helpful if you want to search in your logs.

For more information on `UniWebViewLogger`, please refer to its [documentation](../api/uniwebviewlogger.md).

## Forwarding Web Logs to Unity

When it is necessary to confirm issues on the website, it may be required to check the web logs (such as through
JavaScript's `console.log` and other similar methods). UniWebView provides a convenient method to forward logs from the
web to Unity.

For performance and security reasons, this forwarding is turned off by default. To enable web log forwarding, you can
call `SetForwardWebConsoleToNativeOutput` before creating a web view:

```csharp
UniWebView.SetForwardWebConsoleToNativeOutput(true);

webView = webViewGO.AddComponent<UniWebView>();
webView.Load("https://your-website.com");
webView.Show();
```

> It is recommended to enable this feature only when necessary, and disable it when not needed.

## Inspecting Web Page

Sometimes, you need to inspect your web page, to modify some DOMs, stylesheets, or watching result of a JavaScript.
UniWebView supports to inspect your page in a browser dev tool in Chrome or Safari.

### iOS

On iOS, you need to call the [`SetWebContentsDebuggingEnabled`](/api/#setwebcontentsdebuggingenabled) method first. Then
you could just run and show your web page in UniWebView on an iOS device or simulator.

Follow the [Safari Web Inspector Guide](https://developer.apple.com/library/content/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html) to set up your inspector in Safari.

Please be noted, only binaries built with the Debug configuration can be inspected. The Release build does not work.

### Android

On Android, you need to call the [`SetWebContentsDebuggingEnabled`](/api/#setwebcontentsdebuggingenabled) method first.
It will allow Chrome to discover and connect to the web view on Android. Follow the
[Remote Debugging WebViews](https://developer.chrome.com/docs/devtools/remote-debugging/webviews/) topic to know how to
use Chrome DevTools with UniWebView.

### macOS

On macOS you need to call the [`SetWebContentsDebuggingEnabled`](/api/#setwebcontentsdebuggingenabled) method first.
Then you can right-click on the web view in macOS editor to bring up the context menu. Select the "Inspect Element" in
that menu.

![](/images/editor-inspector.png)

::: warning
Due to a memory bug under WebKit and Unity, it might crash your macOS Editor when you stop playing with an inspector
showing embedded in a web view. To avoid this, close the inspector first or use it as a standalone window. This issue
only happens in the editor and never affects real devices. Please remember to not enable the
`SetWebContentsDebuggingEnabled` in your product build. This feature should be only used in development.
:::


---

### Downloading Files

# Downloading Files

> UniWebView manages file downloads with platform-specific behaviors, offering iOS customization for URLs and MIME types, and supports download events and data/blob links.

Normally, UniWebView will render the content of the visited page (e.g. HTML). However, if the response provided by the server is a non-renderable content like a binary file, UniWebView will try to download the file corresponding to the URL instead.

The file download should work correctly without any additional configuration. However, there are some differences in the file downloading behavior between iOS and Android due to the differences in how they handle file download requests. This document will explain this topic.

## Android

For Android, there are not many configurable options.

When accepting a resource that cannot be rendered, UniWebView will pop up a dialog asking the user for the file name they wish to use. By default, the file name will be read from the `Content-Disposition` header of the received response. After confirming the file name, the file will be stored in the app's `Download` folder. Users can find the downloaded file by accessing `Download` through the Notification Center banner or Android's File app.

## iOS

Unlike Android, Web View on iOS has a more powerful rendering engine and a more rigid file system. As a result, we need to provide more customization options for iOS.

### Inspecting URLs and MIME types

Some files can be rendered directly in the iOS web view, but not in Android. For example, a PDF document: in the Android web view, the PDF document will trigger the download behavior, while in iOS, the web view will try to load and display the content. In most cases, this is probably the result you want. However, if you want to keep the download behavior consistent between iOS and Android, you can set the URL and MIME type that needs to be downloaded on iOS.

UniWebView maintains two lists on iOS: the URL that needs to trigger a download, and the MIME type that needs to trigger a download. iOS UniWebView will determine if a download is to be performed in the following order:

1. Whether the requested URL is in the URL list.
2. Whether the MIME type of the response is in the MIME type list.
3. Whether the MIME type of the response is a type that can be rendered.

If any one of the three conditions is `true`, UniWebView will pop up a dialog asking the user for the file name and download it.

Here is an example of adding items to the lists and its result on iOS:

```csharp
// Instead of rendering the image.png in the web view, this will trigger a download of the image at this specified URL.
webView.AddDownloadURL("https://example.com/image.png");
webView.Load("https://example.com/image.png");

// Instead of rendering the PDF in web view, this will trigger a download of all PDF files,
// if the response contains a `application/pdf` content type header.
webView.AddDownloadMIMEType("application/pdf");
webView.Load("https://example.com/receipt.pdf");

// For the types that cannot be rendered, a download will be triggered without any configuration.
webView.Load("https://example.com/files.zip");
```

#### Using Regular Expression

The default behavior tries to match the exact values for URL and MIME type. For example, adding download URL `https://example.com/image.png` won't make `https://example.com/image.png?size=100x100` downloadable. To allow a pattern, use `UniWebViewDownloadMatchingType.RegularExpression` to call the related APIs:

```csharp
webView.AddDownloadURL("^https://example\\.com/image\\.png.*$", UniWebViewDownloadMatchingType.RegularExpression);
// Download from
//   "https://example.com/image.png",
//   "https://example.com/image.png?size=100x100" or
//   "https://example.com/image.png/download", etc.
// But not from
//   "https://example.com/image.jpg" since it does not match.

webView.AddDownloadMIMEType("^image/.*$", UniWebViewDownloadMatchingType.RegularExpression);
// Download resources with MIME type
//    "image/jpg",
//    "image/png" and more.
// But not
//    "application/pdf".
```

When using `UniWebViewDownloadMatchingType.RegularExpression`, the first parameter accepts a regular expression pattern string.
Since these APIs are only for iOS, you need to pass a regular expression pattern following Objective-C regular express syntax.
Read the [related documentation](https://developer.apple.com/documentation/foundation/nsregularexpression#1661042) from Apple for more.

::: warning
When using `UniWebViewDownloadMatchingType.RegularExpression`, please make sure you are passing a valid regular
expression pattern string to the first parameter. Please be careful it requires a **regular expression** pattern string,
rather than a **wildcard** pattern string (such as `image/*`, which might not be working).
:::

### Post-Downloading Action

The file permission on iOS is much stricter than on Android. Although the downloaded files are stored temporarily in your app's sandbox folder, your user cannot browse them directly before they choose to move these files to another location (eg. iCloud Disk or Dropbox) or another app (eg. File app of iOS). By default, UniWebView will show a system default share panel to let the user choose where to send the files to. Like this:

![](/images/file-share.png)

If you do not want to let user choose an action after downloading on iOS, call:

```csharp
webView.SetAllowUserChooseActionAfterDownloading(false);
```

## Download Events

UniWebView will rise some events related to the download task.

To observe the start of downloading, listen to the `OnFileDownloadStarted` event. For the finishes event, use `OnFileDownloadFinished`:

```swift
webView.OnFileDownloadStarted += (view, remoteUrl, fileName) => {
    Debug.Log(string.Format("Download Started. From '{0}', file name '{1}'", remoteUrl, fileName));
};

webView.OnFileDownloadFinished += (view, errorCode, remoteUrl, diskPath) => {
    if (errorCode == 0) { // Success
        Debug.Log(string.Format("Download Finished. From '{0}', to '{1}'", remoteUrl, diskPath));
    } else {
        Debug.LogError("Download error: " + errorCode);
    }
};
```

The `OnFileDownloadFinished` will be called when either the download succeeds or fails. When failure, a non-zero `errorCode`
will be contained in the event callback body. This code varies based on the platform. On iOS or macOS editor, it is usually
the `errorCode` of a received [`NSURLError`](https://developer.apple.com/documentation/foundation/urlerror) object.
While on Android, it is usually an error case in [`DownloadManager`](https://developer.android.com/reference/android/app/DownloadManager),
which starts with `ERROR_`. For example, [`1004` for `ERROR_HTTP_DATA_ERROR`](https://developer.android.com/reference/android/app/DownloadManager#ERROR_HTTP_DATA_ERROR).

If you need to handle these errors, write code for different cases for different platforms.

## Data Link and Blob Link

UniWebView supports downloading from [data link](https://developer.mozilla.org/en-US/docs/Web/URI/Reference/Schemes/data) and [blob link](https://developer.mozilla.org/en-US/docs/Web/API/Blob). A system alert dialog will be presented to the user to decide the download file name and post-download action.

When dealing with blob link, UniWebView will try to fetch the content of the blob link. You need to make sure the blob link is available during the loading. That means, you should not call the `URL.revokeObjectURL(blobURL);` in your JavaScript too early. A possible and naive way to handle this is delaying the revoking call for a while:

```javascript
var url = URL.createObjectURL(blob);
var a = document.createElement("a");
a.href = url;
a.download = "sample.png";
a.click();

// Delay the revoke call for a while.
setTimeout(() => {
  URL.revokeObjectURL(url);
}, 500);
```

## Some Limitation

On iOS, there is no system-level web view downloading support. So UniWebView starts a new standalone GET request to the URL to start a download.
That means you have to host your downloadable content in a GET request instead of using a POST (say, downloading after submitting an HTML form with POST request).

The stored cookies for the downloading URL and [customized headers](/api/#setheaderfield) will be applied to download tasks.
So if you need to implement some authentication when downloading, use either or both to identify your users, and provide the downloadable content with a GET request.


---

### Embedded Toolbar

# Embedded Toolbar

> UniWebView's embedded toolbar can be shown, customized in position, text, and colors, and managed through events like OnShouldClose for proper web view handling.

UniWebView contains an embedded toolbar that can be displayed with the web view. In this guide, we will discuss how to use the embedded toolbar and the way it can be customized.

### Showing a toolbar

Each `UniWebView` component contains an `EmbeddedToolbar` property. You can just call `Show()` on it to make the toolbar visible:

```csharp{5}
var webView = webViewGameObject.AddComponent<UniWebView>();
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
webView.Load("https://uniwebview.com/");

webView.EmbeddedToolbar.Show();
```

It shows a toolbar with Go Back, Go Forward and Done buttons on both iOS and Android:

![](/images/toolbar-compare.png)

### Handling Done Button

Similar to the [Clean Work section](./working-with-code.md#listening-to-the-event), if you have a reference for the web view component, you need to clean it in the `OnShouldClose` event.

```csharp{10-13}
public class MyMonoBehaviour : MonoBehaviour {
    UniWebView webView

    void ShowWebView ()
    {
        webView = webViewGameObject.AddComponent<UniWebView>();

        // ...

        webView.OnShouldClose += (view) => {
            webView = null;
            return true;
        };
    }
}
```

`OnShouldClose` will be triggered when user taps the Done button in the toolbar. If you do not want the user to close it, you can also return a `false` in `OnShouldClose` and perform your logic there. In that case, to close the web view, you can just pass the `webView` reference to the `Destroy` method:

```csharp
void CloseWebView() {
    Destroy(webView);
    webView = null;
}
```

To know more about the cleaning work and memory management, please refer to the [related topic](./memory-management.md).

### Customization

UniWebView provides several ways to customize the style of the toolbar.

##### Position

```csharp
webView.EmbeddedToolbar.SetPosition(UniWebViewToolbarPosition.Bottom);
```

##### Buttons Text

```csharp
webView.EmbeddedToolbar.SetGoBackButtonText("后退");
webView.EmbeddedToolbar.SetGoForwardButtonText("前进");

webView.EmbeddedToolbar.SetDoneButtonText("完成");
```

##### Title Text

```csharp
webView.EmbeddedToolbar.SetTitleText("UniWebView");
```

##### Colors

```csharp
webView.EmbeddedToolbar.SetButtonTextColor(Color.white);
webView.EmbeddedToolbar.SetTitleTextColor(Color.white);
webView.EmbeddedToolbar.SetBackgroundColor(new Color(0.0f, 0.59f, 0.34f));
```

With these customization, we can get the result as below on iOS and Android:

![](/images/embedded-toolbar-customize.png)

For more about the Embedded Toolbar APIs, check its [API reference](/api/uniwebviewembeddedtoolbar.md).


---

### FAQ

---
sidebarDepth: 0
---

# FAQ

> UniWebView FAQ addresses common issues and queries about usage, platform support, performance, privacy, licensing, and source code access, providing solutions and explanations for developers.

[[toc]]

## Can I put some Unity GUI/object above of UniWebView?

By default, the UniWebView is a layer of the system UI and is added above the whole Unity view. You can never put your
elements from Unity above the native web page.

However, you can **render the web page to a texture** and use it in your 3D world. In this way, it is possible to put Unity
elements above the web view. But it comes with some limitations, such as not interactive and no video rendering.
See the [Render as Texture](/guide/render-as-texture.md) guide for more details.

## I cannot build for Android after importing UniWebView

We prepared a [Trouble Shooting guide](./trouble-shooting.md) for this issue. Please check and follow the Android Section there to see if it helps.

## The page does not load on Android but shows "net::ERR_CLEARTEXT_NOT_PERMITTED".

From Android 9, all plain HTTP traffic is not permitted by default for security. You can find detail on this topic in this [Android documentation page](https://developer.android.com/training/articles/security-config).

Developers are encouraged to secure traffic only, such as HTTPS. Hosting all of your content under a site with HTTPS enabled is the best solution. However, if that is not possible for you yet, you can enable the **"Uses Cleartext Traffic"** option in UniWebView's preference.

You can find that option under the "UniWebView" tab of Unity's Preference Panel. Follow [the installation guide](installation.md#importing-package) if you are not sure where it is.

## I encountered "net::ERR_UNKNOWN_URL_SCHEME" when opening an app link on Android.

UniWebView is already trying to bring up an intent (trying to open a third-party app if a custom scheme URL is received) internally.
But UniWebView has to use the [`queryIntentActivities` method](https://developer.android.com/reference/kotlin/android/content/pm/PackageManager#queryintentactivities)
to check if the target app exists before opening it.

It worked perfectly without any modification if you are using a Target API Level before Android 11 (Level 31) or on devices with lower system versions.
But from API Level 31, you have to add the related query to the Android manifest file to allow this querying work. For more details, I suggest you check
the [Package visibility filtering on Android](https://developer.android.com/training/basics/intents/package-visibility) and
[Declare package visibility needs](https://developer.android.com/training/package-visibility/declaring) documentation and try to add the target package
names you need to open to the `<queries>` tag to your Android Manifest file, then try again to see if it goes fine. For example, if you
need to open a Facebook link like `fb://page?id=123456`, you should add the following to your Android Manifest file:

```xml
<manifest package="com.example.game">
    <queries>
        <package android:name="com.facebook.katana" />
    </queries>
    ...
</manifest>
```

You can find the package name of an app in the URL of its Google Play page.

## I encountered "could not reparse object file in bitcode bundle: 'Invalid bitcode version" when archiving the iOS app in Xcode.

Please try to disable the BitCode in your Xcode project. In your exported project, select "Unity-iPhone" project file in the left Project navigator panel.
In the editor area on right, select "Unity-iPhone" under the "PROJECT" section (be noted, do not select the "Unity-iPhone" under "TARGETS" section),
then in the "Build Settings" tab, search for "Enable Bitcode" item and change its value to "No".

> From Xcode 14, BitCode is no longer required or supported. UniWebView will also remove the support of BitCode eventually.

## Which platforms could UniWebView work on?

UniWebView supports running on:

- **Unity 2020.1** or above
- **iOS 9.0** or above
- **Android 5.0** (API Level 21) or above

UniWebView also contains Unity Editor support on macOS for debug purposes. If you are working on a Windows PC, you can still build and use UniWebView on mobile devices, but you cannot see the result directly in the Windows Unity Editor.

## Sometimes the web page session is not kept on iOS.

On iOS, the web view is running in another self-managed process. It always takes some time (typically several seconds) to synchronize your cookie/session to the cookie storage. So if you destroy the web view too soon before the storage could be synced, the cookie/session information might be lost. This behavior is more likely a limitation of `WKWebView` on the iOS system.

## I have a performance issue, the page is loading/running laggy.

UniWebView is a wrapper of the web view components on iOS or Android. So you can expect similar performance for your page when they are running with UniWebView against when running with `WKWebView` on iOS or `WebView` on Android. However, please remember you are displaying the web content inside Unity, which is also taking a lot of resources to run.

Due to these facts, it is not surprising that your web page might be slower than normal, especially if you have heavy tasks running in your Unity game. If you hit a performance issue in the web view, we suggest you can try below:

1. Turn off all cameras in your game whenever possible (for example, if the game scene is below the web view and invisible). It reduces a lot of rendering pressure and the system can focus on rendering the web content instead.
2. Stop all unnecessary scripts in your scene, especially those contain heavy logic inside `Update`, `FixedUpdate` or `LateUpdate`.
3. Unload and release the unused resource as much as possible.
4. If possible, try to create a clean and new scene to display the web view.
5. If possible, choose to use [Safe Browsing Mode](./safe-browsing.md) instead of a general-purpose web view.

Usually, the performance of the web view component shipped on the system is also improving with the new system version. For example, we can observe about 50% boost from a web view on Android 9.0, compared to Android 5.0. Changing the deploy target of your app is also an important way to improve the performance.

## Does UniWebView collect any privacy data? How to fill out the Apple Privacy Declaration?

UniWebView does not collect any user privacy information, nor does it use any of the privacy-related APIs listed in the Apple Privacy Manifest document. Therefore, you can completely ignore the UniWebView part when filling out Apple's privacy declaration.

## Does this package support Unity Personal or does it only work in Unity Professional?

UniWebView can work well on all supported platforms with both Unity Personal and Profession.

## Is there a trial version?

No, we don't provide a trial currently. That is mainly because there is no good way to protect a Unity package without harming the experience of our customers. Instead of a trial version, we promise a no-reason refund if you decide not to use it in your project. If you purchased in Unity Asset Store, you can request a refund in your Order History. If you purchased from our Gumroad Store, just send us your invoice number and mail address and we will issue a refund for you.

## What's the license type?

You can use UniWebView in all your projects with the same Unity ID exporting the final product. But if you need to use another Unity ID, you need to purchase another license.

You should observe the [EULA of Unity Asset Store](https://unity3d.com/company/legal/as_terms) you agreed to when you registered your Unity Asset Store account. That means you have no right to reproduce, duplicate, copy, sell, trade or resell the package.

## Can I get the source code?

All C# source code for the Unity side is included in the package. However, the native side is only distributed in binary format. The source code (Objective-C for iOS and macOS, Kotlin for Android) is not included in the asset store package.

If you need access to the native side source code, we offer a **Source Access License** for our main development repository. We host this project and all its code on GitHub. With the Source Access License, your GitHub account will be added to our repository, allowing you to access or modify the source code as needed. To purchase a Source Access License, please check the [pricing on our website](https://uniwebview.com/#prices).

## How long will I get the free updates for it?

You can purchase this package from both our digital store and the Unity Asset Store. Please visit our [official site](https://uniwebview.com/#prices) for more information. While you can receive full support from either store, we recommend buying it from our digital store to receive quicker updates.

You will receive all minor and patch updates for free until the next major version (excluding the major version itself). In the event of significant changes in Unity or the system webview, we may need to introduce breaking changes and maintain (or even re-create) the package for improved usability and stability. When this happens, we will release a new major version.

The Source Access License includes free lifetime upgrades, even for major version updates.

## Can I embed UniWebView in my own assets?

You cannot do that under the standard [EULA of Unity Asset Store](https://unity3d.com/company/legal/as_terms) term. But by purchasing the Source Access License, you also get a so-called **Limited Redistribution License**. It allows you to redistribute your own package with UniWebView as a dependency to other developers (or say, you are developing an SDK or something else which does not target to the "end users", but to other developers). In this case, you can redistribute UniWebView in **binary format** to third-party developers.

The detail of the **Source Access License** is provided as below:

> - You are permitted to use the source code in this repository as many projects as you want. But these projects should be owned by the same
>   person or organization made the purchase.
> - You are permitted to modify the source code, compile your own version and use the recompiled version in as many projects as
>   you want, if these projects are owned by the same person or organization made the purchase.
> - The source code and repository is for your own use only. You are NOT permitted to redistribute or share the repository without prior
>   authorization.
> - You are permitted to redistribute the UniWebView package which contains a built version for native code to third-party developers. However, they do not
>   grant the same Source Access License. They are not permitted to redistribute the package again. Only using UniWebView in the enclosure of your product is
>   permitted.
>
> All code and assets provided in this repository are provided on an “as is” basis, without warranty of any kind, express or implied,
> including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no
> event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of
> contract, tort or otherwise, arising from, out of or in connection with the software or the use or other dealings in the software.

Feel free to [contact us](https://onevcat.atlassian.net/servicedesk/customer/portal/2/group/2/create/10011) if you have any question on it. We are glad to help.


---

### HTTP Authentication

# HTTP Authentication

> UniWebView supports HTTP Basic and Digest authentication, prompting users for credentials and storing them permanently, with options to clear stored credentials on iOS and Android.

UniWebView supports HTTP authentication by prompting the user to provide a username and password in a native way.
You could use either HTTP Basic or HTTP Digest to set up the authentication flow. For more information about
HTTP authentication on the server-side and to get a general idea, please refer to [this documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).

### HTTP Authentication in UniWebView

UniWebView has a built-in support for HTTP authentication. When receiving a challenge of HTTP Basic or HTTP
Digest, it will pop up a native alert to ask users for username and password.

![](/images/httpauth.png)

Once the authentication gets passed, the username and password will be stored in a local database. This information is bound to host and realm from the requested protection space as a credential.

The persistence of stored credential is permanent, so your user will not be prompted again to re-authenticate until your server returns code 401.

::: warning NOTICE
On macOS, the credentials are stored in system Keychain. Depending on your settings of the corresponding item, there might be a chance that you cannot access Keychain item directly from Unity Editor. You need to change the Access Control of the keychain item to "Allow all applications to access this item". See this [support article](https://support.apple.com/kb/PH18682) for more.
:::

### Clear Stored Credentials

If the default permanent store strategy is not what you what, you could clear a certain credential as you need.

Call the `ClearHttpAuthUsernamePassword` static method on `UniWebView` and pass the host and realm.
On iOS, it will clear the credentials immediately and completely from both disk and network cache.
However on Android, it only clears from disk database, the authentication might be still cached in the network stack and will not be removed until next session (app restarting).

See [documentation](/api/#clearhttpauthusernamepassword) of `ClearHttpAuthUsernamePassword` for more.


---

### Installation

# Installation

> UniWebView installation involves importing the package from Unity Asset Store or UniWebView Store, configuring necessary permissions in Unity Preferences, and optionally accessing the source code via a GitHub repository.

::: warning IMPORTANT
We strongly recommend that you perform a backup before importing UniWebView to your project. If you are using any [version control system](https://en.wikipedia.org/wiki/Version_control) (like Git or SVN), it should be definitely safe to continue.
:::

### Unity Asset Store

If you purchased UniWebView from [Unity Asset Store](https://assetstore.unity.com/packages/slug/229334), open the Asset Store window from **Window → Asset Store** or **Window → Package Manager**. You could find UniWebView 5 there under **My Assets**, then click "Import".

### UniWebView Store

Besides of Unity Asset Store, we also have [our own store](https://onevcat.gumroad.com/l/uniwebview-5). After purchasing from our store, you could download the `uniwebview_x_y_z.unitypackage` (`x_y_z` in the file name indicates the package version). Open your project in which you want to use UniWebView, then double-click the downloaded file to import it.

### Source Repo Access

For users who want to access the source code of UniWebView, we [provide a plan](https://uniwebview.com/#prices) to get access to the repo of UniWebView that is hosted on GitHub. If you purchased the Source Access License, you can choose either build your own package or directly download the pre-built `unitypackage` file from the GitHub release page from the repo.

## Importing Package

Unity will prompt you with a window to confirm the importing files. Just click "Import" to add all files to your project.

> The minimum deploy target of UniWebView is from iOS 9.0 and Android 5.0 (API Level 21). If you are still using an older deploy target for you
> Unity project, you may have some issues when exporting the project to the final product. Please make sure to update the
> Target minimum iOS Version and Minimum API Level in the player settings.

![](/images/importing-v5.png)

### Restarting Unity

Restart the Unity app to give it a chance to load the UniWebView bundle for macOS Editor support. Remember to switch your build target in Player Setting
to either iOS or Android, since UniWebView only works on these two platforms. Otherwise, UniWebView gives a warning, saying the platform is not supported yet.

### Optional Steps

After importing UniWebView, you can open the Unity Preferences panel (**Unity → Preferences**) to configure some necessary permissions. In most cases, there is no need to adjust them and your project should build and run well. If your project can build without issues on both iOS and Android, you can skip these steps below and check the [next chapter](./using-prefab.md).

If you have any errors when building, you can use this panel to customize how UniWebView should adjust some behaviors or dependencies installation.

UniWebView uses a post-build script to modify the gradle project and "AndroidManifest.xml" file for the exported Android project.

![](/images/preferences-v5.png)

### Android Manifest

Settings in this section will be used to adjust the final `AndroidManifest.xml` file of the exported project.

#### Uses Cleartext Traffic

Set `usesCleartextTraffic` flag to `true` in the "AndroidManifest.xml". From Android 9.0, all plain HTTP traffic is forbidden by default.

If you need to display plain HTTP content in the web view, turn it on.

#### Write External Storage

Add `WRITE_EXTERNAL_STORAGE` permission to the "AndroidManifest.xml". It enables storing an image from the web page to the Download folder on the device.

If you need to download and save any files to disk, turn it on.

#### Access Fine Location

Add `ACCESS_FINE_LOCATION` permission to the "AndroidManifest.xml". It enables the web view to use the location information. To get the location actually, you also need to call [`LocationService.Start`](https://docs.unity3d.com/ScriptReference/LocationService.Start.html) before you open a web page.

If you need to use location APIs on the web, turn it on.

### Gradle Build

You can use settings in this section to modify the `build.gradle` behavior when exporting the project. By default, UniWebView
will add all dependencies it needs. However, if you are using another package manager or some embedded libraries, a duplication might
happen when exporting to Android APK file. In this case, you can try to disable a certain option below to let UniWebView use the existing package instead.

#### Adds Kotlin

Whether Kotlin runtime should be added to the project. UniWebView for Android is written in Kotlin and you need the runtime in your project to run the code. It is on by default.

If any other packages of your project is already adding this, you can opt-out this option to skip adding Kotlin to the project.

#### Adds Android Browser

Whether the [androidx.browser package](https://developer.android.com/jetpack/androidx/releases/browser) should be added to the project.
UniWebView uses some features in that package. It is on by default.

If any other packages of your project is already adding this, you can opt-out this option to skip adding the browser package to the project.

#### Enable Jetifier

[Jetifier](https://developer.android.com/studio/command-line/jetifier) migrates your support-library-dependent libraries to compatible with AndroidX.
UniWebView requires `androidx.browser` package, which is only available as an AndroidX package. Making it on can allow to keep using AndroidX support libraries (if there are). It makes your project cleaner.

If you have to use a legacy support library and it cannot be migrated for some reason, disable this setting.

### Auth Callbacks

This is set of OAuth 2.0 settings. You need to set the OAuth 2.0 callback URLs you want to support in this section. See the [OAuth 2.0 guide](./oauth2.md) for more information.

## Next Step

Congratulations! You are prepared to use UniWebView in your project now. Please read [next chapter](./using-prefab.md) to know how to use the simplest prefab way to show a web page.


---

### Loading Local Files

# Loading Local Files

> UniWebView supports loading local HTML files from the StreamingAssets folder or persistent data path, with specific considerations for Android builds using "Split Application Binary."

## From Game Bundle

You can load local HTML files through the web view if you put them to the [StreamingAssets folder](https://docs.unity3d.com/Manual/StreamingAssets.html) (`Assets/StreamingAssets/` folder in the Unity project).

There is a helper method `UniWebViewHelper.StreamingAssetURLForPath` to get the correct path on all platforms. By passing the relative path of your HTML file, you get a URL pointing to the page. Then load it with the `Load`.

For example, if you have a page under the path: `Assets/StreamingAssets/local_www/index.html`, you can load it with:

```csharp
var url = UniWebViewHelper.StreamingAssetURLForPath("local_www/index.html");
webView.Load(url);
```

All resources in the HTML file are also available if they are put in the correct place. Assume the content of "local_www/index.html" file is:

```html {4}
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <h1>Styled heading</h1>
  </body>
</html>
```

And if you have the "style.css" in the same folder:

```css
/* Assets/StreamingAssets/local_www/style.css */
h1 {
  color: red;
}
```

Then your style file can be loaded and the page is styled. It is the same for other resources, such as images and videos.

::: warning Resource Folder
On iOS and macOS, when you use the `Load` method to load a local page, by default, only the resources in the same folder are visible to your page.

If your resources are located in another folder, you could pass a `readAccessURL` parameter when you call `Load`. See the [API Reference](https://docs.uniwebview.com/api/#load) of this parameter for more.
:::

### Using "Split Application Binary"

If you are using "Split Application Binary" for Android build (OBB files), your local HTML files in the OBB bundle cannot be accessed directly by WebView. UniWebView provides an automated solution to handle this.

#### Before Unity 2021.2

If you are still using Unity 2021.1 or any earlier version, you can put your files to `Assets/Plugins/Android/assets/`
and then use the same way as you did for normal streaming assets resource to load it from the new location.

#### Unity 2021.2 and later (Automated Solution)

From Unity 2021.2, the Unity Editor prevents the existence of `Assets/Plugins/Android/assets/`. UniWebView now provides an automated solution:

1. **Configure Asset Folders**: Open **Preferences > UniWebView** (or **Edit > Project Settings > UniWebView** in Unity 2019.1+)
2. **Add Folders to Copy**: In the "Android Assets" section, add the folders you want to be accessible in OBB builds
3. **Build Normally**: When you export as Android Gradle Project, UniWebView will automatically copy the configured folders to the correct location

##### Example: Web Content Outside StreamingAssets

If you have web content in `Assets/WebContents/` (not in StreamingAssets):

```
Assets/
├── WebContents/
│   ├── index.html
│   ├── style.css
│   └── images/
│       └── logo.png
```

**Step 1: Configure UniWebView Settings**
- Open Preferences > UniWebView
- In "Android Assets" section, add: `WebContents`
- This tells UniWebView to copy this folder to Android assets during build

**Step 2: Load the Content**
```csharp
// After configuration, the files will be accessible at the configured path
var url = UniWebViewHelper.StreamingAssetURLForPath("WebContents/index.html");
webView.Load(url);

// This will resolve to "file:///android_asset/WebContents/index.html" on Android
// The folder will be automatically copied there during Gradle export
```

##### Example: Traditional StreamingAssets Approach

If your content is already in StreamingAssets:

```
Assets/
├── StreamingAssets/
│   └── WebContents/
│       ├── index.html
│       └── style.css
```

**Configuration**: Add `StreamingAssets/WebContents` to Android Assets
**Loading**:
```csharp
var url = UniWebViewHelper.StreamingAssetURLForPath("WebContents/index.html");
webView.Load(url);
```

##### Configuration for Multiple Folders

You can configure multiple folders from different locations:

```json
Android Assets: ["WebContents", "StreamingAssets/HTML", "MyPlugin/WebAssets"]
```

This will copy all specified folders to the Android assets directory, maintaining their relative paths.

##### Benefits

- ✅ **No Manual Copying**: Files are automatically copied during Gradle export
- ✅ **Flexible Organization**: Place web content anywhere in Assets folder
- ✅ **Error Prevention**: No risk of forgetting to copy files manually
- ✅ **Consistent Workflow**: Same build process for all developers

## From Persistent Data Path

Sometimes, you may want to download some HTML files to disk and then load them locally. One popular location to put the downloaded files would be the `Application.persistentDataPath`. If you are putting your files under this path, use `UniWebViewHelper.PersistentDataURLForPath` method to get the correct path:

```csharp
var url = UniWebViewHelper.PersistentDataURLForPath("www/index.html");
webView.Load(url);
```

Notice that You may also need to add external read permission to your Android manifest file since the `persistentDataPath` is usually a location on the SD card.


---

### Memory Management

# Memory Management

> To manage memory effectively with UniWebView, destroy unused web views promptly, reset references when closed, and clear caches when not needed.

Memory is a key limitation on mobile platforms. We designed and checked the memory management carefully to make sure there is no unintended memory usage or leaking. To keep your game fast and with a small memory footprint, please follow the rules below.

### Destroy the web view once you do not need it

A common mistake when using UniWebView is keeping creating new web views without destroying the unused ones.

Once you do not use a web view component, we strongly suggest to destroy it as soon as possible. To close and destroy a web view, pass it to the Unity's `Destroy` method. Also reset any reference to it for code safe:

```csharp{5-6}
public class MyMonoBehaviour : MonoBehaviour {
    UniWebView webView = //... You set the web view as a member somewhere

    void CloseWebView() {
        Destroy(webView);
        webView = null;
    }
}
```

If there is a chance that the holder component of the web view (here, the `MyMonoBehaviour`) get destroyed, also add `OnDestroy` to `MyMonoBehaviour` and close the web view:

```csharp{9-11}
public class MyMonoBehaviour : MonoBehaviour {
    UniWebView webView = //... You set the web view as a member somewhere

    void CloseWebView() {
        Destroy(webView);
        webView = null;
    }

    void OnDestroy() {
        CloseWebView();
    }
}
```

#### Hide Or Destroy

There is a `Hide` method which makes the web view invisible. However, the `Hide` method is only for visual effect: the hidden web view is still there, and of course, taking memory. If you are not going to show the page again, `Destroy` it instead of calling `Hide`.

We suggest you always destroy the web view as soon as possible after a browsing session completes. You could always create a new web view when you need it a new browsing action.

### Reset web view reference to avoid error

On Android, the user can close the web view with the back button on the device. On iOS, there is also a "Done" button in the toolbar. For either case, if you are holding a reference of the web view in your script, you need to reset it to `null` when the web view is closed.

Add a listener to `OnShouldClose` event, which either Android and iOS would call when the web view is going to be closed by a user action. There you can set the reference to web view back to `null`:

```csharp{6-9}
public class MyMonoBehaviour : MonoBehaviour {
    UniWebView webView;

    void CreateWebView() {
        webView = gameObject.AddComponent<UniWebView>();
        webView.OnShouldClose += (view) => {
            webView = null;
            return true;
        };
    }
}
```

> This event also gives you a chance to override the closing operation. If you return `false` in the event action, the web view will not be closed.

In other parts in `MyMonoBehaviour` which is using the `webView`, keep in mind that the web view might be already gone. Perform `null` check before using it:

```csharp{5}
public class MyMonoBehaviour : MonoBehaviour {
    UniWebView webView;

    void Load() {
        if (webView != null) {
            webView.Load("https://example.com");
        }
    }
}
```

### Clean cache when you are not using it

While your user browsing the Internet, it will create some cache, including cached images and responses. The web page might also store things in the local storage. Although it will not take memory in most cases, if you are not using the cache in your case, call `CleanCache` to purge them at a proper time:

```csharp
webView.CleanCache();
```


---

### URL Messaging System

# URL Messaging System

UniWebView provides two messaging systems for communication between web content and Unity:

1. **URL Scheme Messaging** (Traditional) - Simple, one-way communication using custom URL schemes
2. **Channel Message System** (New) - Advanced, bidirectional communication with structured data support

## Choosing the Right System

| Feature | URL Scheme Messaging | Channel Message System |
|---------|---------------------|----------------------|
| **Complexity** | Simple, easy setup | More powerful, slightly more complex |
| **Communication** | One-way (Web → Unity) | Bidirectional (Web ↔ Unity) |
| **Data Format** | URL query parameters | Structured JSON data |
| **Response Support** | No | Yes (sync and async) |
| **Data Size Limit** | ~16KB | Much larger (no URL length limits) |
| **Performance** | Good for simple messages | Better for complex data |
| **Type Safety** | String-based parsing | Native object serialization |
| **Use Cases** | Simple actions, notifications | Complex data exchange, API-like interactions |

**Recommendation:**
- Use **URL Scheme Messaging** for simple, fire-and-forget messages
- Use **Channel Message System** for complex data exchange and when you need responses

::: tip NEW FEATURE
The Channel Message system is available starting from UniWebView v6. It provides more powerful communication capabilities. Learn more in the [Channel Message Guide](./channel-message.md).
:::

In this guide, we focus on the URL Scheme Messaging.

---

## URL Scheme Messaging

> This traditional messaging system enables one-way communication from web views to Unity using custom URL schemes, with a safe data transfer limit of about 16KB per message.

### Send and Receive

You can send a message from the web view to UniWebView. It helps you implement a way to "control" your game from the web page.

UniWebView inspects all links starts from `uniwebview://` by default. That means if your user taps a link starting with "uniwebview://", an `OnMessageReceived` event will be raised with a `UniWebViewMessage` as its parameter.

If you have this on your page:

```html
<a href="uniwebview://action?key=value&anotherKey=anotherValue">Tap Me</a>
```

And you have this event listener in Unity:

```csharp
webView.OnMessageReceived += (view, message) => {
    print(message.RawMessage);
};
```

When the link is tapped, it prints:

> uniwebview://action?key=value&anotherKey=anotherValue

::: tip NAVIGATION
Besides of an HTML link, a `location.href` JavaScript will also send a message to UniWebView and trigger the event. The code below is identical to example above:

```javascript
location.href = "uniwebview://action?key=value&anotherKey=anotherValue";
```

:::

### Message Object

UniWebView parses the input and pass it to you in the `OnMessageReceived` event, as the `message` parameter. In the example above, you have:

```csharp
message.Scheme // "uniwebview"
message.Path   // "action"
message.Args   // {"key": "value", "anotherKey": "anotherValue"}
```

::: warning Using a Valid URL
From iOS 15.4, Apple applied a limitation that an invalid URL is not triggering the necessary events for UniWebView to deliver the message anymore.
That means you **cannot** use things like `location.href = "uniwebview://{\"title\":\"hello\"}"` to send a message. Instead, you need to make sure to pass a valid URL, like `location.href = "uniwebview://event?title=hello"` or `location.href = "uniwebview://event?payload={\"title\":\"hello\"}"`.

Furthermore, if you prefer an HTML link instead of the `location.href` above, remember to encode your URL query:

```html
<a href="uniwebview://event?payload=%7B%22title%22:%22hello%22%7D">Hello</a>
```

For more about what is a "valid URL", please check [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) and other related specifications.
:::

::: tip DUPLICATED KEY
If you are using a same key for multiple values in the URL query, `UniWebViewMessage` will parse them to the same key as well, with the values concatenated by a comma. For example, a URL like `uniwebview://action?key=1&key=2` will be parsed to a message with `Args` as `{"key": "1,2"}`.
:::

### Adding your own scheme

By default, "uniwebview" is inspected in UniWebView Messaging System. You can also add your own URL schemes. Call `AddUrlScheme` with the one you need:

```csharp
// Start to inspect all `myscheme://` URLs.
webView.AddUrlScheme("myscheme");
```

A tricky thing here is, you can even set `http` and `https` as the scheme. It will prevent all loading of web resources. A use case is that you do not want your user to leave the current page: first load your page, then, in the `OnPageFinished` event, disable all navigating by adding the "http(s)" scheme:

```csharp
webView.Load("https://yourpage.com");

webView.OnPageFinished += (view, statusCode, url) => {
    webView.AddUrlScheme("http");
    webView.AddUrlScheme("https");

    // Now your user will not be able to navigate to other pages hosted on HTTP or HTTPS.
};
```

---

::: warning Limitation
The URL scheme messaging system is built on URL and Unity's message sender. It means you cannot send the unlimited size of data at once. The allowed max length of a URL is different from devices and system versions. But **a safe length is ~16KB** for a URL. If you have something huge to send from the web page to Unity and encountered some problems, it would be better to split them into smaller pieces or switch to the Channel Message System.
:::

## Migrating to Channel Message System

If you find the URL scheme messaging limitations restrictive, consider migrating to the Channel Message system. Here's a simple example:

### Before (URL Scheme)
```javascript
// JavaScript - Limited data size, no response
location.href = "uniwebview://updateScore?score=1500&level=3&bonus=true";
```

```csharp
// Unity - String parsing required
webView.OnMessageReceived += (view, message) => {
    if (message.Scheme == "uniwebview" && message.Path == "updateScore") {
        var score = int.Parse(message.Args["score"]);
        var level = int.Parse(message.Args["level"]);
        var bonus = bool.Parse(message.Args["bonus"]);
        UpdateScore(score, level, bonus);
    }
};
```

### After (Channel Message)
```javascript
// JavaScript - Structured data, can get response
const result = window.uniwebview.call('updateScore', {
    score: 1500,
    level: 3,
    bonus: true
});

console.log('Score updated:', result);
```

```csharp
// Unity - Type-safe object serialization
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "updateScore") {
        var data = message.GetData<ScoreData>();
        var result = UpdateScore(data.score, data.level, data.bonus);
        return UniWebViewChannelMessageResponse.Success(result);
    }
    return null;
};

[System.Serializable]
public class ScoreData {
    public int score;
    public int level;
    public bool bonus;
}
```

::: tip NEXT STEPS
Ready to use the more powerful Channel Message system? Check out the [Channel Message Guide](./channel-message.md) for complete documentation and examples.
:::


---

### Migration Guide (v4 to v5)

# Migration Guide (v4 to v5)

> To migrate from UniWebView 4 to 5, remove old files, install the new version, replace deprecated methods, and explore new features like the embedded toolbar and OAuth 2.0 support.

::: tip Upgrade Pricing
If you have purchased UniWebView 4 before, we offer an upgrading discount.

For users:

- Purchased from our Gumroad Store - [Submit a ticket](https://onevcat.atlassian.net/servicedesk/customer/portal/2/group/2/create/10011) with your purchasing Email and we will send a coupon back.
- Purchased from Unity Asset Store - Sign in to Asset Store and visit [our product page](https://assetstore.unity.com/packages/slug/229334)
  to find the Upgrade Price.
  :::

### Overview

Most part of UniWebView 5 is compatible with UniWebView 4. In most cases, migrating to the new version just takes several
minutes. You can do it with very little (if not no) efforts. You need to:

1. Remove UniWebView 4 from your project.
2. Install UniWebView 5.
3. Replace deprecated methods with new ones.
4. Check if new features can do better jobs.

Let's start!

::: warning
Before you start the migration, we strongly suggest that you should backup your project. If you are already using a
version control system (like git), you should be all fine!
:::

### Removing UniWebView 4

First we suggest remove UniWebView 4 from your project. Remove these files/folders (and the related ".meta" files if
any) from your project:

- "Assets/UniWebView" folder
- "Assets/Plugins/Android/UniWebView.aar"
- "Assets/Plugins/iOS/libUniWebView.a"
- "Assets/Plugins/UniWebView.bundle"

> It is assumed that you didn't move these files to another location. If you did that, remove the corresponding folders
> and files.

### Installing UniWebView 5

Now, you have completely removed UniWebView 4 from you project. Please make sure that you no longer have a "UniWebView"
folder in "Assets". Then follow the [Installation Guide](./installation.md) to integrate UniWebView 5 into your project.

### Deprecated Methods

In UniWebView, the old **built-in toolbar** (iOS only) is deprecated and will be removed in the future. Although the
code will still work for a while, we suggest you to use the new **embedded toolbar** instead. The new toolbar works for
both iOS and Android, and is more flexible and customizable. If you are using any of these methods of `UniWebView` in
your project, consider to replace them with the new ones:

| Deprecated                              | New                                            |
| --------------------------------------- | ---------------------------------------------- |
| webView.SetShowToolbar                  | webView.EmbeddedToolbar.Show                   |
| webView.SetToolbarDoneButtonText        | webView.EmbeddedToolbar.SetDoneButtonText      |
| webView.SetToolbarGoBackButtonText      | webView.EmbeddedToolbar.SetGoBackButtonText    |
| webView.SetToolbarGoForwardButtonText   | webView.EmbeddedToolbar.SetGoForwardButtonText |
| webView.SetShowToolbarNavigationButtons | webView.EmbeddedToolbar.ShowNavigationButtons  |
| webView.SetToolbarTintColor             | webView.EmbeddedToolbar.SetButtonTextColor     |
| webView.SetToolbarTextColor             | webView.EmbeddedToolbar.SetButtonTextColor     |

There are also some new methods in the new `EmbeddedToolbar` class. You can check them in the
[Embedded Toolbar](./embedded-toolbar.md) guide for more information.

### Checking New Features

The most noticeable change in UniWebView 5 is the new built-in OAuth 2.0 support. If you are using OAuth 2 in your project,
regardless of using UniWebView to perform the user login or another plugin, now it is possible to use a "UniWebViewAuthenticationFlow"
prefab to simplify the work. UniWebView provides the out-of-box level support for most popular OAuth 2.0 providers. If you
need to support a new provider, you can also create your own auth flow. To get started, read the [OAuth 2.0 Support Guide](./oauth2.md).

For other features and fixes in new versions of UniWebView v5, please check the [Release Notes](./release-notes.md).


---

### Migration Guide (v5 to v6)

# Migration Guide (v5 to v6)

> To migrate from UniWebView 5 to 6, remove old files, install the new version, and explore the new Channel Message system for enhanced bidirectional communication.

::: tip Upgrade Pricing
If you have purchased UniWebView 5 before, we offer an upgrading discount.

For users:

- Purchased from our Gumroad Store - [Submit a ticket](https://onevcat.atlassian.net/servicedesk/customer/portal/2/group/2/create/10011) with your purchasing Email and we will send a coupon back.
- Purchased from Unity Asset Store - Sign in to Asset Store and visit [our product page](https://assetstore.unity.com/packages/slug/229334)
  to find the Upgrade Price.
  :::

### Overview

UniWebView 6 is fully compatible with UniWebView 5. The migration to the new version is seamless and requires minimal effort. You need to:

1. Remove UniWebView 5 from your project.
2. Install UniWebView 6.
3. Explore new Channel Message features.
4. Consider upgrading existing URL scheme messaging to Channel Messages for better performance.

Let's start!

::: warning
Before you start the migration, we strongly suggest that you should backup your project. If you are already using a
version control system (like git), you should be all fine!
:::

### Removing UniWebView 5

First we suggest remove UniWebView 5 from your project. Remove these files/folders (and the related ".meta" files if
any) from your project:

- "Assets/UniWebView" folder
- "Assets/Plugins/Android/UniWebView.aar"
- "Assets/Plugins/iOS/libUniWebView.a"
- "Assets/Plugins/UniWebView.bundle"

> It is assumed that you didn't move these files to another location. If you did that, remove the corresponding folders
> and files.

### Installing UniWebView 6

Now, you have completely removed UniWebView 5 from you project. Please make sure that you no longer have a "UniWebView"
folder in "Assets". Then follow the [Installation Guide](./installation.md) to integrate UniWebView 6 into your project.

### Backward Compatibility

UniWebView 6 maintains full backward compatibility with UniWebView 5. All existing APIs and functionality continue to work exactly as before. Your existing code will work without any modifications.

### New Features

The most significant addition in UniWebView 6 is the **Channel Message system**. This new system provides enhanced communication capabilities between web pages and Unity:

#### Enhanced Communication
- **Better Performance**: Direct bridge communication without URL scheme overhead
- **Bidirectional Communication**: Unity can respond with data back to JavaScript
- **Structured Data**: Native JSON support for complex data types
- **Multiple Patterns**: Choose between fire-and-forget, synchronous, and asynchronous communication

#### When to Use Channel Messages

Consider upgrading from URL scheme messaging (`uniwebview://`) to Channel Messages when:

- You need to send large amounts of data
- You require bidirectional communication
- You want better error handling and debugging
- You need high-frequency messaging without loss
- You prefer working with structured JSON data

#### Migration Example

**Old URL Scheme Approach:**
```javascript
// JavaScript
window.location = "uniwebview://action?data=" + encodeURIComponent(JSON.stringify(myData));
```

```csharp
// Unity
webView.OnMessageReceived += (view, message) => {
    if (message.path == "action") {
        var data = message.args["data"];
        // Process data...
    }
};
```

**New Channel Message Approach:**
```javascript
// JavaScript
window.uniwebview.send('action', myData);
```

```csharp
// Unity
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "action") {
        var data = message.GetData<MyDataType>();
        // Process data...
        return null; // For send messages
    }
    return null;
};
```

### Getting Started with Channel Messages

To start using the new Channel Message system, check out the comprehensive [Channel Message Guide](./channel-message.md). The guide covers:

- Three communication patterns (Send, Call, Request)
- JavaScript API usage
- Unity event handling
- Error handling best practices
- Security considerations

### Checking New Features

For a complete overview of all new features and improvements in UniWebView 6, please check the [Version Highlight](./version-highlight.md) guide.

For detailed API documentation of the Channel Message system, refer to the API references for:
- [UniWebViewChannelMessage](../api/UniWebViewChannelMessage.md)
- [UniWebViewChannelMessageResponse](../api/UniWebViewChannelMessageResponse.md)
- [UniWebViewChannelMessageType](../api/UniWebViewChannelMessageType.md)

For all changes and fixes in UniWebView v6, please check the [Release Notes](../release-note/).

---

### Migration Guide (v3 to v4)

# Migration Guide (v3 to v4)

> To migrate from UniWebView 3 to 4, remove old files, install the new version, replace deprecated methods like SetImmersiveModeEnabled and OnKeyCodeReceived, and consider using new features like Safe Browsing Mode.

::: tip Upgrade Pricing
If you have purchased UniWebView 3 before, we offer an upgrading discount.

For users:

- Purchased from our Gumroad Store - [Submit a ticket](https://onevcat.atlassian.net/servicedesk/customer/portal/2/group/2/create/10011) with your purchasing Email and we will send a coupon back.
- Purchased from Unity Asset Store - Sign in to Asset Store and visit [our product page](https://assetstore.unity.com/packages/slug/229334)
  to find the Upgrade Price.
  :::

### Overview

Most part of UniWebView 4 is compatible with UniWebView 3. In most cases, migrating to the new version just takes several
minutes. You can do it with very little (if not no) efforts. You need to:

1. Remove UniWebView 3 from your project.
2. Install UniWebView 4.
3. Replace deprecated methods with new ones.
4. Check if new features can do better jobs.

Let's start!

::: warning
Before you start the migration, we strongly suggest that you should backup your project. If you are already using a
version control system (like git), you should be all fine!
:::

### Removing UniWebView 3

First we suggest remove UniWebView 3 from your project. Remove these files/folders (and the related ".meta" files if
any) from your project:

- "Assets/UniWebView" folder
- "Assets/Plugins/Android/UniWebView.aar"
- "Assets/Plugins/iOS/libUniWebView.a"
- "Assets/Plugins/UniWebView.bundle"

> It is assumed that you didn't move these files to another location. If you did that, remove the corresponding folders
> and files.

If you have ever modified your "AndroidManifest.xml" file under "Assets/Plugins/Android" folder, we also suggest you
restore the changes related to UniWebView. The latest UniWebView 4 can configure the project with a post-build script, so
manual modification is not recommended any more.

### Installing UniWebView 4

Now, you have completely removed UniWebView 3 from you project. Please make sure that you no longer have a "UniWebView" folder in "Assets". Then follow the [Installation Guide](./installation.md) to integrate UniWebView 4 into your project.

### Deprecated Methods

The methods below are deprecated and not functional from UniWebView 4. Please find a replacement or remove it from your code if you are using them:

#### SetImmersiveModeEnabled

> [`SetImmersiveModeEnabled` API Reference in v3](https://docs-v3.uniwebview.com/api/#setimmersivemodeenabled)

UniWebView 4 on Android changed its way of adding itself to Unity scene. Now it respects Unity's setting of immersive mode.
It means `SetImmersiveModeEnabled` is no longer needed anymore. If you want to show the web view with navigation bar
visible on Android, disable the immersive mode.

#### OnKeyCodeReceived

> [`OnKeyCodeReceived` API Reference in v3](https://docs-v3.uniwebview.com/api/#onkeycodereceived)

UniWebView 4 on Android now does not inject system touch event to handle user interaction. That means you can keep
receiving key code events even with a web view being shown. Now the `OnKeyCodeReceived` event is never raised. To
inspect a key code, check the `Input.GetKeyUp` in `Update` instead:

```csharp
// DON'T DO IT.
// webView.OnKeyCodeReceived += (view, keyCode) => {
//     if (keyCode == 4) {
//         Debug.Log("Back Button was clicked.");
//     }
// };

// Check Input in Update():
void Update() {
    if (Input.GetKeyUp(KeyCode.Escape)) {
        Debug.Log("Back Button was clicked.");
    }
}
```

### Checking New Features

UniWebView 4 introduces a bunch of new features. Check the [Version Highlight](version-highlight.md) guide for more
details. Among them, the most noticeable addition is the [Safe Browsing Mode](safe-browsing.md). Maybe it is a better
way to show your web content to your users, in a cleaner and safer way.

As the final step of the migration, we suggest you judge whether it is a good idea for your project to adopt to the
latest new features. However, even you choose to keep using your current implementation, you can still get benefits
from the upgrading, which contains quite a few fixes as well as performance improvement.


---

### OAuth 2.0 with GitHub

# OAuth 2.0 with GitHub

> Use UniWebView to implement GitHub OAuth 2.0 authentication by setting up the component, handling callbacks, and managing token storage and refresh.

> The following guide was last updated in October 2024. Please note that it may become outdated if the provider updates their user interface or workflow.

In this guide, we are using GitHub for demonstration purpose.

We assumed that you have already created a GitHub App to follow this guide. If not yet, please refer to [this official guide](https://docs.github.com/en/developers/apps/building-github-apps/creating-a-github-app) to create one. We assume you have the following information for the app, and we will use them in this guide:

> | GitHub App Field                                       | Value                            |
> | ------------------------------------------------------ | -------------------------------- |
> | Client ID                                              | Iv1.1234567890abcdef             |
> | Client Secret                                          | 1234567890abcdef1234567890abcdef |
> | Callback URL                                           | authhub://auth                   |
> | Enable Device Flow                                     | false                            |
> | Webhook - Active                                       | false                            |
> | Request user authorization (OAuth) during installation | false                            |
>
> _\* The values here are only for demonstration purpose. In your implementation, replace them to the actual values of your app._

## Adding Component

To get started, adding the `UniWebViewAuthenticationFlowGitHub` component to any of your game object in the scene. The easiest way is clicking the "Add Component" button in the Inspector, and search for "github":

![](/images/adding-github-auth.png)

## Setting Properties

Next, fill the necessary values of your app to the added `UniWebViewAuthenticationFlowGitHub` component. In this example, we need to set "Client Id", "Client Secret" and "Callback Url":

![](/images/property-github-auth.png)

:::warning Client Secret
Strictly speaking, the client secret **should not be stored** on the client side. In the OAuth flow of a native app, we should use [PKCE](https://oauth.net/2/pkce/) whenever possible to protect the authorization process (UniWebView [supports PKCE](/api/UniWebViewAuthenticationFlowCustomize.html#optional)). However, GitHub’s OAuth does not currently support PKCE, so we still have to use the client secret when exchanging tokens in this guide for the sake of simplicity.

A more secure approach would be to set up your own backend server and use server-to-server communication to obtain the access token. In UniWebView, you can use the [Customize Flow](/guide/oauth2.html#customize-flow) to set the entry point for access token exchange to your server, thereby avoiding exposing the client secret in the client-side code.
:::

There are also some other options on the component. Usually it contains some other optional settings for the OAuth provider. For GitHub, you can specify other "Scope" or determine whether to use "State" to validate the callback. For difference service, there are usually different options. Please refer the service provider documentation to know more.

> For a built-in supported provider, you always just need to set the top-level properties to get a minimal available setup.

## Setting Callback URL

When users log in to the service with their accounts, the service will open the callback URL you set in the app. For OAuth 2.0 in a mobile app, this callback URL usually launches your app. For that works globally in the app, you need to add the callback URL to UniWebView's preference panel.

Open the preference panel (Unity → Preferences) and find "UniWebView" in the side bar. Then, expand the "Auth Callbacks Urls" and add the callback URL (`authhub://auth` in this example) to the list:

![](/images/adding-github-callback.png)

## Handling Result

Almost done! Now, you can add a handler to get the result of the authentication flow. It is similar to Unity.UI's button action. You can prepare a method and assign it to the handlers list.

Create an empty game object (Unity Menu, GameObject -> Create Empty) to the scene and rename it as "OAuthHandler". Then add a new component by clicking the "Add Component" button in the Inspector, input "OAuthHandler" and choose "New script":

![](/images/adding-oauth-handler.png)

In the new `OAuthHandler.cs`, add the following code:

```csharp
public void OnGitHubTokenReceived(UniWebViewAuthenticationGitHubToken token) {
    Debug.Log("Token received: " + token.AccessToken);
}

public void OnGitHubAuthError(long errorCode, string errorMessage) {
    Debug.Log("Error happened: " + errorCode + " " + errorMessage);
}
```

At last, go back to the object with `UniWebViewAuthenticationFlowGitHub`, click the "plus" button. Then, drag the `OAuthHandler` object to the field and select its related methods:

![](/images/oauth-action-list.png)

## Start Authenticating

Now, you can start the authentication flow by calling `StartAuthentication` of the `UniWebViewAuthenticationFlowGitHub` component.

To do that, you first need to have a reference of the `UniWebViewAuthenticationFlowGitHub`. Add a new script component **to the same game object** where the `UniWebViewAuthenticationFlowGitHub` is on. Then in the new added script, add the following code in the `Start()` method:

```csharp {2,3}
void Start() {
    var githubFlow = GetComponent<UniWebViewAuthenticationFlowGitHub>();
    githubFlow.StartAuthenticationFlow();
}
```

:::tip
Alternative, you can turn on the "Authorize On Start" option in the `UniWebViewAuthenticationFlowGitHub` component. It
provides an easy way if you want to start the authentication flow automatically when the component starts.
:::

The GitHub authentication should work now. By running the scene, a web view will be opened and navigate to the GitHub authorization page. You can now log in with your GitHub account to the GitHub app, and receive a valid access token in `OnGitHubTokenReceived` callback:

![](/images/github-login.png)

When log in successfully, you can find the following console log with the retrieved access token:

```
Token received: ${YOUR_ACCESS_TOKEN}
```

## Store & Read the Token

Sometimes, you may want to store the token locally. UniWebView, as a web view component with OAuth support, does not provide any storage for the token. You will need to implement this yourself.

You can read the [`RawValue` string of the token](/api/UniWebViewAuthenticationStandardToken.html#rawvalue), and store it on the device or on your server. Remember the token is sensitive data, you should not store it in plain text. Usually, it is a good idea to encrypt it before storing it.

> There are several ways to encrypt and store a string in Unity, for example, the [SecurePlayerPrefs](https://assetstore.unity.com/packages/tools/input-management/secureplayerprefs-35160) is a good one.

When you need to use the token, you can read the raw string value from the storage and create a new `UniWebViewAuthenticationStandardToken` object:

```csharp
var rawValue = // Read the raw value from the storage
var token = new UniWebViewAuthenticationGitHubToken(rawValue);

// Or, if you are using a subclass of UniWebViewAuthenticationStandardToken, use its `Parse` method:
var token = UniWebViewAuthenticationTokenFactory<UniWebViewAuthenticationGitHubToken>.Parse(rawValue);
```

## Refresh Token

If in the token, there is a non-null `RefreshToken` property, it usually suggests that you can use it to refresh the access token.

In any compatible flow (in this example, the `UniWebViewAuthenticationFlowGitHub`), there is a `StartRefreshTokenFlow` method. You can pass the refresh token in, and the flow will try to communicate with
the service provider and refresh the token. Similar to the access token authentication flow, the refresh token result will be returned in the callback too.

But instead of setting the methods for "On Authentication Finished" and "On Authentication Errored", this time you need to set "On Refresh Token Finished" and "On Refresh Token Errored":

![](/images/refresh-action-list.png)

```csharp
public void OnGitHubTokenRefreshed(UniWebViewAuthenticationGitHubToken token) {
    Debug.Log("Token refreshed: " + token.AccessToken);
}

var rawValue = // Read the raw value from the storage
var token = new UniWebViewAuthenticationGitHubToken(rawValue);
if (token.RefreshToken != null) {
    githubFlow.StartRefreshTokenFlow(token.RefreshToken);
}
```


---

### OAuth 2.0 with Google

# OAuth 2.0 with Google

> Use UniWebView to implement Google OAuth 2.0 authentication by setting up the component, handling callbacks, and managing token storage.

> The following guide was last updated in October 2024. Please note that it may become outdated if the provider updates their user interface or workflow.

## Creating an OAuth Client ID

We assume that you already have a valid Google Cloud account for development. Navigate to your project on
[Google Cloud](https://console.cloud.google.com/welcome), click **APIs & Services** -> **Credentials** (or use
[this link](https://console.cloud.google.com/apis/credentials)). Then click **Create Credentials** and select **OAuth client ID**.

![](/images/create-google-oauth-client.png)

In the "Create OAuth client ID" window, choose **iOS** as the application type. Give a proper name to your application
and fill in the bundle ID. You can leave all other fields empty for now. Click **Create** to generate an OAuth Client
ID for your app.

![](/images/fill-oauth-info.png)

> Here, we created an iOS application as our OAuth Client. It can be used for testing purposes for both iOS and Android
> in UniWebView. However, if you also need to publish your game on Android, you may need to create another OAuth Client
> ID by choosing **Android** as the application type and filling in some platform-specific information (such as package
> name and signature) before it can pass Google's review for publishing.

In the next screen, you will get a new client ID value. It contains two components before a fixed Google domain suffix,
in a format like this:​

`{number}-{token}.apps.googleusercontent.com`

In this guide, we will use this Client ID value as an example:

`1234567890-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com`

To allow a Google account to sign in to this newly created OAuth Client ID during the development phase, you also need
to add a test account. Open the **OAuth consent screen** settings panel on the Google Cloud Console, and add any test
accounts you need to the **Test users** section.

## Adding Component

Add a `UniWebViewAuthenticationFlowGoogle` component to any game object in the scene. The easiest way is to click the
**Add Component** button in the Inspector and search for "google":

![](/images/adding-google-auth.png)

## Setting Properties

Next, fill in the necessary values for your app in the added `UniWebViewAuthenticationFlowGoogle` component. In this
example, we need to set **Client ID**, **Redirect URI**, and **Scope** to the following values:

> | Field        | Value                                                                  |
> | ------------ | ---------------------------------------------------------------------- |
> | Client ID    | 1234567890-abcdefghijklmnopqrstuvwxyz.apps.googleusercontent.com       |
> | Redirect Uri | com.googleusercontent.apps.1234567890-abcdefghijklmnopqrstuvwxyz:/auth |
> | Scope        | https://www.googleapis.com/auth/userinfo.profile                       |

Remember to replace the `1234567890-abcdefghijklmnopqrstuvwxyz` part in **Client ID** and **Redirect URI** with the
actual partial content of your Client ID. For the **Scope** field, we add the **userinfo.profile** scope to obtain
basic user information. You may need to add more scopes to meet your requirements. Please check
[Google's documentation](https://developers.google.com/identity/protocols/oauth2/scopes) for the full list.

![](/images/property-google-auth.png)

There are also some other options on the component. Typically, these include optional settings for the OAuth provider.
For Google, leave **PKCE Support** and **Enable State** at their default values (`S256` and "enabled"). These settings
provide a secure client authentication flow.​⬤

> For a built-in supported provider, you only need to set the top-level properties to achieve a minimal available setup.

## Setting Callback URL

When users log in to the service with their accounts, the service will open the callback URL you set in the app. For
OAuth 2.0 in a mobile app, this callback URL usually launches your app. To ensure this works globally in the app, you
need to add the callback URL to UniWebView's preference panel.

Open the preference panel (Unity → Preferences) and find **UniWebView** in the sidebar. Then, expand
**Auth Callbacks URLs** and add the callback URL
(`com.googleusercontent.apps.1234567890-abcdefghijklmnopqrstuvwxyz:/auth` in this example) to the list:

![](/images/adding-google-callback.png)

## Handling Result

Almost done! Now, you can add a handler to get the result of the authentication flow. This process is similar to the
Unity.UI button action. You can prepare a method and assign it to the handlers list.

Create an empty game object (Unity Menu: GameObject -> Create Empty) in the scene and rename it to **OAuthHandler**.
Then, add a new component by clicking the **Add Component** button in the Inspector, input **OAuthHandler**, and
choose **New script**:

![](/images/adding-oauth-handler.png)

In the new `OAuthHandler.cs`, add the following code:

```csharp
public void OnGoogleTokenReceived(UniWebViewAuthenticationGoogleToken token) {
    Debug.Log("Token received: " + token.AccessToken);
}

public void OnGoogleAuthError(long errorCode, string errorMessage) {
    Debug.Log("Error happened: " + errorCode + " " + errorMessage);
}
```

At last, go back to the object with `UniWebViewAuthenticationFlowGoogle`. Click the **plus** button in the
**On Authentication Finished** and **On Authentication Errored** sections to create a callback. Then, drag the
**OAuthHandler** object to the field and select its related methods:

![](/images/oauth-action-list-google.png)

## Start Authenticating

Now, you can start the authentication flow by calling `StartAuthentication` of the `UniWebViewAuthenticationFlowGoogle`
component.

To do this, first, you need to have a reference to the `UniWebViewAuthenticationFlowGoogle`. Add a new script component
**to the same game object** where the `UniWebViewAuthenticationFlowGoogle` is located. Then, in the newly added script,
add the following code in the `Start()` method:

```csharp {2,3}
void Start() {
    var googleFlow = GetComponent<UniWebViewAuthenticationFlowGoogle>();
    googleFlow.StartAuthenticationFlow();
}
```

:::tip
Alternative, you can turn on the "Authorize On Start" option in the `UniWebViewAuthenticationFlowGoogle` component. It
provides an easy way if you want to start the authentication flow automatically when the component starts.
:::

The Google authentication should work now. By running the scene, a web view will open and navigate to the Google authorization page. You can now log in with your Google account and receive a valid access token in the `OnGoogleTokenReceived` callback:

![](/images/google-login.png)

When log in successfully, you can find the following console log with the retrieved access token:

```
Token received: ${YOUR_ACCESS_TOKEN}
```

## Store & Read the Token

Sometimes, you may want to store the token locally. UniWebView, as a web view component with OAuth support, does not provide any storage for the token. You will need to implement this yourself.

You can read the [`RawValue` string of the token](/api/UniWebViewAuthenticationStandardToken.html#rawvalue), and store it on the device or on your server. Remember the token is sensitive data, you should not store it in plain text. Usually, it is a good idea to encrypt it before storing it.

> There are several ways to encrypt and store a string in Unity, for example, the [SecurePlayerPrefs](https://assetstore.unity.com/packages/tools/input-management/secureplayerprefs-35160) is a good one.

When you need to use the token, you can read the raw string value from the storage and create a new `UniWebViewAuthenticationStandardToken` object:

```csharp
var rawValue = // Read the raw value from the storage
var token = new UniWebViewAuthenticationGoogleToken(rawValue);

// Or, if you are using a subclass of UniWebViewAuthenticationStandardToken, use its `Parse` method:
var token = UniWebViewAuthenticationTokenFactory<UniWebViewAuthenticationGoogleToken>.Parse(rawValue);
```


---

### OAuth 2.0 General

# OAuth 2.0 General

> UniWebView supports OAuth 2.0 for multiple providers, offering customizable flows and secure authentication methods.

## Overview

UniWebView provides support for [OAuth 2.0 authorization code flow](https://www.oauth.com/oauth2-servers/server-side-apps/authorization-code/). It contains built-in support for several popular OAuth 2.0 providers by following their options, which are:

| Service Provider | UniWebView Auth Class                | Provider Documentation                                                                                          |
| ---------------- | ------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| Google           | UniWebViewAuthenticationFlowGoogle   | [OAuth 2.0 for Mobile & Desktop Apps](https://developers.google.com/identity/protocols/oauth2/native-app?hl=en) |
| Facebook         | UniWebViewAuthenticationFlowFacebook | [Manually Build a Login Flow](https://developers.facebook.com/docs/facebook-login/guides/advanced/manual-flow)  |
| Twitter          | UniWebViewAuthenticationFlowTwitter  | [Authentication](https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code)             |
| GitHub           | UniWebViewAuthenticationFlowGitHub   | [Authorizing OAuth Apps](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps) |
| Discord          | UniWebViewAuthenticationFlowDiscord  | [OAuth2 in Discord](https://discord.com/developers/docs/topics/oauth2)                                          |
| LINE             | UniWebViewAuthenticationFlowLine     | [LINE Login v2.1 API reference](https://developers.line.biz/en/reference/line-login/)                           |

Besides of them, UniWebView also a customizable common setup for **any other services which provides a standard OAuth 2.0 code flow**.

UniWebView follows the OAuth 2.0 standard and use a secure way to perform authentication. It supports both `state` verification and [PKCE](https://oauth.net/2/pkce/) challenge out-of-the-box, which simplifies your work and improves the security a lot.

In this guide, we will cover both and show you how to have your users login to a service with OAuth 2.0.

> All services names and trademarks are property of their respective owners in this guide.

## Checking Availability

This feature is not available on all UniWebView supporting platforms. On Apple's devices, it only works on iOS 11, macOS 10.15 and later. On Android, it requires the similar environment as [Safe Browsing Mode](./safe-browsing.md#checking-availability).

#### Target API Level higher than Android 11

On Android, if you set your **Target API Level to Android 11 (30) or later**, you need to add the correct intent query
explicitly in your `AndroidManifest.xml` file, to follow the [Package Visibility](https://developer.android.com/about/versions/11/privacy/package-visibility)
to add `queries` as a sub-node of the `manifest` tag:

```xml{6-10}
<manifest>
  // ...

  </application>

  <queries>
    <intent>
      <action android:name="android.support.customtabs.action.CustomTabsService" />
    </intent>
  </queries>
</manifest>
```

::: warning Package Visibility from Android 11
If you are setting Target API Level higher than Android 11 (API Level 30), but not setting the `queries` in your
`AndroidManifest.xml`, the OAuth 2.0 related APIs will not work expectedly on Android.
:::

#### Runtime Checking

To check if OAuth 2.0 feature is available at runtime, call `IsAuthenticationSupported` like this:

```csharp
if (UniWebViewAuthenticationSession.IsAuthenticationSupported) {
    // OAuth 2.0 code flow is available on the current device.
}
```

This `IsAuthenticationSupported` property returns `true` on Android with customize tabs, iOS 11, macOS 10.15 and later.
**You should always check whether this feature is available before using it.** Only continue to use OAuth 2.0 feature
when this value is `true`. Otherwise, the authentication flow may not even start.

## Built-In Providers

For built-in supported providers [mentioned above](#overview), each provider has a dedicated class responsible for the authentication flow. We provided some step-to-step guide for integrating some providers to your app. Please refer the articles below for detail.

- OAuth 2.0 with Google
- OAuth 2.0 with GitHub

For other providers, most of the settings are the same or similar. For the provider-specific settings, please refer to the API reference of each class to know more details.

## Other Properties

For other OAuth 2.0 providers which are not mentioned in the step-by-step guide, you should be able to perform the auth in the similar way, by setting the responsive fields like "Client Id" and "Callback Url", etc. There are also some common fields between different providers. In this section, we introduce them briefly.

#### Authorize On Start

Normally, you need to call `StartAuthenticationFlow` to display the web view for login form.

When this is enabled, the authentication flow will start automatically when the component starts (in the `Start()` method).

#### Private Mode

The system will remember the session for a certain service. Unless the user logs out from the service in the web view,
it will just reuse the last credentials if available when the user tries to log in again. To disable this behavior and
allow the user to choose another account, set the "Private Mode" option to "true".

::: warning VERSIONS
When enabled, the web view will try to open the authorization page in private (incognito) mode.

On iOS, this works on iOS 13 and later.

On Android, it is not always available but depends on the Chrome version and might require users to enable the incognito
mode (and support for third-party use) in Chrome's settings. Check settings with `chrome://flags/#cct-incognito` and
`chrome://flags/#cct-incognito-available-to-third-party` in Chrome to see the current status.
:::

## Customize Flow

Besides the built-in supported OAuth 2.0 providers, you can also use the common flow to let your user log in to any
standard OAuth 2.0 provider. To adapt to a common flow, add the `UniWebViewAuthenticationFlowCustomize` component instead,
and set the necessary properties like "Authorization Endpoint", "Token Endpoint", "Client Id" and other more:

![](/images/common-flow-component.png)

> Usually, you can find these necessary entry points information in the service provider documentation.

To receive the authorization result, set the success handler parameter to `UniWebViewAuthenticationStandardToken`:

```csharp
public void CustomizeOAuthDone(UniWebViewAuthenticationStandardToken token) {
    Debug.Log("Token received: " + token.AccessToken);
}

public void CustomizeOAuthFailed(long errorCode, string errorMessage) {
    Debug.Log("Error happened: " + errorCode + " " + errorMessage);
}
```

## Universal Link as callback URL

You can also use an [iOS Universal Link](https://developer.apple.com/ios/universal-links/) or [Android App Link](https://developer.android.com/training/app-links) that starts with `https` as the callback URL for most of the providers. Ensure that the Universal Link or App Link is correctly configured both in your app and on your website.

Keep in mind that the Universal Link or App Link must be triggered by user action. Some OAuth providers automatically redirect to the callback URL if the user is already logged in, which may prevent the app from opening. To handle this, you should set the `prompt` value in the "Optional" section to something like `"consent"`. This will prompt the user to click the authentication button, allowing the app to open via the `https` callback URL.

![](/images/oauth-universal-link.png)


---

### Overview

# Overview

> UniWebView offers two options for displaying web content: a customizable general-purpose web view and a simple, secure full-screen safe browsing mode.

In this guide, we will introduce the two main options when using this package to show some web content. You can choose one that fits your project better.

## Two Options

There are two options to show some a web page. You need to decide which one is better to fit for your project:

- [**General-Purpose Web View**](using-prefab.md)

  The powerful option. You can set web view's size and position, show or hide the navigation bar, load local files, call JavaScript on the web page from Unity and do much more other tasks.

- [**Safe Browsing Mode**](safe-browsing.md)

  The simple option. It provides an always-full-screen and browser-level experience to display web content. There is very little you can do except giving it a URL and let it show, but it is much safer and familiar to your users. You can think it as the Mobile Safari or Chrome in your app.

::: tip
Each option has a Unity prefab to simplify the basic use, as well as provides a full-set of APIs by code.
:::

If you are still not sure which is better for your case, check the sections below and there are more suggestions.

## When to Choose Web View

If you are going to implement any of below, you have to choose the [general purpose-web view option](using-prefab.md):

- Show the page in partial area of the screen, instead of always full screen.
- Hide the system UI, such as the navigation buttons (Go Back, Go Forward and Done, etc).
- Call some JavaScript on the page from Unity.
- Receive certain user actions on the web page in Unity.
- Listen to the page's events, such as page loaded or error happened.
- Set customize header fields or user agent.
- Set or read cookies on the page from Unity.
- Load any local files from the app bundle.

It gives you a much more powerful web view component. But at the same time, you take the responsibility to use it correctly.

## When to Choose Safe Browsing Mode

If one of the following conditions is met, then the [safe browsing mode option](safe-browsing.md) could be the best choice for you:

- Simply show a remote web page in full screen and browse a specified URL, just like in a browser.
- Use some secure-strict features, like **Apple Pay**, **Reader Mode**, or **Password Autofill**.

It is simple and easy to use, as an out-of-the-box solution to show the web page. But you do not have much more other control except for the navigation bar color.


---

### Playing Videos

# Playing Videos

> UniWebView supports HTML5 video playback with options for auto play and inline play, but does not support Flash-based videos.

UniWebView supports playing HTML5 videos. You could embed your videos in the [`<video>` tag](https://www.w3schools.com/html/html5_video.asp) to play it in HTML.

For most video host sites (such as YouTube or Vimeo), video playback should work out-of-the-box, including all controls and full-screen support. Some of the video providers also provide JavaScript SDK/Tools to give more control on the video playing. Since UniWebView supports JavaScript, you should also be able to make use of them to control your playback.

If you want more advanced features like auto play or inline play, you need some additional steps.

### Auto Play

When an `autoplay` attribute is in the video tag, the video is expected to be played automatically when the page is opened:

```html {1}
<video autoplay>
  <source src="movie.mp4" type="video/mp4" />
</video>
```

But in web view, the auto play is not enabled by default. To enable auto play feature, call `UniWebView.SetAllowAutoPlay(true)` before you create a web view.

### Inline Play

By default, videos will be played full screen on iPhone or iPod devices. On Android or iPad devices with a larger display, you could choose an inline way to play your videos. But this behavior could also be changed by calling `UniWebView.SetAllowInlinePlay(true)`.

These settings (and some other similar static setup methods of `UniWebView`) works in a "pre-configuration" way. That is, the setting will not be applied to previously created web views.

---

::: danger
Legacy flash-based videos are not and will never be supported in UniWebView.
:::


---

### Position and Size

# Position and Size

> UniWebView allows setting web view position and size either directly with a frame or by referencing a UI element's RectTransform for adaptive layouts.

UniWebView has two ways to determine where the web view should be displayed on the screen:

- **Setting a frame directly**, or
- **Setting a reference UI element**

## Setting Frame

You could set the position and size by using `Frame` property.

### Origin and Size

A frame is a combination of an origin (where it should be) and a size (how large it should be).

The coordinate system used in UniWebView is top-left based. The zero point `(0, 0)` in the coordinate is the most top-left point of your screen. And the size is defined by Unity `Screen`, with `Screen.width` and `Screen.height` as its max:

![](/images/RectXY.svg)

In this coordinate system, you could set the position and size of the web view quite easy:

```csharp
// Full screen web view:
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);

// Bottom half of screen:
webView.Frame = new Rect(0, Screen.height / 2, Screen.width, Screen.height / 2);

// Insets from all sides by 10:
webView.Frame = new Rect(10, 10, Screen.width - 20, Screen.height - 20);

// 200 x 200 web view at point (100, 100)
webView.Frame = new Rect(100, 100, 200, 200)
```

> Although you can set the absolute value, keep in mind that the screen sizes are varying. Usually, you need to calculate a frame based on the current `Screen` before set it.

If you want more control on the position and size, UniWebView supports another way to get benefit from Resolution & Device Independence concept from Unity UI and **Canvas Scaler**. Read the [Using Reference UI Element](#using-reference-ui-element) below to know how to use it.

::: warning IMPORTANT
`Frame` property will be ignored if you use the method described in "Using Reference UI Element" (or say, if the `ReferenceRectTransform` property is not `null`).
:::

### Orientation Change

When setting `Frame` property, it is **only for the current screen**. If your game supports different orientation, you need to update the `Frame` to a new value when the screen orientation changes.

Listen to the `OnOrientationChanged` event and update `Frame` property there. For example, the code below will set the web view full screen and also keep it full screen when the orientation changes:

```csharp{4-8}
// Set the frame to full screen. Say it is portrait 320x640.
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);

// OnOrientationChanged will be called whenever the screen orientation changes.
webView.OnOrientationChanged += (view, orientation) => {
    // Set full screen again. If it is now in landscape, it is 640x320.
    webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
};
```

> If you do not set the `Frame` again in the `OnOrientationChanged` event, the web view size will keep what it is initially set (320x640), and your layout will be broken.

## Using Reference UI Element

Unity has a responsive, nicely designed UI system: Unity UI. It considers screen canvas scaler and every rendered Unity UI comes with a `RectTransform`. You can set a `RectTransform` to UniWebView's `ReferenceRectTransform`, and UniWebView will follow this given `RectTransform` to determine its position and size. So you could skip to calculate the `Frame` and adapt to devices with different sizes and resolutions.

> Unity UI could be designed to fit for multiple resolutions by using a canvas with Canvas Scaler. With this feature, UniWebView can also be adaptive. If you are not familiar with it, we recommend you to read the [Designing UI for Multiple Resolutions](https://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html) first.

Once you have a `RectTransform`, just set the property:

```csharp
RectTransform myUITransform = ...
webView.ReferenceRectTransform = myUITransform;
```

And everything should be done.

> The `RectTransform` supports all three kinds render mode ("Screen Space - Overlay", "Screen Space - Camera" and "World Space") on the first `Canvas` from the transform above. However, if you are using a camera-depended space, please make sure you have set up the camera correctly for the render mode. Otherwise, `RectTransform` will fall back as there is no camera and the size/location might be incorrect.

### Handle Rect Transform Changing

Similar to the case for `Frame`, `ReferenceRectTransform` only considers the current state of the referenced transform when set. However, since we know the reference rect will be changed when the screen orientation changes, there is no need to update it again in `OnOrientationChanged` event. UniWebView will update its position and size automatically for you.

But for other changes besides of the orientation change, UniWebView cannot detect it automatically. You take the responsibility to update the web view position and size in this case. In Unity, the `OnRectTransformDimensionsChange` in `UIBehavior` will be called when the attached rect transform changed. Please call UniWebView's `UpdateFrame()` in this method to give UniWebView a chance to calculate correct layout:

```csharp
// In a UIBehavior script:

// This method is called whenever the associated `rectTransform` is changed.
void OnRectTransformDimensionsChange() {
    // Update web view's frame to match the reference rect transform.
    webView.UpdateFrame();
}
```


---

### Privacy Policy

# Privacy Policy

> UniWebView prioritizes privacy, collecting minimal data, using it only for order processing, and ensuring secure transmission with encryption.

::: tip DATE
Last updated: 2018-04-29
:::

Protection of your privacy is very important to us. Below you will find detailed information about how we deal with your data.

Our data protection policy conforms to the Federal Data Protection Act (Bundesdatenschutzgesetz, BDSG) as well as to the Telemedia Act (Telemediengesetz).

### Collection, processing and use of personal data

You can use our site service (home page, documentation) without providing any personal information. We only save access data not connected to individuals, such as the name of your internet service provider, the web page from which you visit us, or the names of the requested files. These data are only evaluated to improve our service and do not allow any personal references to be drawn.

Personal data will only be collected if you choose to share them within the scope of your order or when submitting an issue ticket. We only use the data you have shared to fulfill and process your order or contacting you from our agents, unless you have given specific permission. When you purchased our service, your email address will be stored to identify you for delivering software updates.

### Transferring personal data

Your personal data will only be transferred to third parties if it is necessary to process an order. One-time payments are processed through the service provider, if you choose to purchase from the service web site instead of Unity Asset Store:

> Gumroad, Inc.
> 1640 17th Street
> San Francisco, CA 94107

All data needed for payment processing are used by Gumroad Inc or Unity Asset Store. UniWebView and its developers exclusively for carrying out the payments.

### Right to information

According to the Federal Data Protection Act, you have the right to obtain information about your stored data at no charge as well as the right, if necessary, to correct, block or delete these data.

### Data protection

During the order process your personal data will be encrypted when transmitted over the internet. We take technical and organizational measures to secure our website and other systems against loss, destruction, access, modification or distribution of your data by unauthorized persons.

### The encryption procedure

During the order process your personal data is securely transmitted to our servers over HTTPS and encrypted using SSL/TLS.


---

### Render as Texture

# Render as Texture

> UniWebView allows rendering web content as a non-interactive texture in Unity, suitable for 3D integration but with performance and feature limitations.

Usually, UniWebView is used as a native overlay layer on top of the whole Unity scene. That means you cannot put any
other Unity element on top of the web view (see the [FAQ here](/guide/faq.html#can-i-put-some-unity-gui-object-above-of-uniwebview)).
Instead, UniWebView provides a way to render the current web view content into a texture, you can use the texture in the
3D world, such as Unity `RawImage` or any `Material` on any 3D object.

::: warning LIMITATION
When rendered as texture, the web view will not be interactive anymore. Although it is still possible to call any method
programmatically on the web view, you cannot click on any link or button, or scroll the web view by gesture. It is just
a visual snapshot of the current web view content.

All hardware acceleration content, such as the video or WebGL elements, cannot be rendered.

See the [Limitations](#other-limitations) section below for more details.
:::

Here is what it looks like when you render the web view into a texture and put it on a cube:

![](/images/webview-cube.png)

## Implementation

UniWebView provides a neat API to render the current web view content into a texture. However, this feature is turned off
by default for performance reasons. You need to manually start and stop the process of rendering as you need.

### Start Rendering Process

Before you begin to access any data or texture, you need to start the rendering process first. You can do it by calling the
[`StartSnapshotForRendering`](/api/#startsnapshotforrendering) method.

```csharp
public class MyBehaviour : MonoBehaviour {

  UniWebView webView;

  void OpenWebView() {
    webView = gameObject.AddComponent<UniWebView>();
    webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
    webView.Load("https://uniwebview.com");

    // Start the rendering process.
    webView.StartSnapshotForRendering();
  }
}
```

> It is no need to call `Show` method to actually display the web view. The rendering process will be started even if
> the web view is not visible.

### Create the Texture

You can choose either to create a texture once, or repeatedly create a new texture in the `Update` method. Gets the
texture and assign it somewhere in your scene. For example, assume there is a `cube` in the scene with a renderer:

```csharp
public class MyBehaviour : MonoBehaviour {

    // ...

    Renderer cubeRenderer; // cube.GetComponent<Renderer>();

    void Update() {
      if (webView != null) {
        Destroy(cubeRenderer.material.mainTexture);
        cubeRenderer.material.mainTexture = webView.CreateRenderedTexture();
      }
    }
}
```

Every call to `CreateRenderedTexture` creates a new texture. You should destroy the old one before creating a new one.
Otherwise, it will cause a memory leak and your game might be killed very soon.

> If you still want to show the texture in a plain 2D format, then a the Unity's `Plane` or `RawImage` might be your
> choice.

### Clean Work

Finally, when you no longer need the web view to generate any additional textures, it is a good practice to stop the
rendering process. This closes the data channel and clears the buffer to free up some memory.

```csharp
webView.StopSnapshotForRendering();
```

When you destroy the web view (by either calling the `Destroy` on the UniWebView component or destroying the whole
scene containing the web view), UniWebView will call the `StopSnapshotForRendering` for you. When you keep the best
practice that is mentioned in the [Memory Management](./memory-management.md) guide, usually you do not need to call
this method manually yourself.

Also, do not forget to destroy the last rendered texture:

```csharp
Destroy(cubeRenderer.material.mainTexture);
```

## Performance

It is heavy work to take snapshots of the web view and pass them between the native side and Unity, especially on
old devices. There are some small tips to improve the performance.

### Create Less Texture

The most straightforward way is creating less textures. Instead of creating a new texture in every `Update`, you can
set an interval. For example, a very naive change to make it create only a quarter of the textures compared to above:

```csharp
int counter = 0;

void Update() {
  if (webView != null) {
    count += 1;
    if (count == 4) {
      Destroy(cubeRenderer.material.mainTexture);
      cubeRenderer.material.mainTexture = webView.CreateRenderedTexture();
      count = 0;
    }
  }
}
```

### One Time Rendering

If the web content is static and does not change after the first load, instead of taking the snapshot in `Update`, you
can also choose to perform a one-time rendering by calling `StartSnapshotForRendering` in the `OnPageFinished`
event, and passing an `onStart` callback to it:

```csharp
public class MyBehaviour : MonoBehaviour {

  // ...

  void OpenWebView() {
    webView = gameObject.AddComponent<UniWebView>();
    webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
    webView.Load("https://uniwebview.com");

    webView.OnPageFinished += (view, code, error) => {
      webView.StartSnapshotForRendering(onStarted: texture => {
        cubeRenderer.material.mainTexture = texture;
      });
    };
  }
}
```

> Also, do not forget to call `Destroy(cubeRenderer.material.mainTexture);` at proper time to avoid memory leak.

### Size and Partial Snapshot

The size of the texture is also a factor that affects the performance. The larger the texture is, the more time it takes
to be rendered and passed between native and Unity.

To only take a partial snapshot of the web view, you can pass a `Rect` to the `CreateRenderedTexture` method:

```csharp
// Take the snapshot of 100x100 square in the middle of the web view.
var rect = new Rect(webView.Frame.width / 2 - 50,  webView.Frame.height / 2 - 50, 100, 100);
cubeRenderer.material.mainTexture = webView.CreateRenderedTexture(rect);
```

> The final pixel count of the snapshot matters. If you do not need the texture to be at the high resolution, you can
> also create a smaller web view from the very beginning, for example:
>
> ```csharp
> // webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
> webView.Frame = new Rect(0, 0, Screen.width / 4, Screen.height / 4);
> ```

## Other Limitations

The rendered texture is not a native view but only a live snapshot of the view. There are some other limitations other
than the performance.

### Interaction

The rendered texture is not interactive. You cannot click any link or button on the texture, or scroll the web view
by gesture.

Although the user interaction is not available, you can still call any `UniWebView` methods on the web view
programmatically. It is also possible to use methods like `ScrollTo` to "simulate" the scrolling, or use JavaScript to
"click" the button or link on the web page. For example, you can use the following code to get all links on the page,
and click the first one:

```csharp
webView.OnPageFinished += (view, statusCode, url) => {
    webView.EvaluateJavaScript("Array.from(document.links).map(link => link.href);", result => {
        var data = UniWebViewExternal.Json.Deserialize(result.data) as List<object>;
        // Use the data: ["https://example.com", "https://example.com/link1", ...]

    });
};

// Later, simulate the click on the first link.
webView.EvaluateJavaScript("document.links[0].click();");
```

> Simulating a user tap on the native view is not possible through public APIs on iOS. So it won't be implemented in
> the current UniWebView. We are keeping an eye on the latest iOS system changes. If Apple provides a way to do it in
> iOS, we will try to support it too.

### Video

Any hardware-accelerated content, such as video or WebGL elements, cannot be rendered. You will only see a black
rectangle in the place of the video.


---

### Rotation and Scale

# Rotation and Scale

> UniWebView supports transforming web views with rotation and scaling, enhancing display flexibility in Unity games.

UniWebView allows you to transform the web view by applying rotation and scale. This gives you more flexibility when displaying web content in your game.

## Rotation

You can rotate a web view by setting a `UniWebViewTransform` value. The rotation is performed around the center point of the web view's frame.

```csharp
// Set rotation to 30 degrees
var rotation = new UniWebViewTransform(30)
webView.SetTransform(rotation);
```

The rotation value is measured in degrees, and it rotates the web view clockwise. When you apply a rotation, the web view maintains its frame dimensions but appears rotated on screen.

## Scale

Scaling a web view changes its visual size without affecting the actual frame dimensions. This is different from setting the size directly through the frame.

```csharp
// Scale the web view to 1.5 times its original size
var scale = new UniWebViewTransform(1.5f, 1.5f)
webView.SetTransform(scale);
```

It differs from adjusting the web view size via the `Frame` property: scaling the web view does not alter the layout of the web content. The web view loads the content at its original frame size and then visually scales the final display. This ensures that text and other elements keep their positions as set by the original frame.

## Use Cases

Both rotation and scale operations are performed around the center point of the web view's frame. This center point serves as the pivot for all transformations.

### Full Screen Landscape Web View in Portrait Mode

A common scenario is to display a landscape (horizontal) web view in a portrait (vertical) game orientation, if you do not want the game to follow the device auto-rotation. Here is how you can achieve this:

```csharp
void SetRotationLandscapeFullScreen()
{
    // Calculate dimensions for a rotated full-screen web view
    float x = (Screen.width - Screen.height) / 2.0f;
    float y = (Screen.height - Screen.width) / 2.0f;
    float width = Screen.height;
    float height = Screen.width;

    // Set the frame to properly position the web view
    webView.Frame = new Rect(x, y, width, height);

    // Apply 90-degree rotation
    var rotation = new UniWebViewTransform(90);
    webView.SetTransform(rotation);

    // Show the web view
    webView.Show();
}
```

In this example:

1. We calculate a frame where the width and height are swapped compared to the screen
2. We position it centered on screen by adjusting x and y coordinates
3. We rotate it by 90 degrees around its center
4. The result is a full-screen web view in landscape orientation while the game remains in portrait mode

### Combined Transformations

You can combine rotation and scale transformations for more complex presentations:

```csharp
// Rotate by 45 degrees and scale to 80% of the original size
var transform = new UniWebViewTransform(45.0f, 0.8f, 0.8f);
webView.SetTransform(transform);
```

### Maximum Toolbar Height

When applying rotation and scale, the toolbar height will be still calculated by the original frame size. Sometimes it may cause a too-high toolbar since it will take the notch area into account. If you need a compact toolbar, you can set the maximum toolbar height:

```csharp
// Set the maximum height of the toolbar to 40 pixels.
webView.EmbeddedToolbar.SetMaxHeight(40);
```

If the calculated toolbar height exceeds the maximum height, it will be clamped to the specified value. Otherwise, the toolbar will be displayed at its original height. This is useful when you want to ensure that the toolbar does not take up too much space on the screen, especially when using rotation and scale transformations.


---

### Safe Browsing Mode

# Safe Browsing Mode

> UniWebView's Safe Browsing Mode offers a full-screen, browser-like web experience with customizable UI and requires device support checks.

In this guide, we cover both of the prefab and code use of the Safe Browsing Mode.

In the Safe Browsing Mode, the web content will be displayed full-screen with a default UI on either iOS and Android:

![](/images/safe-browsing-mode-compare.png)

> Safe Browsing Mode is a simpler and out-of-the-box solution to show the web page as it is in the browser. For more detail about the difference between the general-purpose web view and the Safe Browsing Mode, refer to [this guide](./overview.md#two-options).

## Checking Availability

Before creating and showing a page, please ensure that the Safe Browsing Mode is available on the device. To do so, call
`IsSafeBrowsingSupported` and check its result:

```csharp
if (UniWebViewSafeBrowsing.IsSafeBrowsingSupported) {
    // Safe Browsing Mode is available on current device.
}
```

#### Target API Level higher than Android 11

If you set your **Target API Level to Android 11 (30) or later**, you need to add the correct intent query
explicitly in your `AndroidManifest.xml` file, to follow the [Package Visibility](https://developer.android.com/about/versions/11/privacy/package-visibility)
to add `queries` as a sub-node of the `manifest` tag:

```xml{6-10}
<manifest>
  // ...

  </application>

  <queries>
    <intent>
      <action android:name="android.support.customtabs.action.CustomTabsService" />
    </intent>
  </queries>
</manifest>
```

::: warning Package Visibility from Android 11
If you are setting Target API Level higher than Android 11 (API Level 30), but not setting the `queries` in your
`AndroidManifest.xml`, the `UniWebViewSafeBrowsing` related APIs will not work expectedly.
:::

#### About `IsSafeBrowsingSupported`

This property always returns `true` on iOS runtime platform. On Android, it depends on whether there is an Intent
can handle the safe browsing request. Usually this ability is provided by Chrome, but there are also other browser apps
might implement that. If there is no Intent can open the URL in safe browsing mode, or the handling app is set to
disabled in Android system settings, this property returns `false`.

You can only use the Safe Browsing Mode when the property is `true`. Otherwise, please let your user know how to enable
it by re-installing Chrome and enable it in the system settings.

## Prefab

> Remember to remove the previous `UniWebView.prefab` first if you just followed the [Web View - Prefab](./using-prefab.md) guide.
> Both prefabs try to show the web page up in the `Start` method, so you may get into a conflict.

The steps of using the safe browsing prefab are almost the same as above: drag the `UniWebViewSafeBrowsing.prefab` under
`UniWebView/Prefab` folder to your scene, configure it, and play the scene. UniWebViewSafeBrowsing prefab only provides one property:

![](/images/webview-safe-browsing-prefab-v5.png)

Set it to `https://uniwebview.com`, and build the scene to a device. The web page with a default title and toolbar UI will be displayed:

![](/images/webview-safebrowsing-sample.png)

## Code

### Create & Show

You can also create a safe browsing view by code:

```csharp
// Create a UniWebViewSafeBrowsing instance with a URL.
var safeBrowsing = UniWebViewSafeBrowsing.Create("https://docs.uniwebview.com");

// Show it on screen.
safeBrowsing.Show();
```

::: danger HTTP & HTTPS
Only web content hosted by HTTP or HTTPS is supported in Safe Browsing Mode. Attempts to load a local file URL in Safe Browsing Mode causes a runtime error.
:::

::: warning Safe Browsing Memory
Once created, the Safe Browsing component in native side will be there and taking memory until dismissed.
In other words, you need to at least call `Show` once you create a Safe Browsing. Otherwise, its memory is leaked.
:::

### Customization & Events

#### Color

You can customize the color of title/tool bar background:

```csharp
var color = new Color(0.263f, 0.627f, 0.278f);

// Background color.
safeBrowsing.SetToolbarColor(color);

// Controls color. Only for iOS.
safeBrowsing.SetToolbarItemColor(Color.white);
```

The code above will give you a colorful toolbar:

![](/images/sb-toolbar-ios.png)

![](/images/sb-toolbar-android.png)

::: warning Controls color on Android
Although in the screenshot above, the controls are rendered with white and it seems that `SetToolbarItemColor` also applies to Android, that method actually only works for iOS.

On Android, the system will automatically pick from white or black, based on the background color you set by `SetToolbarColor`, to make sure the text is clearly visible.
Check the color palettes in the [Material design color guide](https://material.io/design/color/the-color-system.html#tools-for-picking-colors) to get detail on which color will be used.
:::

#### Finish Event

`UniWebViewSafeBrowsing` delivers an `OnSafeBrowsingFinished` event when the browsing is done and web page is dismissed by user. It is a good time to restore your game session or reset any reference you are using to the `UniWebViewSafeBrowsing` object.

```csharp
safeBrowsing.OnSafeBrowsingFinished += (browsing) => {
    Debug.Log("UniWebViewSafeBrowsing is closed.");
};
```

#### Safe Browsing Mode in Editor

On macOS Editor, due to the corresponding native class is not available, there is no such "Safe Browsing Mode". When you create and show a `UniWebViewSafeBrowsing`, UniWebView falls back to `Application.OpenURL`. That means:

- Your URL will be opened in an external browser on system, such as Safari or Chrome.
- The customization methods and the events do not work. Any logic you write in `OnSafeBrowsingFinished` will never be called in Editor.


---

### Supporting New Window

# Supporting New Window

> UniWebView supports new windows in web views through configuration, allowing links and JavaScript to open new tabs or windows.

::: tip Choose Safe Browser Mode
This guide is for the general-purpose web view.

To get full support for a new window or new tab, we suggest you choose to use the Safe Browsing Mode, which gives a browser level experience.
:::

### Links with "\_blank" attribute

In a general web browser (like Chrome or Safari), a URL with `target="_blank"` attribute is intended
to be opened in a new tab. However, in the context of web view, there is no way to handle new tabs without
proper configurations. Due to that, by default UniWebView will ignore the `target="_blank"` and try to open
the page in the same web view if that kind of link is pressed.

This works for most cases, but if this is a problem to your app logic, and you need to handle the new tab,
you can change this behavior by calling `SetSupportMultipleWindows` with `true`:

```csharp
webView.SetSupportMultipleWindows(true, false);
```

It enables the "opening in new tab" behavior in a limited way, by adding the new tab web view above to the current web
view, with the same size and position. When the opened new tab is closed, it will be removed from the view hierarchy
automatically.

The new tab web view is just a temporary layer: it is not a fully functional `UniWebView` component itself, and will not
follow all settings as the original web view. You have to make sure it can be dismissed correctly, for example, using
a JavaScript to call `window.close()`. Otherwise, the original web view will be always covered and invisible.

### Opening window with JavaScript

Besides of a link with "\_blank" attribute, there is another way to open a new window: JavaScript. An invocation of `window.open`
will ask the web view to open a new window. To support it, make sure you pass `true` as the second parameter (`allowJavaScriptOpening`) to the
`SetSupportMultipleWindows` method. On some devices, you also need to call `SetAllowJavaScriptOpenWindow` before creating
the web view to allow UniWebView can receive the opening request:

```csharp
UniWebView.SetAllowJavaScriptOpenWindow(true);
var webView = // Creating the web view component...

webView.SetSupportMultipleWindows(true, true);

// Then, you can use JavaScript like `window.open` to open the web view.
```

> The code above allows any JavaScript to open a new window, even without user's action. It might be an issue in some cases,
> especially if you are using an iframe to display an external page, or some un-controlled third-party JavaScript
> code is contained in your page. Use it at your own risk.

For more about this topic, please check the [API reference](/api/#setsupportmultiplewindows) of `SetSupportMultipleWindows`.


---

### Submit a Ticket

# Submit a Ticket

> Use the AI-driven chat bot for quick help or submit a private ticket for direct support if needed.

## Chat Bot

Cannot find answers for your questions in our guide or [FAQ page](./faq.md)? Please try to ask the chat bot below and see if it helps.

> Please note that the chat bot is driven by the AI and it might not be always able to answer all your questions correctly.

<iframe
 src="https://dify.onev.dev/chatbot/0p3I4SR5pWnW6gnG"
 style="width: 100%; height: 100%; min-height: 700px"
 frameborder="0"
 allow="microphone">
</iframe>

## Ticket

If the bot does not help, [submit a ticket and contact us](https://onevcat.atlassian.net/servicedesk/customer/portal/2). All discussions are private between you and the support staff.


---

### Term of Service (Terms)

# Term of Service (Terms)

> UniWebView's Terms of Service, aligned with Unity Asset Store'sToS, govern use, content ownership, and allow for service modifications and termination.

::: tip DATE
Last updated: 2018-03-06
:::

UniWebView follows ToS of Unity Asset Store. Please [read that](https://unity3d.com/legal/as_terms) before you continue to use Unity Asset Store and UniWebView.

Additionally, please read these Terms of Service ("Terms", "Terms of Service") of UniWebView carefully before using the UniWebView (the "Service") operated by us.

You acknowledge and agree that, by accessing, purchasing or using the Service, you are indicating that you have read, understand and agree to be bound by the agreement. By accessing or using the Service you agree to be bound by these Terms. If you disagree with any part of the terms then you may not access the Service.

### Termination

We may terminate or suspend access to our website or customer support service immediately, without prior notice or liability, for any reason whatsoever, including without limitation if you breach the Terms.

All provisions of the Terms which by their nature should survive termination shall survive termination, including, without limitation, ownership provisions, warranty disclaimers, indemnity and limitations of liability.

### Modification

UniWebView reserves the right, at its sole discretion, to modify the Services. UniWebView may also modify the Agreement at any time and without prior notice. If we modify the Agreement, we will post the modification on the Site or otherwise provide you with notice of the modification. We will also update the “Last updated” date at the top of these Terms.

### Content

The Site, Software, Developer Services, Communities and Website Content (as that term is defined in the Site and Communities Additional Terms) are protected by copyright, trademark, and other laws. Except as expressly provided in the Agreement, UniWebView and its licensors exclusively own all right, title and interest in and to the Services, including all associated intellectual property rights. You will not remove, alter or obscure any copyright, trademark, service mark or other proprietary rights notices incorporated in or accompanying the Services.

As between you and UniWebView, you own all right, title and interest (including, all intellectual property rights) in and to the content you create using the Software, Developer Services and/or any content you post to the Site or in the Communities (collectively, “Your Content”) (other than any components of the Software contained therein or used in connection therewith).

UniWebView and its developers of the Service has no control over, and assumes no responsibility for, the content, privacy policies, or practices of any third party web sites or services. You further acknowledge and agree that UniWebView and its developers shall not be responsible or liable, directly or indirectly, for any damage or loss caused or alleged to be caused by or in connection with use of or reliance on any such content, goods or services available on or through any such web sites or services.

If you have any questions about these Terms, please contact us.


---

### Transition

# Transition

> UniWebView offers customizable show/hide transitions and position/size animations for web views.

The transition effect in UniWebView is easy. We provide several built-in show/hide visual transition effects. You can also animate the position and size of web view on the screen.

## Show / Hide Transition

`Show` and `Hide` methods accept several parameters to define a better visual effect and natural transition experience. The full signatures (and their default values) of these methods are:

```csharp
bool Show(
    bool fade = false,
    UniWebViewTransitionEdge edge = UniWebViewTransitionEdge.None,
    float duration = 0.4f,
    Action completionHandler = null
)

bool Hide(
    bool fade = false,
    UniWebViewTransitionEdge edge = UniWebViewTransitionEdge.None,
    float duration = 0.4f,
    Action completionHandler = null
)
```

By default, if no parameters are given when called, the `Show` and `Hide` happens without animation. If you set either the `fade` to `true` or the `edge` to any value except for `UniWebViewTransitionEdge.None`, there will be a transition animation.

- `fade` - Fades in or out the web view while show or hide.
- `edge` - Defines the **show from** or **hide to** edge. The edge transition is a modal presenting or dismissing animation.

These sample code below:

```csharp
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
webView.Show(true, UniWebViewTransitionEdge.Bottom, 0.35f);

// Later
webView.Hide(true, UniWebViewTransitionEdge.Bottom, 0.35f);
```

produces the result in the video below:

<div>
<video class="video-player" src="/images/transition.mp4" controls="controls"></video>
</div>

::: warning NOTICE
A `bool` value is returned from `Show` or `Hide`, it represents whether the `Show` or `Hide` command is accepted and going to be executed.

Only **one transition is allowed at a time**. If you are trying to initialize another transition while the previous not finished yet, the new one will not start and the return value would be `false`.
:::

## Move Animation

UniWebView also supports to be animated to a new position and size while it is being displayed:

```csharp{5-8}
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);

var halfScreen = new Rect(0, 0, Screen.width, Screen.height / 2.0);

// The animation will last for 400ms and with 100ms delay:
webView.AnimateTo(halfScreen, 0.4f, 0.1f, ()=>{
    print("Animation finished!");
});
```

For more about transition and animation, read the [API Reference](/api/).


---

### Clicking Through

# Clicking Through

> UniWebView enables clicking through transparent web pages to interact with Unity scenes behind.

If you have a web page with transparency background, it is possible to click through the web page and deliver the touch events to the Unity scene behind. This is called "Transparency Clicking Through" in UniWebView.

## Steps

There are three steps before you can actually click through the transparent part on web view.

### Enabling click through check

Calling [`SetTransparencyClickingThroughEnabled`](/api/#settransparencyclickingthroughenabled) with `true`. This allows UniWebView to check every touch and the pixel color at the touch point.

You can simply do this after creating the web view:

```csharp
webView = gameObject.AddComponent<UniWebView>();
webView.SetTransparencyClickingThroughEnabled(true);
```

### Preparing a transparent web page

To allow clicking through, it is required that the Unity scene is visible even under the web view. So you need to have a transparent web page content in HTML. Normally, it is controlled by the style used by `body` tag in the page:

```html
<body style="background-color: transparent"></body>
```

Or in the CSS:

```css
body {
  background-color: transparent;
}
```

> By default, if `background-color` style is not set in the `body`, it has a default value of `transparent`. See the [related documentation](https://www.w3schools.com/cssref/pr_background-color.asp) for more.

### Setting clear background color for web view

Lastly, you need to set a clear color to the `BackgroundColor` property of UniWebView.

```csharp
webView.BackgroundColor = Color.clear;
```

> The `BackgroundColor` is different from the `background-color` of HTML body. It is the background color of the web view control, while `background-color` is for the HTML web content.

## Full example

Here you can find a [sample HTML page](/passthrough.html.zip) with transparent background. There are two buttons on the web page. When clicking, they use UniWebView's [Messaging System](/guide/messaging-system.html) to deliver messages to Unity. Meanwhile the web view is displayed in full screen, the UI in Unity scene is available at the same time.

Here is some reference code:

```csharp
Text passthroughText;
UniWebView webView;

void ShowWebView() {
    // Prepare Unity UI.
    passthroughText.text = "Sample Text";

    // Create web view.
    webView = gameObject.AddComponent<UniWebView>();
    webView.Frame = new Rect(0, 0, Screen.width, Screen.height);

    // Allow transparency clicking through.
    webView.SetTransparencyClickingThroughEnabled(true);
    // Make Unity scene visible.
    webView.BackgroundColor = Color.clear;

    // Disable the scrolling bounces effect to fix the web UI.
    webView.SetBouncesEnabled(false);

    webView.OnShouldClose += (view) => {
        webView = null;
        return true;
    };

    webView.OnMessageReceived += (view, message) => {
        if (message.Path == "close") {
            Destroy(webView);
            webView = null;
        } else if (message.Path == "hello") {
            passthroughText.text = "Hello From Web View";
        }
    };

    webView.Load("https://docs.uniwebview.com/passthrough.html");
    webView.Show();
}

void UnityCloseButtonTapped() {
    Destroy(webView);
    webView = null;
}
```

![](/images/passthrough.jpg)

The "Sample Text" and "Close From Unity" are created and as a part of Unity UI.
Although the web view covers full screen, the Unity scene is still visible and all three buttons will be responsible and do their works.


---

### Trouble Shooting

# Trouble Shooting

> UniWebView build errors and runtime crashes can be resolved by adjusting settings in Unity Preferences and performing a clean build.

## Android

### Building Error

In most cases, it might be some errors saying "duplicate class" when exporting for Android. It happens if you have another package already adding the same package UniWebView requires.

UniWebView mainly needs two packages as dependencies:

- Kotlin standard library ([org.jetbrains.kotlin:kotlin-stdlib-jdk7](https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-stdlib-jdk7))
- Android X Browser ([androidx.browser:browser](https://mvnrepository.com/artifact/androidx.browser/browser))

By default, UniWebView will detect the Gradle file and add both automatically.

However, if any other package in your project is already adding the same libraries in an undetectable way (such as embedding them as a part of the library file, or downloading the duplicated package into "Plugins/Android" folder), UniWebView will fail to detect them and add duplicated packages.

Most of the issues can be solved by adjusting the settings under the **"UniWebView" section**, which in the **Unity Preferences** panel. Press the "Settings" item in Unity's menu and open it, then follow the instructions below based on the error you have in the Unity console or Android log.

![](/images/preferences-v5.png)

::: tip
In almost all cases, it is important to perform a Clean Build after you change the settings. You can find it in the dropdown menu in the "Build Settings" window.
![](/images/clean-build.png)
:::

---

::: danger Building Error
"Duplicate class androidx.browser. ... in modules (androidx.browser:browse)"
:::

1. Turn off "Adds Android Browser".
2. Turn on "Adds Android X Core". (It appears when "Adds Android Browser" is off)
3. Perform a Clean Build.

---

::: danger Building Error
"Duplicate class kotlin..."
:::

1. Turn off "Adds Kotlin".
2. Perform a Clean Build.

---

::: danger Building Error
"Duplicate class android.support.v4.app ..."
:::

1. Turn off "Adds Android Browser".
2. Turn on "Adds Android X Core". (It appears when "Adds Android Browser" is off)
3. Find and remove the legacy support package from your project. Usually it is a jar file containing `android-support-4.0` or similar in its name, under your Plugins/Android folder.
4. Make sure "Enable Jetifier" is enabled. Your packages depending on the legacy support package will be converted to Android X automatically.
5. Perform a Clean Build.

---

### Runtime Crash

::: danger Crash
"Unable to get provider com.onevcat.uniwebview.UniWebViewFileProvider..." on app launch
:::

1. Check if "Adds Android X Core" is enabled (it appears when "Adds Android Browser" is off). If the "Android Browser" is not added, UniWebView will require this package to work.
2. Turn on "Adds Android X Core".
3. Perform a Clean Build.


---

### Uploading

# Uploading

> UniWebView supports file uploads from device or cloud, with specific iOS setup required for camera access.

UniWebView supports uploading files from the disk of your device or from a cloud service to your website.

To show an upload field, use the standard input tag with proper type:

```html
<input type="file" name="filename" accept="image/*" />
```

When the user clicks the select file button, UniWebView will prompt the user from where they want to choose a file.
If you specified the "accept" to `image/*` as the sample above, only photo sources and image files will be available.
You can also change the "accept" type to a wider `*/*`, which will cause all types of files be choosable.

::: warning NOTICE
Additional steps are required for allowing uploading in some cases, please keep reading below to know more about it.
:::

### Additional Setup

On iOS, if you just want your user upload images from the photo library, it should already work without any effort. However, if you want to let users upload images from cameras, you need to set [NSCameraUsageDescription](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW24) in your Info.plist file. Otherwise, your app would crash when users choose to take photos or videos with the camera.

::: tip Apple-specific setup
You can set the `NSCameraUsageDescription` key from Unity's player settings panel. Check [Unity documentation](https://docs.unity3d.com/Manual/PlayerSettingsiOS-Other.html#Config-Apple) for detail.
:::


---

### Using JavaScript

# Using JavaScript

> UniWebView allows adding and executing JavaScript functions on web pages, with options to disable JavaScript for performance or security.

You can run any JavaScript embedded in the web page. Or you can even add new JavaScript functions to the current page.

## Add a Function

Call `AddJavaScript` to add some JavaScript to your page. This is an asynchronous API with a callback action. You can check the `resultCode` there to ensure the function is added without any problem.

```csharp{2-6}
webView.OnPageFinished += (view, statusCode, url) => {
    webView.AddJavaScript("function add(a, b) { return a + b; }", (payload) => {
        if (payload.resultCode.Equals("0")) {
            print("Adding JavaScript Finished without error.");
        }
    });
};
```

If any error occurs when you adding the JavaScript (syntax error, in most cases), the `resultCode` will not be "0".

::: tip JavaScript Related Methods
In the example above, we add the JavaScript inside the `OnPageFinished` event callback.

The JavaScript is always bound to a context, or say, the current web page. You can only add functions to a page, or execute a function which is already on the page. Usually, it is a good idea to perform JavaScript related operation **after the page being loaded** (inside `OnPageFinished`).
:::

## Run a Function

Call `EvaluateJavaScript` to run a JavaScript:

```csharp{3-7,11}
webView.OnPageFinished += (view, statusCode, url) => {
    webView.AddJavaScript("function add(a, b) { return a + b; }", (payload) => {
        webView.EvaluateJavaScript("add(1, 2);", (payload) => {
            if (payload.resultCode.Equals("0")) {
                print("1 + 2 = " + payload.data);
            }
        });
    });
};

// => "1 + 2 = 3"
```

Similar to `AddJavaScript`, the `payload` of `EvaluateJavaScript` also contains a `resultCode` to indicate whether the calling is successful or not. If everything goes fine, you can find the returned value of the JavaScript in `payload.data`.

Not only the functions you added, you can also execute any JavaScript already there, just like what you do in a modern browser. For example, to get the `innerHTML` of the whole document we loaded:

```csharp
webView.EvaluateJavaScript("document.body.innerHTML", (payload) => {
    // Do something with payload.
});
```

> You can also get the content of the page by the [GetHTMLContent](/api/#gethtmlcontent) method.

Thanks to the modern mobile web view component, UniWebView is fully compatible with JavaScript. You can expect that almost all features are supported in UniWebView if they are supported in the browser of your device. That means you are free to use lots of third-party JavaScript libraries to enhance your browsing experience. It is even possible to run a complicated Single Page Application built on something like React and Vue.js without any problem.

## Disabling

If you are not using any JavaScript, you could disable it by `UniWebView.SetJavaScriptEnabled(false)`. All web view created after this setting does not support JavaScript, it would give you a faster speed when browsing non-JavaScript content or for certain security purposes.


---

### Web View - Prefab

# Web View - Prefab

> UniWebView prefab simplifies adding a web view to Unity scenes, with options for URL loading and toolbar customization.

In this guide, we will add a `UniWebView.prefab` to the scene and show a sample page with it. This covers the basic usage of the general-purpose web view through prefab.

## Adding to Scene

[Prefab](https://docs.unity3d.com/Manual/Prefabs.html) is the fastest way to integrate a web view to your project. You can find the general-purpose web view prefab in `UniWebView/Prefab/UniWebView.prefab`:

Drag it to the scene you need to show a web view. Then you can configure the properties of the component in the Inspector Tab.

#### UniWebView.prefab Inspector

The `UniWebView.prefab` provides settings as below by default:

![](/images/uniwebview-property-v5.png)

For now, just input your web page URL into the "Url On Start" field (eg. `https://uniwebview.com`) and leave others as default. If you are on macOS, click the "Play" button in Unity Editor and now you should be able to see the web view opened and the page is loaded. You could also build it to an iOS or Android device to see how it works in the real device!

::: warning
If Unity reports any error when you play the scene, try to restart your Unity Editor and give it a chance to load the plugin at launch.
:::

::: details Properties Detail

---

##### Url On Start

> The URL which will be loaded in `Start()` of UniWebView. A normal web URL started with "http://" or "https://" is supported.

##### Show On Start

> Show the web view in `Start()`. If `false`, the web view will not show up automatically. You need to call `Show` method of the web view to display it later.

##### Full Screen

> Make the web view be full screen at start. If `true`, the "Frame" and "Reference Rect Transform" below will be ignored.

##### Use Toolbar

> **Deprecated.** Do not use it anymore. It is replaced by "Use Embedded Toolbar".

> ~~This is only for iOS and macOS Editor. By turning this on, a toolbar contains Go Back Button, Go Forward Button and Done Button (iOS only) will be shown with the web view. Your user could use this toolbar to navigate and close the web view. On Android, users could use the back button in the navigation bar to perform "go back" and "close" operation, so there is no need to supply a toolbar for Android.~~

##### Toolbar Position

> **Deprecated.** Do not use it anymore. It is replaced by "Embedded Toolbar Position".

> ~~If "Use Toolbar" is on, UniWebView will show the toolbar in the position specified by this. It only works for iOS, since on macOS the toolbar will always show in the window title bar.~~

##### Use Embedded Toolbar

> Show an embedded toolbar with the web view. It contains a Go Back Button, a Go Forward Button, a Done Button and a title label (default empty). Your user could use this toolbar to navigate and close the web view.

##### Embedded Toolbar Position

> If "Use Embedded Toolbar" is on, UniWebView will show the toolbar in the position specified by this. On macOS the toolbar will always show in the window title bar.

##### Frame

> Set the rect frame value for the web view. It is a `Rect` which indicates web view's origin point and its size as: `{x, y, width, height}`. If you need a fixed-size web view regardless of the screen size is, you could uncheck the "Full Screen" option, leave "Reference Rect Transform" to `null` and set this "Frame" instead.

##### Reference Rect Transform

> UniWebView could refer to a `RectTransform` and change web view size to follow that transform. It is very useful if you are using [Unity UI](https://docs.unity3d.com/Manual/UISystem.html) and/or with [Multiple Resolutions](https://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html) support. You can just create a UI element (like a `Panel`) under your Canvas and assign its `RectTransform` component here. UniWebView will determine the position and size based on this transform. You need to uncheck the "Full Screen" option, and setting "Reference Rect Transform" will also make "Frame" ignored.

:::

When you exporting your project to a device, please remember to contain the sample scene in the Build Settings. Here is what it would look like when opening in an iOS device:

![](/images/webview-sample.png)

## Instantiating at Runtime

Instead of adding the prefab to the scene before running it, you can also instantiate it at runtime. There is nothing different from instantiating a UniWebView prefab than any other normal prefab. Please refer to [Unity's documentation](https://docs.unity3d.com/Manual/InstantiatingPrefabs.html) to know more about this topic.

Once a UniWebView gets closed by Done Button or Back Button, it will destroy the component itself by default for releasing resources as soon as possible. You will not be able to reuse the same UniWebView. You need to create a new UniWebView if you want to display another page. Don't worry if you are not sure what does that means. We will explain this behavior in the [memory management](./memory-management.md) section later.

## Next Step

It is fairly easy to add a web view by using the UniWebView prefab. But to use all features of UniWebView, you have to write some code. We have a set of elegant and simple APIs. Even without any experience in coding before, it should be not hard for you to follow up the guide and control UniWebView fine. Follow the [Working with Code](./working-with-code.md) chapter to get your hand dirty now! :sweat_drops:


---

### Version Highlight

# Version Highlight

> UniWebView 6 introduces the Channel Message system for high-performance bidirectional communication, enhanced error handling, and improved messaging reliability between web pages and Unity.

::: tip Upgrade Pricing
If you have purchased UniWebView 5 before, we offer an upgrading discount.

For users:

- Purchased from our Gumroad Store - [Submit a ticket](https://onevcat.atlassian.net/servicedesk/customer/portal/2/group/2/create/10011) with your purchasing Email and we will send a coupon back.
- Purchased from Unity Asset Store - Sign in to Asset Store and visit [our product page](https://assetstore.unity.com/packages/slug/229334)
  to find the Upgrade Price.
  :::

UniWebView contains some significant improvements over its predecessor UniWebView 5. Here we will list a few of them to
give you an overview about what are added and changed.

### Channel Message System

UniWebView 6 introduces a revolutionary **Channel Message system** that provides high-performance, bidirectional communication between web pages and Unity. This new system addresses the limitations of traditional URL scheme messaging:

- **No size limits** for data transfer
- **No message loss** in high-frequency scenarios
- **Bidirectional communication** with sync/async patterns
- **Direct JSON object** passing without encoding
- **Enhanced error handling** with structured responses
- **Cross-platform consistency** (iOS, Android, Unity)

The Channel Message system offers three communication patterns:

| Pattern | Method | Description |
| ------- | ------ | ----------- |
| Fire-and-Forget | `send(action, data)` | Async messages without response |
| Synchronous Call | `call(action, data)` | Immediate return values |
| Async Request | `request(action, data)` | Promise-based responses with timeout |

For more information about the Channel Message system, please check the [Channel Message Guide](./channel-message.md).

### Enhanced Error Handling

UniWebView 6 provides structured error responses that include error codes, detailed messages, and additional metadata. This makes debugging and error handling much more robust in production applications.

### Improved Performance and Reliability

The new messaging system eliminates URL encoding overhead and navigation cancellation issues, providing better performance and reliability for communication-heavy applications.

The pure JavaScript uploading controls are now also supported. For more, please read the [Uploading](./uploading.md) guide.

### Improved Export Phase

In previous versions, when exporting with Release configuration and project minifying on, it is possible that the required
symbols gets stripped out on Android. In UniWebView 5, we have a deeper integration with Unity's build pipeline to make sure
this not happen again. Now the exporting behavior should be much more stable under different build configurations.

Starting from UniWebView 5, the library on Android now are also built with minify enabled, which means a smaller binary
size and an improvement of project security.

### Much More

Please check other guides in the side bar and the [API Documentation](/latest/api/overview) to know more about UniWebView.
We strongly suggest you upgrade to the latest version for a more powerful and stable web view component.

If you need to migrate from UniWebView 4 to the latest UniWebView 5, please refer to the [Migration Guide](./migration-guide-v4-to-v5.md).

You can find other recent changes and all release logs in the [Release Note](../release-note) page.


---

### WebRTC Support

# WebRTC Support

> UniWebView supports WebRTC on iOS 14.3+ and Android, requiring specific configurations for safe browsing or regular web view use.

[WebRTC](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API) (or say, the popular `getUserMedia` or similar
APIs) is supported from iOS 14.3 and all Android versions. But it requires a few steps before you can use it.

First, you need to choose either using the **Safe Browsing Mode** (if you only need to display a web page full screen
and do not need other customization) or using the **regular web view** (when you need to resize the web view and get
more control).

### Using Safe Browsing Mode

It is recommended that you use the [Safe Browsing Mode](safe-browsing.md) to show WebRTC contents. It launches an
environment closer to a real browser, where WebRTC can work seamlessly.

```csharp
if (UniWebViewSafeBrowsing.IsSafeBrowsingSupported) {
  var safeBrowsing = UniWebViewSafeBrowsing.Create("https://webrtc.github.io/samples/");
  safeBrowsing.Show();
}
```

::: warning NOTICE
On Android, you need to add an intent query to allow `UniWebViewSafeBrowsing` API available. Please follow the
"Checking Availability" part in the [Safe Browsing Mode](safe-browsing.md#checking-availability) guide.
:::

### Using Regular Web View

If you need to take more control over the web view, you can still use the regular web view. Before the WebRTC APIs can
work on your page, you need to configure the web view and project. In the example below, we try to use the camera. If
you need other hardware such as the microphone, you can add the corresponding permissions as well.

#### On iOS

1. Make sure you are targeting iOS 14.3 or later. Before iOS 14.3, there is no support for WebRTC on the iOS system.
2. Add the code below to enable auto-play on iOS before you create a web view. Otherwise, the captured video won't play
   correctly.

   ```csharp
   UniWebView.SetAllowAutoPlay(true);
   UniWebView.SetAllowInlinePlay(true);

   // Now, you can create the web view.
   var webView = webViewGameObject.AddComponent<UniWebView>();
   // ...
   ```

3. Add `NSCameraUsageDescription` key in the Info.plist to the exported Xcode project. You can do this by setting a
   value to the "Camera Usage Description" field in the "Player Settings, iOS Settings tab" of your Unity Project.

   > If you also need to access other hardware, you can add the corresponding permissions as well, such
   > as `NSMicrophoneUsageDescription` for microphone.

#### On Android

1. Add the code below to enable auto-play on Android before you create a web view. Otherwise, the captured video won't
   play correctly on certain API Levels.

   ```csharp
   UniWebView.SetAllowAutoPlay(true);
   UniWebView.SetAllowInlinePlay(true);

   // Now, you can create the web view.
   var webView = webViewGameObject.AddComponent<UniWebView>();
   // ...
   ```

2. Request the camera permission in either the AndroidManifest.xml and through Unity's `Permission` class.

   ```csharp
   Permission.RequestUserPermission(Permission.Camera);

   // Maybe you need these too in some cases in AndroidManifest.xml:

   <manifest xlmns:android...>
     ...
     <uses-permission android:name="android.permission.CAMERA" />
   <application ...
   </manifest>
   ```

   > If you also need to access other hardware, you can add the corresponding permissions as well, such
   > as `android.permission.RECORD_AUDIO` for microphone.

#### Prompt for Permission

Now, when you load a page that uses WebRTC, the web page will prompt the user to allow the hardware access.

```csharp
webView.Load("https://webrtc.github.io/samples/");

// When you open a demo on the page (such as "Basic getUserMedia demo") and
// start to use the media hardwares, a prompt will show up.
```

![](/images/permission-prompt.jpg)

::: tip Grant Permission by Default
If you have a certain host that you trust and want to allow the hardware access by default without showing the prompt alert, you can use the `RegisterOnRequestMediaCapturePermission` to handle the request by yourself.

Check the related [API documentation](/api/#registeronrequestmediacapturepermission) for more details.

```csharp
webView.RegisterOnRequestMediaCapturePermission((permission) => {
    if (permission.Host == "webrtc.github.io") {
        return UniWebViewMediaCapturePermissionDecision.Grant;
    }
    return UniWebViewMediaCapturePermissionDecision.Prompt;
});
```

:::


---

### Web View - Code

# Web View - Code

> Learn to create and interact with UniWebView in Unity, including loading pages, handling events, and using JavaScript for web view communication.

[[toc]]

---

::: tip
This tutorial is assuming you are using a general-purpose web view. Using code to show web view in Safe Browsing Mode is much easier, and described in the [Safe Browsing Mode](./safe-browsing.md) guide.
:::

In this tutorial, we will see how to create and use the general-purpose UniWebView with code. In this tutorial, we will load [a sample page](https://docs.uniwebview.com/game.html) hosted on this site and perform some interaction with it. You can learn:

- How to attach a `UniWebView` component to a game object.
- How to load a sample page in the web view and handle the loading events.
- How to work with some essential features, like JavaScript and UniWebView messaging system.

> The sample page is not doing much for now if you open it in your browser. Don't worry, we will soon see how it is working with UniWebView.

Enough talk, let's begin.

### Creating a UniWebView

If you have already followed the [Installation](./installation.md) and [Prefab](./using-prefab.md) guide, you can just delete the `UniWebView` prefab in your scene and continue.

If you are going to start with a fresh project, you can create an empty Unity project and import UniWebView by following the [Installation guide](./installation.md). After importing UniWebView, remember to restart the Unity Editor, as well as change the target platform to either "iOS" or "Android" in Build Settings.

The first task is creating a UniWebView by code and make it show our content. In [previous chapter](./using-prefab.md), we did it with the prefab. But it is only a fast way to show content with very limited configurable items. Here, to get more control of the UniWebView component, we will do it in code, step by step.

#### Adding `Controller`

In the opened sample scene (or you can also create a new scene), add an empty `GameObject` by **GameObject → Create Empty** in menu. Rename the newly created game object to "Controller". It will be our controller object for the scene.

Select the newly added `Controller` object, click **Add Component** button in the Inspector. Choose **"new script"** and create a script with **"Controller" as its name**.

After these steps, your project should look like this:

![](/images/controller-created-v5.png)

#### Adding `UniWebView` Component

Open Controller.cs with any text editor you like, modify the content of that file to:

```csharp{7,12-16}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Controller : MonoBehaviour {

    UniWebView webView;

    // Start is called before the first frame update
    void Start ()
    {
        // Create a game object to hold UniWebView and add component.
        var webViewGameObject = new GameObject("UniWebView");
        webView = webViewGameObject.AddComponent<UniWebView>();

        // More to add...
    }

    // Update is called once per frame
    void Update ()
    {

    }
}
```

It creates a new `GameObject` with the name of "UniWebView" in the current scene when the `Start()` method called for the Controller. We also add a `UniWebView` component to that game object and store the component in the `webView` property in `Controller`.

> The name "UniWebView" used when creating the `GameObject` is only for demonstration purpose. You can use any name you like.

#### Load and Show

Now let's add more code to config the web view and load our sample page now. Add the code below at the end of `Start()` method, replace the "More to add..." line to:

```csharp{6-8}
void Start ()
{

    //...

    webView.Frame = new Rect(0, 0, Screen.width, Screen.height); // 1
    webView.Load("https://docs.uniwebview.com/game.html");       // 2
    webView.Show();                                              // 3
}
```

1. Set the web view's frame to the full screen. On iOS and Android, it will use the display size and make the web view take all of the area. On macOS Editor, the player screen size will be used to create a new window which contains web view.
2. The `Load` method will do exactly what you expect, it starts to load the page at the given URL. Here, we load our demo page hosted on the UniWebView site. You will see it later.
3. `Show` the web view so it becomes visible. This method and its opposite `Hide` method has several parameters to control the transition. For now, we just use the default behavior without any animation. You can learn more about this topic in the [Transition](./transition.md) chapter.

Now, you could start the game to see what will happen. If everything goes fine, when you click the "Play" button, you should see the demo page, which contains a canvas and two buttons:

![](/images/game-start-v4.png)

#### About the Sample Page

The page itself does nothing interesting now. It will even navigate you to an unexisting page when clicking the "Close Page" button.

Notice that there is a text saying "Call startGame() to begin". Yes, it is the key! If you take a look at the source code of that page in a desktop browser, you will see there is a `startGame` JavaScript function. When called, it will start this web page game.

::: details The web page code

The page is no more than an HTML with some script. `startGame()` is one of the function defined in the page.

```html {22-24}
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      canvas {
        border: 1px solid #d3d3d3;
        background-color: #f1f1f1;
      }

      button {
        width: 150pt;
        height: 40pt;
      }
    </style>
  </head>

  <body onload="prepareGame()" data-gr-c-s-loaded="true">
    <canvas width="480" height="270"></canvas>
    <script>
      // ...

      function startGame() {
        this.interval = setInterval(updateGameArea, 20);
      }

      //...
    </script>
    <br />
    <button
      onmousedown="accelerate(-0.2)"
      ontouchstart="accelerate(-0.2)"
      onmouseup="accelerate(0.05)"
      ontouchend="accelerate(0.05)"
    >
      ACCELERATE
    </button>
    <a href="uniwebview://close">
      <button>Close Page</button>
    </a>
    <p>Use the ACCELERATE button to stay in the air</p>
    <p>How long can you stay alive?</p>
  </body>
</html>
```

:::

Our next task is calling the `startGame` function on the page when it is prepared. The JavaScript on the page won't be available until the page is fully loaded. To do that, we need to first know some loading events of the web view.

### Listening to the Event

Calling a JavaScript function just below the `webView.Show();` line does not get the job done. It probably gives you an error, due to the page is still loading and the function does not yet exist on the page. You need to wait for a while before the function gets available.

UniWebView has a powerful event system to let you know what happens to the web view. You can know when the page loading successfully finished or failed with an error; Or when the screen orientation is changed so you have a chance to adjust the web view size.

Here, we need to inspect the loading finished event. When `OnPageFinished` event happens, we ensure that the page is fully loaded and the `startGame` function is ready.

Continue to add more code below the final line of `Start`:

```csharp {8-10}
void Start ()
{

    //...

    webView.Show();

    webView.OnPageFinished += (view, statusCode, url) => {
        // Page load finished
    };
}
```

We add an action handler to this event by `+=` a block. Whenever the page is loaded, the code in this block will be executed.

> If you are not familiar with `Action` or `Delegate` in C#, [this documentation](https://msdn.microsoft.com/en-us/library/018hxwa8.aspx) of .NET Framework contains more detail explanation on the syntax.

#### Some Cleaning Work

Before continue to start the game, let's take a look at another important event in UniWebView first.

`OnShouldClose` is an event sent to you when the web view is about to close. The users can use the "Done" button on the toolbar to close the web view. When the web view closed, the `UniWebView` component will be destroyed automatically to keep things clean. But if you are holding the web view in a reference yourself (e.g. here we hold the web view by `webView` property), UniWebView has no way to help you clean it. You have to set it back to `null` yourself, otherwise, the property will be in an invalid state.

To do that, listen to the `OnShouldClose` event and reset `webView` at the end of `Start` method:

```csharp {6-9}
void Start ()
{

    //...

    webView.OnShouldClose += (view) => {
        webView = null;
        return true;
    };
}
```

:::tip
If you are not holding the web view component with a reference, or you are sure you won't use the reference after the web view closed, the `OnShouldClose` is not necessary.
:::

### Unity to Web View - Calling JavaScript

Let's go back to start the game! Invoking a JavaScript function in UniWebView is easy. Call `EvaluateJavaScript` inside the `OnPageFinished` action body:

```csharp {6-12}
void Start ()
{
    //...

    webView.OnPageFinished += (view, statusCode, url) => {
        webView.EvaluateJavaScript("startGame();", (payload)=>{
            if (payload.resultCode.Equals("0")) {
                Debug.Log("Game Started!");
            } else {
                Debug.Log("Something goes wrong: " + payload.data);
            }
        });
    };

    //...
}
```

You pass the JavaScript you want to execute to `EvaluateJavaScript`. Here we run `startGame();`. The second parameter is an `Action` with `UniWebViewNativeResultPayload` as its input. It represents the JavaScript result: the value `"0"` in `payload.resultCode` means that the JavaScript is executed without any error.

Now, run the scene again, the web view should start after page loading finishes. Still remember [Flappy Bird](https://en.wikipedia.org/wiki/Flappy_Bird)? It's time to play!

![](/images/playing-game-v4.png)

### Web View to Unity - Messaging System

When you, unfortunately, run into an obstacle, the game will be stopped. That is not what we expect: we should be able to restart the challenge. It requires a way to detect when the game is over. With the help of the Messaging System of UniWebView, we are able to send a message from web view through a specified URL scheme. Let's try it.

UniWebView by default is **inspecting any URL starting with `uniwebview://` scheme**. When this kind of URL received, it sends a message to Unity instead of loading it in the web view.

If you take a look the HTML source, you can find this code below which will be executed when the game end, which loads a `uniwebview://` URL:

```javascript
window.location.href = "uniwebview://game-over?score=" + myGameArea.frameNo;
```

In UniWebView, an `OnMessageReceived` event will be raised when this URL is loaded. Add this code at the end of `Start()`:

```csharp{5-12}
void Start ()
{
    //...

    webView.OnMessageReceived += (view, message) => {
        if (message.Path.Equals("game-over")) {
            var score = message.Args["score"];
            Debug.Log("Your final score is: " + score);

            // Restart the game
        }
    };
}
```

The action handler receives a `message`, which is a result by parsing the URL. Here we check its path to see whether it is `game-over`. All parameters in the original link are set to `Args`. We get back the final score by accessing the `"score"` key and then print it to the console.

Finally, let's restart the game. The easiest way is reloading the whole page. Just call `Reload` on the web view. Add a `Restart` method and invoke it with a delay:

```csharp{1-6,17-18}
void Restart()
{
    if (webView != null) {
        webView.Reload();
    }
}

void Start ()
{
    //...

    webView.OnMessageReceived += (view, message) => {
        if (message.Path.Equals("game-over")) {
            var score = message.Args["score"];
            Debug.Log("Your final score is: " + score);

            // Restart the game after 3 second
            Invoke("Restart", 3.0f);
        }
    };
}
```

Play the game again. The game will restart when you hit an obstacle.

::: tip Navigating to URL
In the example above, we used a JavaScript `window.location.href` to navigate the page to `uniwebview://` link. Besides of using the JavaScript, a normal HTML link like `<a href="uniwebview://...">` also works. You will see an example in the ["Close the web view" practice below](#close-the-web-view).
:::

### Practice

Let's do some practice to help you understand the whole thing better!

#### Score to Star

Instead of displaying the score as a point, a normal choice is showing how many stars the player gets for easier understanding. For example, below 1000 points gives 1 star, 10001~2000 gives 2 stars, etc. There is already a function to convert an input point to star count on the web page:

```javascript
function getStars(score) {
  // ...
  return starCount;
}
```

Try to call this method to see how many stars you've earned! It should be possible done by an invoking of `EvaluateJavaScript` and getting the `data` of returned payload.

::: details Solution
In the `OnMessageReceived` above, when the game is over and the score is extracted, call `getStars`:

```csharp {10-12}
void Start ()
{
    //...

    webView.OnMessageReceived += (view, message) => {
        if (message.Path.Equals("game-over")) {
            var score = message.Args["score"];
            Debug.Log("Your final score is: " + score);

            webView.EvaluateJavaScript($"getStars({score})", (payload) => {
                Debug.Log("Stars: " + payload.data);
            });

            // Restart the game after 3 second
            Invoke("Restart", 3.0f);
        }
    };
}
```

:::

#### Close the web view

The "Close" button is not functional yet. This button on the page, in fact, is a link to `uniwebview://close`:

```javascript
<a href="uniwebview://close">
  <button>Close Page</button>
</a>
```

Try to add another `if` statement in the `OnMessageReceived` to handle it. To close the web view, call `Destroy(webView);`.

::: details Solution

```csharp{11-14}
void Start()
{
    // ...

    webView.OnMessageReceived += (view, message) => {

        if (message.Path.Equals("game-over")) {
          // ...
        }

        if (message.Path.Equals("close")) {
            Destroy(webView);
            webView = null;
        }
    };
}
```

:::

---

::: tip
If you got any trouble in the practice, you can find the final version of Controller.cs [here](https://gist.github.com/onevcat/9666d61d481843c41d67caf08467def1). However, we strongly suggest you try to implement it yourself first!
:::

### Next Step

Congratulations! You already have the basic ideas and learned the essential parts of the general-purpose UniWebView. Now you are ready to create and use the web view in your project.

If you are still considering using the [Safe Browsing Mode](./safe-browsing.md) to get a simpler solution, check its guide too.

There are much more than what mentioned in this tutorial. We prepared a bunch of resources for you. If you need to know deeper about UniWebView, pick the topics you are interested in **from the "Topics" section in sidebar** and keep reading. Please also read the [API Documentation](/api) to know details about the provided APIs.


---

## API Reference

### IUniWebViewAuthenticationFlow

# IUniWebViewAuthenticationFlow
file: IUniWebViewAuthenticationFlow

summary:

`IUniWebViewAuthenticationFlow<TTokenType>` is an interface for implementing a custom authentication flow. 
An authentication flow, in UniWebView, usually a "code" based OAuth 2.0 flow, contains a standard set of steps:

1. User is navigated to a web page that requires authentication;
2. A temporary code is generated by service provider and provided to client by a redirect URL with customized scheme.
3. Client requests an access token using the temporary code by performing an "access token" exchange request.

To use the common flow, any customize authentication flow must implement this interface and becomes a subclass of
`UniWebViewAuthenticationCommonFlow`.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<TTokenType>
summary: Called when the authentication flow succeeds and a valid token is generated.

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<TTokenType>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.

[[Methods]]
name: GetCallbackUrl
syntax: GetCallbackUrl()
returnType: string
returnValue: The redirect URL set in the OAuth settings.
summary:

Returns the redirect URL that is used to redirect the user after authenticated. This is used as the `redirect_uri`
parameter when navigating user to the authentication page.

Usually this is a URL with customize scheme that later service provider may call. It takes intermediate code in its
query and can be used to open the current app in client. The native side of UniWebView will catch and handle it,
then send it to Unity side as the result of `UniWebViewAuthenticationSession`.

[[Methods]]
name: GetAuthenticationConfiguration
syntax: GetAuthenticationConfiguration()
returnType: UniWebViewAuthenticationConfiguration
returnValue: The config object of an authentication flow.
summary:

Returns the config of the authentication flow. It usually defines the authentication requests entry points.

[[Methods]]
name: GetAuthenticationUriArguments
syntax: GetAuthenticationUriArguments()
returnType: Dictionary<string, string>
returnValue: The dictionary indicates parameters that are used to perform the authentication request.
summary:

Returns a dictionary contains the parameters that are used to perform the authentication request.
The key value pairs in the dictionary are used to construct the query string of the authentication request.

This usually contains fields like `client_id`, `redirect_uri`, `response_type`, etc.

[[Methods]]
name: GetAdditionalAuthenticationUriQuery
syntax: GetAdditionalAuthenticationUriQuery()
returnType: string
returnValue: The additional query arguments that are used to construct the query string of the authentication request.
summary:

Returns a string contains the additional query arguments that are used to construct the query string of the authentication request.

If you want to add some extra query arguments to the authentication request, you can override this method and 
return a string that contains the additional query arguments. The returned string will be appended to the query 
string that constructed from `GetAuthenticationUriArguments`.

[[Methods]]
name: GetAccessTokenRequestParameters
syntax: GetAccessTokenRequestParameters(string authResponse)
returnType: Dictionary<string, string>
returnValue: The dictionary indicates parameters that are used to perform the access token exchange request.
summary:

Returns a dictionary contains the parameters that are used to perform the access token exchange request.
The key value pairs in the dictionary are used to construct the HTTP form body of the access token exchange request.

[[Methods.parameters]]
name: authResponse
type: string
summary:

The response from authentication request. If the authentication succeeds, it is
usually a custom scheme URL with a `code` query as its parameter. Base on this, you could construct the body of the
access token exchange request.

[[Methods]]
name: GetRefreshTokenRequestParameters
syntax: GetRefreshTokenRequestParameters(string refreshToken)
returnType: Dictionary<string, string>
returnValue: he dictionary indicates parameters that are used to perform the access token refresh request.
summary:

Returns a dictionary contains the parameters that are used to perform the access token refresh request.
    /// The key value pairs in the dictionary are used to construct the HTTP form body of the access token refresh request.

[[Methods.parameters]]
name: refreshToken
type: string
summary:

The refresh token you received from a previous access token exchange request. If the access token can be refreshed, the
service provider should provide you a refresh token under the `refresh_token` field of the response body along side with
the access token exchange when you issue the access token.

[[Methods]]
name: GenerateTokenFromExchangeResponse
syntax: GenerateTokenFromExchangeResponse(string exchangeResponse)
returnType: TTokenType
returnValue: A token object with `TToken` type that represents the authenticated result.
summary:

Returns the strong-typed token for the authentication process.
When the token exchange request finishes without problem, the response body will be passed to this method and
any conforming class should construct the token object from the response body.

[[Methods.parameters]]
name: exchangeResponse
type: string
summary:

The body response of the access token exchange request. Usually it contains the desired `access_token` and other
necessary fields to describe the authenticated result.

---

### UniWebViewAuthenticationCommonFlow

# UniWebViewAuthenticationCommonFlow
file: UniWebViewAuthenticationCommonFlow

summary:

Abstract class and general control for other authentication flows. This class determines the global behaviors of the 
authentication flow, such as whether to start authentication as soon as the script `Start`s, and whether to use private
mode to authenticate the user.

This is a super and abstract class for all concrete auth flow. You are not expected to use this class directly.
Instead, to start a customized auth flow, you can use the `UniWebViewAuthenticationFlowCustomize` class.

[[Properties]]
name: authorizeOnStart
returnType: bool
hasSetter: true
summary:

Whether to start authentication as soon as the script `Start`s.

[[Properties]]
name: privateMode
returnType: bool
hasSetter: true
summary:

Whether to use private mode to authenticate the user. If `true` and the device supports, the authentication
will begin under the incognito mode.

On iOS, this works on iOS 13 and later.

On Android, it depends on the Chrome version and might require users to enable the incognito mode (and support
for third-party use) in Chrome's settings. Check settings with `chrome://flags/#cct-incognito` and
`chrome://flags/#cct-incognito-available-to-third-party` in Chrome to see the current status.

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: abstract void
summary:

Subclass should override this method to start the authentication flow. Usually it starts
a `UniWebViewAuthenticationFlow`. But you can also choose whatever you need to do.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: abstract void
summary:

Subclass should override this method to start the authentication flow. Usually it starts
a Unity Web Request against the authentication flow's token entry point to refresh the token.

[[Methods]]
name: GenerateAndStoreState
syntax: GenerateAndStoreState()
returnType: string
summary:

Child classes are expected to call this method to request a `state` (and store it for later check) if the 
`state` verification is enabled.

[[Methods]]
name: GenerateCodeChallengeAndStoreCodeVerify
syntax: GenerateCodeChallengeAndStoreCodeVerify(UniWebViewAuthenticationPKCE method)
returnType: string
summary:

Child classes are expected to call this method to request a `code_challenge`. Later when exchanging the access
token, the `code_verifier` will be used to verify the `code_challenge`. Subclass can read it from `CodeVerify`.

[[Methods]]
name: VerifyState
syntax: VerifyState(VerifyState(Dictionary<string, string> parameters, string key)
returnType: void
summary:

Perform verifying for `state`. Child classes are expected to call this method to verify the `state`.
If the `state` is invalid, the authentication flow will be stopped and an `AuthenticationResponseException.InvalidState`
thrown.

---

### UniWebViewAuthenticationFlowCustomize

# UniWebViewAuthenticationFlowCustomize
file: UniWebViewAuthenticationFlowCustomize

summary:

A customizable authentication flow behavior.

For a guide of using this class, please refer to the [Common Flow](/guide/oauth2.html#common-flow)
section in theOAuth 2.0 Support guide.

Besides of the predefined authentication flows, such as Twitter (`UniWebViewAuthenticationFlowTwitter`) or Google
(`UniWebViewAuthenticationFlowGoogle`), this class allows you to determine the details of the authentication flow,
such as entry points, grant types, scopes and more. But similar to other target-specified flows, it follows the same
OAuth 2.0 code auth pattern.

If you need to support other authentication flows for the platform targets other than the predefined ones, you can
use this class and set all necessary parameters. It conforms to the `IUniWebViewAuthenticationFlow` and runs the 
standard OAuth 2.0 flow and gives out a `UniWebViewAuthenticationStandardToken` as the result.

If you need to support authentication flows other than `code` based OAuth 2.0, try to derive from
`UniWebViewAuthenticationCommonFlow` and implement `IUniWebViewAuthenticationFlow` interface, or even use the underneath
`UniWebViewAuthenticationSession` to get a highly customizable flow.

It inherits from `UniWebViewAuthenticationCommonFlow`, which is in turn a `MonoBehaviour` and can be attached to a Game 
Object. The usual way to use this class is attaching it to an existing Game Object in the scene and setup it in the inspector.

[[Properties]]
name: config
returnType: UniWebViewAuthenticationFlowCustomizeConfig
hasSetter: true
summary:

The config object which defines the basic information of the authentication flow.

It contains basic information of an OAuth 2.0 service provider, including the `authorizationEndpoint`, `tokenEndpoint`
and `responseType`, etc.

Although you can set the values for a `config` instance by code, a more common way is attaching this
script to a Game Object and setup it in the Unity inspector UI.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client Id of your OAuth application.

Usually, when you create an application on the provider platform, you will get a client Id to identify your application
on the platform. It is used as the "Client Identifier" in OAuth 2.0 specification.

[[Properties]]
name: redirectUri
returnType: string
hasSetter: true
summary:

The redirect URI of your OAuth application. The service provider is expected to call this URI to pass back the
authorization code. It should be something also set to your OAuth application.

Also remember to add it to the "Auth Callback Urls" field in UniWebView's preference panel. 

It is used as the "Redirection Endpoint"  in OAuth 2.0 specification.

[[Properties]]
name: scopes
returnType: string
hasSetter: true
summary:

The scope of the authentication request.

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowCustomizeOptional
hasSetter: true
summary:

The optional object which defines some optional parameters of the authentication flow, such as whether supports
`state` or `PKCE`.

Although you can set values for an `optional` instance by code, a more common way is attaching this
script to a Game Object and setup it in the Unity inspector UI.

example:

```csharp
public UniWebViewAuthenticationFlowCustomize customize;

customize.optional.enableState = true;
customize.optional.PKCESupport = UniWebViewAuthenticationPKCE.S256;

customize.StartAuthenticationFlow();
```

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationStandardToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
flow.OnAuthenticationFinished.AddListener(OnTokenReceived)

void OnTokenReceived(UniWebViewAuthenticationStandardToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
flow.OnAuthenticationErrored.AddListener(OnAuthError);

void OnAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationStandardToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
flow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationStandardToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
flow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowDiscord

# UniWebViewAuthenticationFlowDiscord
file: UniWebViewAuthenticationFlowDiscord

summary:

A predefined authentication flow for Discord.

This implementation follows the flow described [here](https://discord.com/developers/docs/topics/oauth2).

See the [OAuth 2.0 Support](/guide/oauth2.html) for a more detailed guide of authentication in UniWebView.

To allow the Discord flow working, at least you need these steps:

1. Setting `Client Id`, `Client Secret` and `Redirect Uri` in the `UniWebViewAuthenticationFlowDiscord` inspector.
2. Setting `scope` and at least contains `identify` in the `UniWebViewAuthenticationFlowDiscord` inspector.
3. Setting the `Auth Callbacks Urls` containing `Redirect Uri` in `UniWebView` preference panel.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client ID of your Discord application.

[[Properties]]
name: clientSecret
returnType: string
hasSetter: true
summary:

The client secret of your Discord application.

notice:

Setting this value may leak the client secret and cause security issue. Prefer to setting the PKCESupport to `S256` in 
the option instead. With the correct PKCE setup, you do not need to set the client secret here.

[[Properties]]
name: redirectUri
returnType: string
hasSetter: true
summary:

The redirect URI of this Discord application.

[[Properties]]
name: scope
returnType: string
hasSetter: true
summary:

The scope string of all your required scopes.

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowDiscordOptional
hasSetter: true
summary:

Optional to control this flow's behaviour.

[[Properties]]
name: optional.PKCESupport
returnType: UniWebViewAuthenticationPKCE
hasSetter: true
summary:

Whether to enable PKCE when performing authentication. On mobile platforms, this has to be enabled as `S256`,
otherwise, Discord will reject the authentication request.

[[Properties]]
name: optional.enableState
returnType: bool
hasSetter: true
summary:

Whether to enable the state verification. If enabled, the state will be generated and verified in the
authentication callback. Default is `true`.

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationDiscordToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
discordFlow.OnAuthenticationFinished.AddListener(OnDiscordTokenReceived)

void OnDiscordTokenReceived(UniWebViewAuthenticationDiscordToken token) {
  Debug.Log("Discord Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
discordFlow.OnAuthenticationErrored.AddListener(OnDiscordAuthError);

void OnDiscordAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationDiscordToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
discordFlow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationDiscordToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
discordFlow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowFacebook

# UniWebViewAuthenticationFlowFacebook
file: UniWebViewAuthenticationFlowFacebook

summary:

A predefined authentication flow for Facebook Login.

It is not a standard OAuth2 flow, and using a plain web view. There once was a policy that Facebook did not allow
any third-party customize authentication flow other than using their official SDK. Recently Facebook started to provide
a so-called manual flow way to perform authentication. But it is originally only for Desktop apps, it is not stable
and not standard.

Facebook suggests "For mobile apps, use the Facebook SDKs for iOS and Android, and follow the separate guides for
these platforms." So on mobile, use this class with your own risk since it might be invalidated or forbidden by
Facebook in the future.

This implementation is based on the manual flow described in [this documentation](https://developers.facebook.com/docs/facebook-login/guides/advanced/manual-flow).

See the [OAuth 2.0 Support](/guide/oauth2.html) for a more detailed guide of authentication in UniWebView.

To allow the Facebook flow working, at least you need to set the `App Id` in the `UniWebViewAuthenticationFlowFacebook` inspector.

[[Properties]]
name: appId
returnType: string
hasSetter: true
summary: The App ID of your Facebook application.

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowFacebookOptional
hasSetter: true
summary: Optional to control this flow's behaviour.

[[Properties]]
name: optional.scope
returnType: string
hasSetter: true
summary: The scope string of all your required scopes.

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationFacebookToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
facebookFlow.OnAuthenticationFinished.AddListener(OnFacebookTokenReceived)

void OnFacebookTokenReceived(UniWebViewAuthenticationFacebookToken token) {
  Debug.Log("Facebook Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
facebookFlow.OnAuthenticationErrored.AddListener(OnFacebookAuthError);

void OnFacebookAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowGitHub

# UniWebViewAuthenticationFlowGitHub
file: UniWebViewAuthenticationFlowGitHub

summary:

A predefined authentication flow for GitHub.

This implementation follows the flow described [here](https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps).

See the [OAuth 2.0 Support](/guide/oauth2.html) and [OAuth 2.0 with GitHub](/guide/oauth2-github.html) for a more detailed guide of authentication in UniWebView.

To allow the GitHub flow working, at least you need these steps: 

1. Setting `Client Id`, `Client Secret`, `Callback Url` in the `UniWebViewAuthenticationFlowGitHub` inspector.
2. Setting the `Auth Callbacks Urls` containing the `Callback Url` in the `UniWebView` preference panel.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client ID of your GitHub application.

example:

At the day of writing, the client Id from GitHub is something like:

```csharp
githubFlow.clientId = "lv1.1234567890abcdef1234";
```

[[Properties]]
name: clientSecret
returnType: string
hasSetter: true
summary:

The client secret of your GitHub application.

notice:

Strictly speaking, the client secret **should not be stored** on the client side. In the OAuth flow of a native app, we 
should use [PKCE](https://oauth.net/2/pkce/) whenever possible to protect the authorization process (UniWebView 
[supports PKCE](/api/UniWebViewAuthenticationFlowCustomize.html#optional)). However, GitHub’s OAuth does not currently 
support PKCE, so we still have to use the client secret when exchanging tokens if we do not have a backend.

A more secure approach would be to set up your own backend server and use server-to-server communication to obtain the 
access token. In UniWebView, you can use the [Customize Flow](/guide/oauth2.html#customize-flow) to set the entry point 
for access token exchange to your server, thereby avoiding exposing the client secret in the client-side code.

[[Properties]]
name: callbackUrl
returnType: string
hasSetter: true
summary:

The callback URL of your GitHub application.

example:

```csharp
githubFlow.callbackUrl = "authhub://auth";
```

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowGitHubOptional
hasSetter: true
summary:

Optional to control this flow's behaviour.

[[Properties]]
name: optional.redirectUri
returnType: string
hasSetter: true
summary:

The redirect URI should be used in exchange token request.

[[Properties]]
name: optional.login
returnType: string
hasSetter: true
summary:

Suggests a specific account to use for signing in and authorizing the app.

[[Properties]]
name: optional.scope
returnType: string
hasSetter: true
summary:

The scope string of all your required scopes.

[[Properties]]
name: optional.enableState
returnType: bool
hasSetter: true
summary:

Whether to enable the state verification. If enabled, the state will be generated and verified in the
authentication callback.

Default is `false`.

[[Properties]]
name: optional.allowSignup
returnType: bool
hasSetter: true
summary:

Whether or not unauthenticated users will be offered an option to sign up for GitHub during the OAuth flow.

Default is `true`.

[[Properties]]
name: optional.prompt
returnType: string
hasSetter: true
summary:

The prompt that will be set to the authentication request query. For example, the possible values can be `login`, 
`consent`, `select_account` and so on.

See https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationGitHubToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
githubFlow.OnAuthenticationFinished.AddListener(OnGitHubTokenReceived)

void OnGitHubTokenReceived(UniWebViewAuthenticationGitHubToken token) {
  Debug.Log("Github Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
github.OnAuthenticationErrored.AddListener(OnGitHubAuthError);

void OnGitHubAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationGitHubToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
githubFlow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationGitHubToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
githubFlow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowGoogle

# UniWebViewAuthenticationFlowGoogle
file: UniWebViewAuthenticationFlowGoogle

summary:

A predefined authentication flow for Google Identity.

This implementation follows the flow described [here](https://developers.google.com/identity/protocols/oauth2/native-app).

Google authentication flow is a bit different from the other standard authentication flows. Please read the link
above carefully to understand it.

See the [OAuth 2.0 Support - General](/guide/oauth2.html) and [OAuth 2.0 with Google](/guide/oauth2-google.html) for a 
more detailed guide of authentication in UniWebView.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client ID of your Google application.

example:

At the day of writing, the client Id from Google is something like:

```csharp
googleFlow.clientId = "1234567890-abcdefgh.apps.googleusercontent.com";
```

[[Properties]]
name: redirectUri
returnType: string
hasSetter: true
summary:

The redirect URI of your Google application.

It might be something like "com.googleusercontent.apps.${clientId}:/${redirect_uri_path}". Be caution that the URI does not
contain regular double slashes `//`, but should be only one.

example:

```csharp
googleFlow.redirectUri = "com.googleusercontent.apps.1234567890-abcdefgh:/auth";
```

[[Properties]]
name: scope
returnType: string
hasSetter: true
summary:

The scope of your Google application.

It might be some full URL in recent Google services, such as `"https://www.googleapis.com/auth/userinfo.profile"`

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowGoogleOptional
hasSetter: true
summary:

Optional to control this flow's behaviour.

[[Properties]]
name: optional.PKCESupport
returnType: UniWebViewAuthenticationPKCE
hasSetter: true
summary:

Whether to enable PKCE when performing authentication. Default is `S256`.

[[Properties]]
name: optional.enableState
returnType: bool
hasSetter: true
summary:

Whether to enable the state verification. If enabled, the state will be generated and verified in the
authentication callback. 

Default is `true`.

[[Properties]]
name: optional.loginHint
returnType: string
hasSetter: true
summary:

If your application knows which user is trying to authenticate, it can use this parameter to provide a hint to
the Google Authentication Server. 

[[Properties]]
name: optional.prompt
returnType: string
hasSetter: true
summary:

The prompt that will be set to the authentication request query. For example, the possible values can be `login`, 
`consent`, `select_account` and so on.

See https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationGoogleToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
googleFlow.OnAuthenticationFinished.AddListener(OnGoogleTokenReceived)

void OnGoogleTokenReceived(UniWebViewAuthenticationGoogleToken token) {
  Debug.Log("Google Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
googleFlow.OnAuthenticationErrored.AddListener(OnGoogleAuthError);

void OnGoogleAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationGoogleToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
googleFlow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationGoogleToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
googleFlow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowLine

# UniWebViewAuthenticationFlowLine
file: UniWebViewAuthenticationFlowLine

summary:

A predefined authentication flow for LINE.

This implementation follows the flow described [here](https://developers.line.biz/en/reference/line-login/).

LINE authentication flow is a bit different from the other standard authentication flows. Please read the link
above carefully to understand it.

See the [OAuth 2.0 Support](/guide/oauth2.html) for a more detailed guide of authentication in UniWebView.

To allow the Google flow working, at least you need these steps:

1. Setting `Client Id` (Channel Id), `iOS Bundle Id` and `Android Package Name` in the `UniWebViewAuthenticationFlowLine` inspector.
2. Setting `Scope` and at least contains `profile` in the `UniWebViewAuthenticationFlowLine` inspector.
3. Check the "Support LINE Login" option in the `UniWebView` preference panel.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client ID (Channel ID) of your LINE Login application.

[[Properties]]
name: iOSBundleId
returnType: string
hasSetter: true
summary:

The iOS bundle Id you set in LINE developer console.

[[Properties]]
name: androidPackageName
returnType: string
hasSetter: true
summary:

The Android package name you set in LINE developer console.

[[Properties]]
name: scope
returnType: string
hasSetter: true
summary:

The scope of your LINE application.

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowLineOptional
hasSetter: true
summary:

Optional to control this flow's behaviour.

[[Properties]]
name: optional.PKCESupport
returnType: UniWebViewAuthenticationPKCE
hasSetter: true
summary:

Whether to enable PKCE when performing authentication. Default is `S256`.

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationLineToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
lineFlow.OnAuthenticationFinished.AddListener(OnLineTokenReceived)

void OnLineTokenReceived(UniWebViewAuthenticationLineToken token) {
  Debug.Log("Line Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
lineFlow.OnAuthenticationErrored.AddListener(OnLineAuthError);

void OnLineAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationLineToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
lineFlow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationLineToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
lineFlow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationFlowTwitter

# UniWebViewAuthenticationFlowTwitter
file: UniWebViewAuthenticationFlowTwitter

summary:

A predefined authentication flow for Twitter.

This implementation follows the flow described [here](https://developer.twitter.com/en/docs/authentication/oauth-2-0/authorization-code).

See the [OAuth 2.0 Support](/guide/oauth2.html) for a more detailed guide of authentication in UniWebView.

To allow the Twitter flow working, at least you need these steps:

1. Setting `Client Id`, `Redirect Uri` in the `UniWebViewAuthenticationFlowTwitter` inspector.
2. Setting `Scope` and at least contains `users.read` in the `UniWebViewAuthenticationFlowTwitter` inspector.
3. Setting the `Auth Callbacks Urls` to contain the Redirect Uri in the `UniWebView` preference panel.

[[Properties]]
name: clientId
returnType: string
hasSetter: true
summary:

The client ID of your Twitter application.

[[Properties]]
name: redirectUri
returnType: string
hasSetter: true
summary:

The redirect URI of your Twitter application.

[[Properties]]
name: scope
returnType: string
hasSetter: true
summary:

The scope string of all your required scopes.

[[Properties]]
name: optional
returnType: UniWebViewAuthenticationFlowTwitterOptional
hasSetter: true
summary:

Optional to control this flow's behaviour.

[[Properties]]
name: optional.PKCESupport
returnType: UniWebViewAuthenticationPKCE
hasSetter: true
summary:

Whether to enable PKCE when performing authentication.This has to be enabled as `S256`,
otherwise, Twitter will reject the authentication request.

[[Properties]]
name: optional.enableState
returnType: bool
hasSetter: true
summary:

Whether to enable the state verification. If enabled, the state will be generated and verified in the
authentication callback. This has to be `true`, otherwise, Twitter will reject the authentication request.

[[Properties]]
name: optional.additionalAuthenticationUriQuery
returnType: string
hasSetter: true
summary:

The additional query arguments that are used to construct the query string of the authentication request.

This is useful when you want to add some custom parameters to the authentication request. This string will be 
appended to the query string that constructed from `GetAuthenticationUriArguments`. 

For example, if you set the value to `prompt=consent&ui_locales=en`, it will be contained in the final authentication 
query.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished
returnType: UnityEvent<UniWebViewAuthenticationTwitterToken>
summary: Called when the authentication flow succeeds and a valid token is generated.
example:

```csharp
twitterFlow.OnAuthenticationFinished.AddListener(OnTwitterTokenReceived)

void OnTwitterTokenReceived(UniWebViewAuthenticationTwitterToken token) {
  Debug.Log("Twitter Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnAuthenticationErrored
syntax: OnAuthenticationErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
twitterFlow.OnAuthenticationErrored.AddListener(OnTwitterAuthError);

void OnTwitterAuthError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Events]]
name: OnRefreshTokenFinished
syntax: OnRefreshTokenFinished
returnType: UnityEvent<UniWebViewAuthenticationTwitterToken>
summary: Called when the access token refresh request finishes and a valid refreshed token is generated.
example:

```csharp
twitterFlow.OnRefreshTokenFinished.AddListener(OnRefreshTokenReceived)

void OnRefreshTokenReceived(UniWebViewAuthenticationTwitterToken token) {
  Debug.Log("Access Token: " + token.AccessToken);
}
```

[[Events]]
name: OnRefreshTokenErrored
syntax: OnRefreshTokenErrored
returnType: UnityEvent<long, string>
summary: Called when any error (including user cancellation) happens during the authentication flow.
example:

```csharp
twitterFlow.OnRefreshTokenErrored.AddListener(OnRefreshTokenError);

void OnRefreshTokenError(long error, string message) {
  Debug.Log("Error code: " + error + " Message: " + message);
}
```

[[Methods]]
name: StartAuthenticationFlow
syntax: StartAuthenticationFlow()
returnType: void
summary:

Starts the authentication flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

[[Methods]]
name: StartRefreshTokenFlow
syntax: StartRefreshTokenFlow(string refreshToken)
returnType: void
summary:

Starts the refresh flow with the standard OAuth 2.0.
This implements the abstract method in `UniWebViewAuthenticationCommonFlow`.

---

### UniWebViewAuthenticationSession

# UniWebViewAuthenticationSession
file: UniWebViewAuthenticationSession

summary:

Represents a session that can be used to authenticate a user through a web service.

Initialize the session with a URL that points to the authentication webpage. A browser or a secure web view loads
and displays the page. On completion, the service sends a callback URL to the session with an authentication token,
and this triggers the `OnAuthenticationFinished` with the received URL. To make your app be invoked by the system,
you need to also add the correct callback URL starting with the value of `CallbackScheme` to UniWebView's preferences.

Usually this session processes an OAuth 2 flow. It will be used along with a following "exchange token" request, to
finally get the user's access token to allow you use the service APIs on behalf of the user. This token exchange can
happen in the client app, or you can pass the code to your server and let your server do the left work.

UniWebView also provides built-in integrated authentication flows for several popular service. The the
`UniWebViewAuthenticationFlow` cluster classes to use them and simplify your work. If the built-in models do not
fit your work, you can use this class as a starting point of your own authentication integration. 

See the [OAuth 2.0 Support](/guide/oauth2.html) for a more detailed guide of authentication in UniWebView.

[[Events]]
name: OnAuthenticationFinished
syntax: OnAuthenticationFinished(UniWebViewAuthenticationSession session, string url)
returnType: void
summary:

Raised when the session finishes authentication.

This event will be invoked when the service provider calls the callback URL. regardless of the authentication code
is retrieved or an error is returned in the callback URL.

[[Events.parameters]]
name: session
type: UniWebViewAuthenticationSession
summary: The session which raised this event.
[[Events.parameters]]
name: url
type: string
summary: The received URL from service. It might contain a valid `code` from the service, or an error.

[[Events]]
name: OnAuthenticationErrorReceived
syntax: OnAuthenticationErrorReceived(UniWebViewAuthenticationSession session, int errorCode, string errorMessage)
returnType: void
summary:

Raised when the session encounters an error.

This event will be invoked when the authentication session cannot finishes with a URL callback. This usually
happens when a network error or the user dismisses the authentication page from native UI.

[[Events.parameters]]
name: session
type: UniWebViewAuthenticationSession
summary: The session which raised this event.
[[Events.parameters]]
name: errorCode
type: int
summary: The error code represents the error type.
[[Events.parameters]]
name: errorMessage
type: string
summary: The error message describes the error in detail.

[[Properties]]
name: IsAuthenticationSupported
returnType: bool
hasSetter: false
summary:

Check whether the current device and system supports the authentication session.

Returns `true` if the safe browsing mode is supported and the page will be opened in safe browsing 
mode. Otherwise, `false`.

This property always returns `true` on iOS 11, macOS 10.15 and later. On Android, it depends on whether there
is an Intent can handle the safe browsing request,  which is use to display the authentication page. Usually
it is provided by Chrome. If there is no Intent can open the URL in safe browsing mode, this property will
return `false`.

To use this API on Android when you set your Target SDK to Android 11 or later, you need to declare the correct 
intent query explicitly in your AndroidManifest.xml, to follow the [Package Visibility](https://developer.android.com/about/versions/11/privacy/package-visibility):

example:

```csharp
<queries>
  <intent>
    <action android:name="android.support.customtabs.action.CustomTabsService" />
  </intent>
</queries>

// To use it:
if (UniWebViewAuthenticationSession.IsAuthenticationSupported) {
    // Continue to create and start the authentication session.
}
```

[[Properties.badges]]
name: static
color: blue

[[Properties]]
name: Url
returnType: string
hasSetter: false
summary: The URL of the authentication webpage. This is the value you used to create this session.

[[Properties]]
name: CallbackScheme
returnType: string
hasSetter: false
summary:

The callback scheme of the authentication webpage. This is the value you used to create this session. The service
is expected to use a URL with this scheme to return to your app.

[[Methods]]
name: Create
syntax: Create(string url, string callbackScheme)
returnType: UniWebViewAuthenticationSession
summary:

Creates a new authentication session with a given authentication page URL and a callback scheme.

example:

```csharp
// For example: 
// - Auth entrypoint: "example.com/oauth/authorize"
// - Callback Url: "authExample://auth"
var session = UniWebViewAuthenticationSession.Create(
  "https://example.com/oauth/authorize?client_id=12345&&scope=profile",
  "authExample"
);
// Use the `session` to start the authentication flow.
```

[[Methods.parameters]]
name: url
type: string
summary:

The authentication page which is provided by the service. It should be a URL with some information like your app's
client id and required scopes, etc.

[[Methods.parameters]]
name: callbackScheme
type: string
summary:

The URL scheme which the service will use to navigate back to your client app.

[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: Start
syntax: Start()
returnType: void
summary:

Start the authentication session process. It will show up a secured web page and navigate users to the `Url`.

example:

```csharp

var session = UniWebViewAuthenticationSession.Create(
  "https://example.com/oauth/authorize?client_id=12345&&scope=profile",
  "authExample"
);
session.OnAuthenticationFinished += (_, resultUrl) =>  {
  Debug.Log("Auth flow received callback url: " + resultUrl);
  // Continue to exchange the code to the access token.
};

session.OnAuthenticationErrorReceived += (_, errorCode, message) => {
  // Error handling.
};

session.Start();
```

[[Methods]]
name: SetPrivateMode
syntax: SetPrivateMode(bool flag)
returnType: void
summary:

Sets to use the private mode for the authentication. 

If running under private mode, the previous stored authentication information will not be used.

On Apple's platform, this works from iOS 13 and macOS 10.15. On Android, this depends on the Chrome setting on the
device. The users should enable the "incognito" and "third-party incognito" to allow to use this feature.

Check them in Chrome app:
-  chrome://flags/#cct-incognito
-  chrome://flags/#cct-incognito-available-to-third-party

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the session should run in private mode or not.

---

### UniWebViewAuthenticationStandardToken

# UniWebViewAuthenticationStandardToken
file: UniWebViewAuthenticationStandardToken

summary:

Represents the standard token used in the OAuth 2 process.

Most of the built-in authentication flows in UniWebView are using the same model of this standard token.
It contains the information of the access token, the refresh token, the expiration time and the token type.
When received a token from the server, UniWebView tries to parse it into this standard token and then pass it to the 
`OnAuthenticationFinished` event.

[[Properties]]
name: AccessToken
returnType: string
summary:

The access token retrieved from the service provider.

This usually comes from the `access_token` field in the response.
Use this token to access the service provider's API.

If you do not need the token "offline", just use it and discard. UniWebView will not store this token, if you
need to keep it for other purpose, please make sure you do not violate any policies and put it to a secure
place yourself.

[[Properties]]
name: Scope
returnType: string
summary:

The granted scopes of the token. This is usually comes from the `scope` field in the response.

If there are optional scopes in the initial auth request, the user can choose to not give you some of the
permissions. Check this field before you use the access token to perform certain actions to avoid failure
before actual attempts.

[[Properties]]
name: TokenType
returnType: string
summary:

The token type. This usually comes from the `token_type` field in the response.

For most OAuth 2.0 services, it is fixed to `Bearer`.

[[Properties]]
name: RefreshToken
returnType: string
summary:

The refresh token retrieved from the service provider. This usually comes from the `refresh_token` field in the
response.

If the access token is refreshable, you can use this
refresh token to perform a refresh operation and get a new access token without the user's consent again.

The refresh policy can be different from the service providers. Read the documentation of the service provider
to determine the use of refresh token.

If the response does not contain a refresh token, this field will be `null`.

[[Properties]]
name: ExpiresIn
returnType: long
summary:

How long does this token remain valid. This usually comes from the `expires_in` field in the response.

[[Properties]]
name: IdToken
returnType: string
summary:

The ID token retrieved from the service provider. This usually comes from the `id_token` field in the response.

If the service provider does not support ID token or you did not apply for it, this field will be `null`.
The ID token is usually a JWT token that contains information about the user.

[[Properties]]
name: RawValue
returnType: string
summary:

The raw value of the response of the exchange token request.

If the predefined fields are not enough, you can parse the raw value to get the extra information.

---

### UniWebViewAuthenticationUtils

# UniWebViewAuthenticationUtils
file: UniWebViewAuthenticationUtils

summary:

This class provides some helper utils for performing the authentication flow.

They are used inside the built-in flows, but you can also use them to implement your own flow.

[[Methods]]
name: GenerateRandomBase64String
syntax: GenerateRandomBase64String()
returnType: string
returnValue: A random Base64 encoded string.
summary: Generates a random Base64 encoded string.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: GenerateRandomBase64URLString
syntax: GenerateRandomBase64URLString()
returnType: string
returnValue: A random Base64URL encoded string.
summary: Generates a random Base64URL encoded string.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: ConvertToBase64URLString
syntax: ConvertToBase64URLString(string input)
returnType: string
returnValue: A string with Base64URL encoded for the input.
summary: Converts a Base64 encoded string to a Base64URL encoded string.
[[Methods.parameters]]
name: input
type: string
summary: The Base64 encoded string.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: ConvertToBase64String
syntax: ConvertToBase64String(string input)
returnType: string
returnValue: A string with Base64 encoded for the input.
summary: Converts a Base64URL encoded string to a Base64 encoded string.
[[Methods.parameters]]
name: input
type: string
summary: The Base64URL encoded string.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: GenerateCodeVerifier
syntax: GenerateCodeVerifier(int length)
returnType: string
returnValue: A generated code verifier for PKCE usage.
summary: Generates a code verifier for PKCE usage.
[[Methods.parameters]]
name: length
type: int
summary: The length of the target code verifier. Default is 64.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: CalculateCodeChallenge
syntax: CalculateCodeChallenge(string codeVerifier, UniWebViewAuthenticationPKCE method)
returnType: string
returnValue: The result of the code challenge.
summary: Calculates the code challenge for PKCE usage, with a given code verifier and hash method.
[[Methods.parameters]]
name: codeVerifier
type: string
summary: The code verifier you generated.
[[Methods.parameters]]
name: method
type: UniWebViewAuthenticationPKCE
summary: The hash method you want to use.
[[Methods.badges]]
name: static
color: blue

---

### UniWebViewBackForwardItem

# UniWebViewBackForwardItem
file: UniWebViewBackForwardItem

summary:

Represents an item in the back-forward navigation list of a UniWebView browser.
This class stores information about a single entry in the browsing history.

You do not create an instance of this class directly. Instead, you get instances of this class from the
`UniWebViewBackForwardList` class.

[[Properties]]
name: Url
returnType: string
hasSetter: false
summary: Gets the current URL of the history item.

[[Properties]]
name: Title
returnType: string
hasSetter: false
summary:

Gets the title of the webpage represented by this history item.

Empty if the title is not available or set.

[[Properties]]
name: OriginalUrl
returnType: string
hasSetter: false
summary: Gets the original URL before any redirects occurred, if any.

---

### UniWebViewBackForwardList

# UniWebViewBackForwardList
file: UniWebViewBackForwardList

summary:

Represents the back-forward navigation history list of a UniWebView instance.
This class manages the browsing history and provides access to previous and next pages.

You do not create an instance of this class directly. Instead, you get an instance of this class to represent the
back-forward list of a UniWebView instance by calling the `CopyBackForwardList` method of the `UniWebView` class.

The content of this class is read-only and fixed when the instance is created. It does not get updated with the
web view's navigation history automatically. If you need the latest navigation history, you should call the method
`CopyBackForwardList` again to get a new instance of this class.

[[Properties]]
name: AllItems
returnType: List<UniWebViewBackForwardItem>
hasSetter: false
summary: Gets all items in the back-forward navigation history list.

[[Properties]]
name: CurrentItem
returnType: UniWebViewBackForwardItem
hasSetter: false
summary:

Gets the current page item in the navigation history.

It is the page that is currently displayed in the list. If there is no item in the list, it will return null.

[[Properties]]
name: BackItem
returnType: UniWebViewBackForwardItem
hasSetter: false
summary:

Gets the previous (back) page item in the navigation history.

Returns null if there is no previous page.

[[Properties]]
name: ForwardItem
returnType: UniWebViewBackForwardItem
hasSetter: false
summary:

Gets the next (forward) page item in the navigation history.

Returns null if there is no next page.

[[Properties]]
name: CurrentIndex
returnType: int
hasSetter: false
summary:

Gets the index of current page in the navigation history.

The index is zero-based in the list. If there is no item in the list, it will return -1.

[[Properties]]
name: Size
returnType: int
hasSetter: false
summary: Gets the total number of items in the navigation history.

[[Methods]]
name: ItemAtIndex
syntax: ItemAtIndex(int index)
returnType: UniWebViewBackForwardItem
returnValue: The navigation item at the specified index, or null if the index is out of range.
summary:

Gets the item at the specified index in the navigation history.

[[Methods.Parameters]]
name: index
type: int
summary: The zero-based index of the item to retrieve.

---

### UniWebViewCacheMode

# UniWebViewCacheMode
file: UniWebViewCacheMode

[[Properties]]
name: Default
returnType: UniWebViewCacheMode
hasSetter: false
summary:

Default mode. The web view will check the validity of the cache copy when there is one. If the copy is invalid, the web 
view will load from the network. This is the default setting.

[[Properties]]
name: NoCache
returnType: UniWebViewCacheMode
hasSetter: false
summary:

No cache is used. All pages are loaded directly from the network. This is useful for applications that do not want to 
have a cache.

[[Properties]]
name: CacheElseLoad
returnType: UniWebViewCacheMode
hasSetter: false
summary:

Prioritize the cache. If there is a copy of the page in the cache, the web view will use it even if the copy has 
expired. The web view will only load from the network when the page does not exist in the cache.

[[Properties]]
name: CacheOnly
returnType: UniWebViewCacheMode
hasSetter: false
summary:

Only use the cache. In this mode, the web view will not load pages from the network, only use the content in the cache. 
If the requested URL is not in the cache, an error is returned.

---

### UniWebViewChannelMethodHandleRequest

# UniWebViewChannelMethodHandleRequest
file: UniWebViewChannelMethodHandleRequest

summary:

Represents the request of a loading used in request handler.

[[Properties]]
name: Url
returnType: string
hasSetter: false
summary: The URL of the request.

[[Properties]]
name: IsMainFrame
returnType: bool
hasSetter: false
summary:

Whether the request is for the main frame (top-level document) or a sub-frame.

Returns true for main frame requests, false for non-main frame requests (including iframes and other sub-resources).

Note: On older Android versions (API level < 24), this may always return true due to 
platform limitations in distinguishing between main frame and sub-frame requests.

---

### UniWebViewChannelMethodMediaCapturePermission

# UniWebViewChannelMethodMediaCapturePermission
file: UniWebViewChannelMethodMediaCapturePermission

summary:

Represents the request of media capture permission.

This class represents the request of media capture permission. When the web page requests the permission to access
the device's hardware, such as the camera or microphone, UniWebView will ask you to handle the request with a value
of this class. You can use the values in this class to determine the decision for the permission request.

[[Properties]]
name: Protocol
returnType: string
hasSetter: false
summary:

The protocol used by the permission request. Such as "https" or "http".

example:

```csharp
// A permission request from 
// "https://webrtc.github.io/samples/src/content/getusermedia/gum/"

permission.Protocol // "https"
```

[[Properties]]
name: Host
returnType: string
hasSetter: false
summary:

The host of the origin of the permission request.

It is usually the domain of the web page.

example:

```csharp
// A permission request from 
// "https://webrtc.github.io/samples/src/content/getusermedia/gum/"

permission.Host // "webrtc.github.io"
```

[[Properties]]
name: Port
returnType: int
hasSetter: false
summary:

The port of the origin of the permission request.

If not existing in the request URL, it is -1.

example:

```csharp
// A permission request from 
// "https://webrtc.github.io/samples/src/content/getusermedia/gum/"

permission.Port // -1
```

[[Properties]]
name: Resources
returnType: string[]
hasSetter: false
summary:

The string representation of the resources of the origin of the permission request.

An array contains requested resources, the most common values are "VIDEO", "AUDIO". On Android, some pages can
also requests for "PROTECTED_MEDIA_ID", "MIDI_SYSEX", etc. 

example:

```csharp
// A permission request from 
// "https://webrtc.github.io/samples/src/content/getusermedia/gum/"

permission.Resources // ["VIDEO"]
```

---

### UniWebViewEmbeddedToolbar

# UniWebViewEmbeddedToolbar
file: UniWebViewEmbeddedToolbar

summary:

Represents the embedded toolbar in a web view.

You do not create an instance of this class directly. Instead, use the `EmbeddedWebView` property in `UniWebView` to
get the current embedded toolbar in the web view and interact with it.

The embedded toolbar of a web view expands its width to match the web view's frame width. It is displayed at either
top or bottom of the web view, based on the setting received through `SetPosition`. By default, the toolbar contains
a main title, a back button, a forward button and a done button to close the web view. You can use methods in this
class to customize the toolbar to match your app's style. 

[[Methods]]
name: SetPosition
syntax: SetPosition(UniWebViewToolbarPosition position)
returnType: void
summary:

Sets the position of the embedded toolbar. You can put the toolbar at either top or bottom of your web view.

The default position is `Top`.

example:

```csharp
// Sets the web view shows the toolbar at the bottom.
webView.EmbeddedToolbar.SetPosition(UniWebViewToolbarPosition.Bottom);
webView.EmbeddedToolbar.Show();
```

[[Methods.parameters]]
name: position
type: UniWebViewToolbarPosition
summary: The desired position of the toolbar.

[[Methods]]
name: SetMaxHeight
syntax: SetMaxHeight(float height)
returnType: void
summary:

Sets the maximum height of the toolbar. If the specified height is smaller than the toolbar's standard height,
the toolbar will be resized to this height. Otherwise, the standard height will be used.

This method only works on iOS and Android. On macOS Unity Editor, the toolbar will always be displayed in the
window's title bar and the height is fixed.

[[Methods.parameters]]
name: height
type: float
summary: The maximum height value.

[[Methods]]
name: Show
syntax: Show()
returnType: void
summary:

Shows the toolbar.

example:

```csharp
webView.EmbeddedToolbar.Show();
```

[[Methods]]
name: Hide
syntax: Hide()
returnType: void
summary:

Hides the toolbar.

example:

```csharp
webView.EmbeddedToolbar.Hide();
```

[[Methods]]
name: SetDoneButtonText
syntax: SetDoneButtonText(string text)
returnType: void
summary:

Sets the text of the done button. 

The default text is "Done".

example:

```csharp
webView.EmbeddedToolbar.SetDoneButtonText("关闭");
```

[[Methods.parameters]]
name: text
type: string
summary: The desired text to display as the done button.

[[Methods]]
name: SetGoBackButtonText
syntax: SetGoBackButtonText(string text)
returnType: void
summary:

Sets the text of the back button. 

The default text is "❮" ("\u276E").

example:

```csharp
webView.EmbeddedToolbar.SetDoneButtonText("返回");
```

[[Methods.parameters]]
name: text
type: string
summary: The desired text to display as the back button.

[[Methods]]
name: SetGoForwardButtonText
syntax: SetGoForwardButtonText(string text)
returnType: void
summary:

Sets the text of the forward button.

The default text is "❯" ("\u276F").

example:

```csharp
webView.EmbeddedToolbar.SetDoneButtonText("前进");
```

[[Methods.parameters]]
name: text
type: string
summary: The desired text to display as the forward button.

[[Methods]]
name: SetTitleText
syntax: SetTitleText(string text)
returnType: void
summary:

Sets the text of toolbar title. 

The default is empty. The space is limited, setting a long text as title might
not fit in the space.

example:

```csharp
webView.EmbeddedToolbar.SetDoneButtonText("My Game");
```

[[Methods.parameters]]
name: text
type: string
summary: The desired text to display as the title in the toolbar.

[[Methods]]
name: SetBackgroundColor
syntax: SetBackgroundColor(Color color)
returnType: void
summary:

Sets the background color of the toolbar.

example:

```csharp
webView.EmbeddedToolbar.SetBackgroundColor(Color.yellow);
```

[[Methods.parameters]]
name: color
type: Color
summary: The desired color of toolbar's background.

[[Methods]]
name: SetButtonTextColor
syntax: SetButtonTextColor(Color color)
returnType: void
summary:

Sets the buttons color of the toolbar. 

This color affects the back, forward and done button.

example:

```csharp
webView.EmbeddedToolbar.SetButtonTextColor(Color.red);
```

[[Methods.parameters]]
name: color
type: Color
summary: The desired color of toolbar's buttons.

[[Methods]]
name: SetTitleTextColor
syntax: SetTitleTextColor(Color color)
returnType: void
summary:

Sets the text color of the toolbar title. 

example:

```csharp
webView.EmbeddedToolbar.SetTitleTextColor(Color.blue);
```

[[Methods.parameters]]
name: color
type: Color
summary: The desired color of the toolbar's title.

[[Methods]]
name: HideNavigationButtons
syntax: HideNavigationButtons()
returnType: void
summary:

Hides the navigation buttons on the toolbar. 

When called, the back button and forward button will not be shown. 
By default, the navigation buttons are shown.

example:

```csharp
// Do not show the navigation buttons (go back and go forward).
webView.EmbeddedToolbar.HideNavigationButtons();
```

[[Methods]]
name: ShowNavigationButtons
syntax: ShowNavigationButtons()
returnType: void
summary:

Shows the navigation buttons on the toolbar. 

When called, the back button and forward button will be shown.
By default, the navigation buttons are shown.

---

### UniWebViewMediaCapturePermissionDecision

# UniWebViewMediaCapturePermissionDecision
file: UniWebViewMediaCapturePermissionDecision

[[Properties]]
name: Prompt
returnType: UniWebViewMediaCapturePermissionDecision
hasSetter: false
summary:

Display a prompt to ask user for the permission.

The prompt alert shows the origin of the request and the resources requested. It asks user to grant or deny the
permission.

[[Properties]]
name: Grant
returnType: UniWebViewMediaCapturePermissionDecision
hasSetter: false
summary:

Grant the permission request without asking user.

[[Properties]]
name: Deny
returnType: UniWebViewMediaCapturePermissionDecision
hasSetter: false
summary:

Deny the permission request. The web page will receive an error and it knows the request resources are not allowed to 
use.

---

### UniWebViewTransform

# UniWebViewTransform
file: UniWebViewTransform

summary:

Represents a transformation that can be applied to a UniWebView, including rotation and scaling.

The transformation includes:

- **Rotation**: The angle (in degrees) by which the web view should be rotated. Positive values rotate the web
view clockwise, while negative values rotate it counterclockwise.
- **Scaling**: The scale factors for the X and Y axes. A scale factor of 1.0 means no scaling, while values
greater than 1.0 enlarge the web view and values less than 1.0 shrink it.

This transformation is typically used in conjunction with the `SetTransform` method in `UniWebView` to apply visual
transformations to the web view.

[[Properties]]
name: Rotation
returnType: float
hasSetter: true
summary: The rotation of the web view in degrees.

[[Properties]]
name: ScaleX
returnType: float
hasSetter: true
summary: The scaling factor applied to the X-axis of the web view.

[[Properties]]
name: ScaleY
returnType: float
hasSetter: true
summary: The scaling factor applied to the Y-axis of the web view.

---

### UniWebView

# UniWebView
file: README

summary:
The main class of UniWebView. It represents a native web view and exposes a few APIs for you to use in 
Unity. You could create and use an instance of `UniWebView` to show a page from URL, interact with the web content, 
as well as receive a message from the web view.

[[Properties]]
name: IsWebViewSupported
returnType: bool
hasSetter: false
summary:

Whether the web view is supported in current runtime or not.

On some certain Android customized builds, the manufacturer prefers not containing the web view package in the 
system or blocks the web view package from being installed. If this happens, using of any web view related APIs will
throw a `MissingWebViewPackageException` exception.

Use this method to check whether the web view is available on the current running system. If this parameter returns `false`, 
you should not use the web view.

This property always returns `true` on other supported platforms, such as iOS or macOS editor. It only performs 
runtime checking on Android. On other not supported platforms such as Windows or Linux, it always returns `false`.

example:

```csharp
if (UniWebView.IsWebViewSupported) {
    // Do other things with UniWebView.
}
```

[[Properties.badges]]
name: static
color: blue

[[Properties]]
name: Frame
returnType: Rect
hasSetter: true
summary:
Gets or sets the frame of current web view. The value is based on current `Screen.width` and `Screen.height`.
The first two values of `Rect` is `x` and `y` position and the followed two `width` and `height`. The original point is 
top left corner:

![](https://docs.unity3d.com/StaticFiles/ScriptRefImages/RectXY.svg)

example:

```csharp
// Make the web view full screen:
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);

// Make the web view center in the screen with size 500x500:
var side = 500;
var x = (Screen.width - side) / 2.0f;
var y = (Screen.height - side) / 2.0f;
webView.Frame = new Rect(x, y, side, side);
```

notice: `Frame` will be ignored if `ReferenceRectTransform` is set.

[[Properties]]
name: ReferenceRectTransform
returnType: RectTransform
hasSetter: true
summary:

A reference rect transform which the web view should change its position and size to.

Set it to a Unity UI element (which contains a `RectTransform`) under a canvas to determine the web view frame by a certain UI element. 

By using this, you could get benefit from [Multiple Resolutions UI](https://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html).

example:

```csharp
// Some panel
RectTransform panel = ...

// Set the web view position and size to match panel
webView.ReferenceRectTransform = panel;
```

[[Properties]]
name: Url
returnType: string
hasSetter: false
summary: The url of current loaded web page.
example:

```csharp
webView.Load("https://example.com/");

// Some time later or in "OnPageFinished":
print(webView.Url);
// => "https://example.com/"
```

[[Properties]]
name: CanGoBack
returnType: bool
hasSetter: false
summary: Gets whether there is a back page in the back-forward list that can be navigated to.

[[Properties]]
name: CanGoForward
returnType: bool
hasSetter: false
summary: Gets whether there is a forward page in the back-forward list that can be navigated to.

[[Properties]]
name: BackgroundColor
returnType: Color
hasSetter: true
summary:

Gets or sets the background color of web view. The default value if `Color.white`.

This only sets the background color of the content view of the web view. Normally, the background
color will be hidden by the web page background. If you want to make the web view background visible,
you need to make the web page it transparent by adding some necessary style to it.

This property only changes the web view background. 
If you want to make the whole web view transparent, use `Alpha` instead.

example:

```csharp
// Set the web view background (under the web page) to red.
webView.BackgroundColor = Color.red;
```

[[Properties]]
name: Alpha
returnType: float
hasSetter: true
summary:

Gets or sets the alpha value of the whole web view.

You can make the game scene behind web view visible to make the web view transparent.

The default value is `1.0f`, which means totally opaque. Set it to `0.0f` will make the web view totally transparent.

example:

```csharp
// Set the web view half transparent.
webView.Alpha = 0.5f;
```

[[Properties]]
name: EmbeddedToolbar
returnType: UniWebViewEmbeddedToolbar
hasSetter: false
summary:

Represents the embedded toolbar in the current web view.

A toolbar is a built-in area inside the web view, shown at the top or bottom of the web view. It contains navigation buttons
like "Back" and "Forward", as well as a "Done" button to close the web view. You can use APIs under `UniWebViewEmbeddedToolbar` 
to customize the toolbar. See [its APIs](/api/UniWebViewEmbeddedToolbar.html) for more details.

example:

```csharp
// Show the embedded toolbar.
webView.EmbeddedToolbar.Show();
```

[[Properties]]
name: RestoreViewHierarchyOnResume
returnType: bool
hasSetter: true
summary:

Sets whether this web view instance should try to restore its view hierarchy when resumed.

In some versions of Unity when running on Android, the player view is brought to front when switching back
from a pause state, which causes the web view is invisible when the app is resumed. It requires an additional
step to bring the web view to front to make the web view visible. Set this to true to apply this workaround.

Issue caused by this [Unity issue](https://issuetracker.unity3d.com/issues/android-a-black-screen-appears-for-a-few-seconds-when-returning-to-the-game-from-the-lock-screen-after-idle-time).

This issue is known in these released versions:
- Unity 2021.3.31, 2021.3.32, 2021.3.31, 2021.3.34
- Unity 2022.3.10, 2022.3.11, 2022.3.12, 2022.3.13, 2022.3.14, 2022.3.15

If you are using UniWebView in these versions, you may want to set this value to `true`.

[[Methods]]
name: SetTransform
syntax: SetTransform(UniWebViewTransform transform)
returnType: void
summary:

Applies a transformation to the web view, including rotation and scaling.

This method allows you to rotate and scale the web view by specifying a `UniWebViewTransform`
object. The transformation is applied relative to the web view's current position and size, with its center
as the anchor.

The transformation includes:

- **Rotation**: The angle (in degrees) by which the web view should be rotated. Positive values rotate the web
view clockwise, while negative values rotate it counterclockwise.
- **Scaling**: The scale factors for the X and Y axes. A scale factor of 1.0 means no scaling, while values
greater than 1.0 enlarge the web view and values less than 1.0 shrink it.

This method works on iOS and Android. It does nothing in Unity Editor on macOS.

notice:

This method does not affect the `ReferenceRectTransform` or Unity's `transform` component. 
It only applies the transformation, or say, the rotation and scale to the web view itself in the native side.

example:

```csharp
// Rotate the web view 45 degrees clockwise and scale it half of its original size.
var transform = new UniWebViewTransform(45, 0.5f, 0.5f);
webView.SetTransform(transform);

// --------------

// Show a landscape web page in the game with only portrait mode.
// Calculate dimensions for a rotated full-screen web view
float x = (Screen.width - Screen.height) / 2.0f;
float y = (Screen.height - Screen.width) / 2.0f;
float width = Screen.height;
float height = Screen.width;

// Set the frame to properly position the web view
webView.Frame = new Rect(x, y, width, height);

var transform = new UniWebViewTransform(90);
webView.SetTransform(transform);

webView.Load("https://example.com");
webView.Show();
```

[[Methods.parameters]]
name: transform
type: UniWebViewTransform
summary: An object containing the rotation angle and scale factors to apply to the web view.

[[Methods]]
name: Load
syntax: Load(string url, bool skipEncoding, string readAccessURL)
returnType: void
summary: Loads a url in current web view.
example:

```csharp
// Load a URL.
webView.Load("https://example.com");

// Load a URL which is already escaped.
webView.Load("https://example.com?email=support%40uniwebview.com", true);

// Load a local file, with "local_app_folder/root/images/" as its read access path.
var indexURL = UniWebViewHelper.StreamingAssetURLForPath("local_app_folder/root/page/index.html");
var accessURL = UniWebViewHelper.StreamingAssetURLForPath("local_app_folder/root/images/");
webView.Load(indexURL, false, accessURL);
```

[[Methods.parameters]]
name: url
type: string
summary: The url to be loaded. This url should start with `http://` or `https://` scheme, or retrieved from the path methods in `UniWebViewHelper`.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the url or not. If set to `false`, UniWebView will try to encode the url parameter before loading it. Otherwise, your original url string will be used as the url if it is valid. Default is `false`.
[[Methods.parameters]]
name: readAccessURL
type: string
summary: The URL to allow read access to. This parameter is only used when loading from the filesystem in iOS, and passed to `loadFileURL:allowingReadAccessToURL:` method of WebKit. By default, the parent folder of the `url` parameter will be read accessible.

[[Methods]]
name: LoadHTMLString
syntax: LoadHTMLString(string htmlString, string baseUrl, bool skipEncoding)
returnType: void
summary: Loads an HTML string in current web view.
example:

```csharp
webView.LoadHTMLString("<p>Hello World</p>", "https://domain.com");
```

[[Methods.parameters]]
name: htmlString
type: string
summary: The HTML string to use as the contents of the webpage.
[[Methods.parameters]]
name: baseUrl
type: string
summary: The url to use as the page's base url.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the baseUrl or not. If set to `false`, UniWebView will try to encode the baseUrl parameter before using it. Otherwise, your original url string will be used as the baseUrl if it is valid. Default is `false`.

[[Methods]]
name: Reload
syntax: Reload()
returnType: void
summary: Reloads the current page.

[[Methods]]
name: Stop
syntax: Stop()
returnType: void
summary: Stops loading all resources on the current page.

[[Methods]]
name: GoBack
syntax: GoBack()
returnType: void
summary: Navigates to the back item in the back-forward list.
example:

```csharp
if (webView.CanGoBack) {
    webView.GoBack();
}
```

[[Methods]]
name: GoForward
syntax: GoForward()
returnType: void
summary: Navigates to the forward item in the back-forward list.
example:

```csharp
if (webView.CanGoForward) {
    webView.GoForward();
}
```

[[Methods]]
name: CopyBackForwardList
syntax: CopyBackForwardList()
returnType: UniWebViewBackForwardList
summary:

Gets a copy of the back-forward list, which is the navigation history for the web view.

The back-forward list represents the browsing history in the current web view. It contains information
about visited (both back and forward) pages and allows access to any entry in the history by index. This is a
snapshot of the history at the time of calling - it won't update automatically with new navigation. Call
`CopyBackForwardList` again to get the latest history if necessary.

returnValue:
A list object containing a snapshot of the navigation history. It provides a read-only record of all 
web pages visited in this web view.

example:

```csharp
webView.OnPageFinished += (view, statusCode, url) => {
  PrintList();
};
webView.OnLoadingErrorReceived += (view, code, message, payload) => {
  PrintList();
};

void PrintList() {
  var list = webView.CopyBackForwardList();

  // The current viewing page index in `list.AllItems`. 
  // If `-1`, means no item in the list.
  var currentIndex = list.CurrentIndex;

  // List all items in the back-forward list.
  for (var i = 0; i < list.Size; i++) {
    var item = list.ItemAtIndex(i);
    Debug.Log($"#{i}: {item.Url}");
  }
}
```

[[Methods]]
name: GoToIndexInBackForwardList
syntax: GoToIndexInBackForwardList(int index)
returnType: void
summary:

Navigates to the specified index in the back-forward list.

The index is a zero-based index of the item in the back-forward list. If the index is out of range, this method does
nothing.

example:

```csharp
// Go to the first item in the back-forward list.
webView.GoToIndexInBackForwardList(0);
```

[[Methods.parameters]]
name: index
type: int
summary: The zero-based index of the item in the back-forward list.

[[Methods]]
name: SetOpenLinksInExternalBrowser
syntax: SetOpenLinksInExternalBrowser(bool flag)
returnType: void
summary:

Sets whether the link clicking in the web view should open the page in an external browser.

By default, when the user clicks a link, it will be opened in the same web view. After setting this with `true`, 
the user will be navigated to an external native browser.

On iOS, the mobile Safari; on Android, the default browser like Chrome; on macOS Editor, the default browser of your system will be used.

example:

```csharp
// You may want to set it in OnPageFinished event, 
// otherwise the original page will be also opened externally
webView.OnPageFinished += (view, statusCode, url) => {
    webView.SetOpenLinksInExternalBrowser(true);
};
```

[[Methods.parameters]]
name: flag
type: bool
summary: The flag indicates whether a link should be opened externally.

[[Methods]]
name: Show
syntax: Show(bool fade, UniWebViewTransitionEdge edge, float duration, Action completionHandler)
returnType: bool
returnValue: A `bool` value indicates whether the showing operation started.
summary:
Sets the web view visible on screen.

If you pass `false` and `UniWebViewTransitionEdge.None` to the first two parameters, it means no animation will be applied when showing. So the `duration` parameter will not be taken into account. Otherwise, when 
either or both `fade` and `edge` set, the showing operation will be animated.

Regardless of there is an animation or not, the `completionHandler` will be called if not `null` when the web view
showing finishes.

example:

```csharp
// Show the web view without animation
webView.Show();

// Show the web view with a fade animation
webView.Show(true);

// Show the web view with a modal presenting animation from screen bottom
webView.Show(false, UniWebViewTransitionEdge.Bottom);

// Print a message after the web view shown with animation
webView.Show(true, UniWebViewTransitionEdge.Top, 0.25f, ()=> {
    print("Show transition finished!");
});
```

[[Methods.parameters]]
name: fade
type: bool
summary: Whether show with a fade in animation. Default is `false`.
[[Methods.parameters]]
name: edge
type: UniWebViewTransitionEdge
summary: The edge from which the web view showing. It simulates a modal effect when showing a web view. Default is `UniWebViewTransitionEdge.None`.
[[Methods.parameters]]
name: duration
type: float
summary: Duration of the showing animation. Default is `0.4f`.
[[Methods.parameters]]
name: completionHandler
type: Action
summary: Completion handler which will be called when showing finishes. Default is `null`.

[[Methods]]
name: Hide
syntax: Hide(bool fade, UniWebViewTransitionEdge edge, float duration, Action completionHandler)
returnType: bool
returnValue: A `bool` value indicates whether the hiding operation started.
summary:
Sets the web view invisible from screen.

If you pass `false` and `UniWebViewTransitionEdge.None` to the first two parameters, it means no animation will be applied when hiding. So the `duration` parameter will not be taken into account. Otherwise, when either or both `fade` and `edge` set, the hiding operation will be animated.

Regardless there is an animation or not, the `completionHandler` will be called if not `null` when the web view
hiding finishes.

notice:
Hiding the web view does not destroy or release it. You can always call `Show` on the web view again to make it visible.

To release a web view and its resource, pass the web view component as the parameter of `Destroy`.

example:

```csharp
// Hide the web view without animation
webView.Hide();

// Hide the web view with a fade animation
webView.Hide(true);

// Hide the web view with a modal presenting animation from screen bottom
webView.Hide(false, UniWebViewTransitionEdge.Bottom);

// Print a message after the web view hidden with animation
webView.Hide(true, UniWebViewTransitionEdge.Top, 0.25f, ()=> {
    print("Hide transition finished!");
});
```

[[Methods.parameters]]
name: fade
type: bool
summary: Whether hide with a fade in animation. Default is `false`.
[[Methods.parameters]]
name: edge
type: UniWebViewTransitionEdge
summary: The edge from which the web view hiding. It simulates a modal effect when hiding a web view. Default is `UniWebViewTransitionEdge.None`.
[[Methods.parameters]]
name: duration
type: float
summary: Duration of hiding animation. Default is `0.4f`.
[[Methods.parameters]]
name: completionHandler
type: Action
summary: Completion handler which will be called when hiding finishes. Default is `null`.

[[Methods]]
name: AnimateTo
syntax: AnimateTo(Rect frame, float duration, float delay, Action completionHandler)
returnType: bool
returnValue: A `bool` value indicates whether the animation started.
summary: Animates the web view from current `Frame` (position and size) to another `Frame` (position and size) within `duration`.
example:

```csharp
// Animate current web view to cover half of the screen.
var halfScreen = new Rect(0, 0, Screen.width, Screen.height / 2);
webView.AnimateTo(halfScreen, 0.4f, 0.1f, () => {
    print("Animation finished!");
});
```

[[Methods.parameters]]
name: frame
type: Rect
summary: The new `Frame` which the web view should be.
[[Methods.parameters]]
name: duration
type: float
summary: Duration of the animation.
[[Methods.parameters]]
name: delay
type: float
summary: Delay before the animation begins. Default is `0.0f`, which means the animation will start immediately.
[[Methods.parameters]]
name: completionHandler
type: Action
summary: Completion handler which will be called when animation finishes. Default is `null`.

[[Methods]]
name: UpdateFrame
syntax: UpdateFrame()
returnType: void
summary:

Updates and sets current frame of web view to match the setting.

This is useful if the `referenceRectTransform` is changed and you need to sync the frame change
to the web view. This method follows the frame determining rules.

example:

```csharp
// In a UIBehavior script:
// Called when associated `rectTransform` is changed.
void OnRectTransformDimensionsChange() {
    // This will update web view's frame to match the reference rect transform if set.
    webView.UpdateFrame();
}
```

[[Methods]]
name: AddJavaScript
syntax: AddJavaScript(string jsString, Action<UniWebViewNativeResultPayload> completionHandler)
returnType: void
summary:

Adds a JavaScript to current page. Normally, you add a JavaScript function or variable with this method.

The input `jsString` will be executed by current web view. If succeeded, the input JavaScript code will "inject" 
to the web view and a `UniWebViewNativeResultPayload` with `resultCode` being "0" will passed to the `completionHandler`.

example:

```csharp
webView.AddJavaScript("function add() { return 1 + 2; }", (payload)=>{
    if (result.resultCode.Equal("0")) {
        print("JavaScript adding finished without problem.");
    }
});
```

[[Methods.parameters]]
name: jsString
type: string
summary: The JavaScript code to add. It should be a valid JavaScript statement string.
[[Methods.parameters]]
name: completionHandler
type: Action<UniWebViewNativeResultPayload>
summary: Called when adding JavaScript operation finishes. Default is `null`. If everything goes fine and the `jsString` added to current web view, `resultCode` would be \0\""

[[Methods]]
name: EvaluateJavaScript
syntax: EvaluateJavaScript(string jsString, Action<UniWebViewNativeResultPayload> completionHandler)
returnType: void
summary:
Evaluates a JavaScript string on current page. Normally you execute a certain JavaScript function or get a variable by this method.

The input `jsString` will be executed by current web view. Executing result will be sent back to you in the `completionHandler`. You could access the `data` member of `UniWebViewNativeResultPayload` passed in to get the JavaScript function return value.

example:

```csharp
// Pop up an alert from web view.
webView.EvaluateJavaScript("alert('Alert!');", (payload)=>{
    print(payload.resultCode); // => "0"
    print(payload.data); // => ""
});

// Adding two numbers by a JavaScript function.
webView.AddJavaScript("function add(a, b) { return a + b; }", completionHandler: _ => {
    webView.EvaluateJavaScript("add(4, 5);", completionHandler: (payload) => {
        print(payload.resultCode); // => "0"
        print(payload.data);  // => "9"
    });
});

// Call a JavaScript function not existing.
webView.EvaluateJavaScript("functionNotExisting()", completionHandler: (payload) => {
    print(payload.resultCode);
    // a non-zero value which indicates JavaScript error code.
    // eg. "4" on iOS.
});
```

[[Methods.parameters]]
name: jsString
type: string
summary: The JavaScript string to evaluate.
[[Methods.parameters]]
name: completionHandler
type: Action<UniWebViewNativeResultPayload>
summary: Called when evaluating JavaScript operation finishes. Default is `null`. If everything goes find, the `resultCode` would be \0\" and the return value of invoked JavaScript is contained in `data`."

[[Methods]]
name: AddUrlScheme
syntax: AddUrlScheme(string scheme)
returnType: void
summary: Adds a url scheme to UniWebView message system interpreter. All following url navigation to this scheme will be sent as a message to UniWebView instead.
example:

```csharp
// Add "myscheme" as a UniWebView message scheme.
webView.AddUrlScheme("myscheme");

// A link like "myscheme://action" will be treated as a message and raise the `OnMessageReceived` event from now.
```

[[Methods.parameters]]
name: scheme
type: string
summary: The URL scheme to add. It should not contain \://\" part. You could even add \"http\" and/or \"https\" to prevent all resource loading on the page. \"uniwebview\" is added by default. Nothing will happen if you try to add a duplicated scheme."

[[Methods]]
name: RemoveUrlScheme
syntax: RemoveUrlScheme(string scheme)
returnType: void
summary: Removes a url scheme from UniWebView message system interpreter.
example:

```csharp
webView.RemoveUrlScheme("myscheme");
```

[[Methods.parameters]]
name: scheme
type: string
summary: The url scheme to remove. Nothing will happen if the scheme is not in the message system.

[[Methods]]
name: AddSslExceptionDomain
syntax: AddSslExceptionDomain(string domain)
returnType: void
summary:

Adds a domain to the SSL checking white list.

If you are trying to access a website with un-trusted or expired certification, 
the web view will prevent its loading. If you could confirm that this site is trusted,
you can add the domain as an SSL exception, so you could visit it.

notice: We strongly suggest you upgrade your site certification to a trusted one. It would be dangerous to add a site as SSL exception and your user might be exposed to the risk of Man-in-the-middle attack. You should know exactly what you will do before adding a domain to the whitelist.
example:

```csharp
// This loading will fail since the certification is a self-signed one and not trusted.
webView.Load("https://self-signed.badssl.com/"); 

// Add "self-signed.badssl.com" as trusted.
webView.AddSslExceptionDomain("self-signed.badssl.com");
// This page should load now.
webView.Load("https://self-signed.badssl.com/"); 
```

[[Methods.parameters]]
name: domain
type: string
summary: The domain to add. It should not contain any scheme or path part in url.

[[Methods]]
name: RemoveSslExceptionDomain
syntax: RemoveSslExceptionDomain(string domain)
returnType: void
summary: Removes a domain from the SSL checking white list.
example:

```csharp
webView.RemoveSslExceptionDomain("self-signed.badssl.com");
```

[[Methods.parameters]]
name: domain
type: string
summary: The domain to remove. It should not contain any scheme or path part in url.

[[Methods]]
name: SetHeaderField
syntax: SetHeaderField(string key, string value)
returnType: void
summary:

Sets a customized header field for web view requests.

The header field will be used for all subsequence request. 
Pass `null` as value to unset a header field.

Some reserved headers like user agent are not able to override by setting here, 
use the `SetUserAgent` method for them instead.

notice:
Customized header fields will only be set for `GET` requests. The header fields set by this 
method will not be added when a form is submitted as `POST` requests, due to some limitation of WebKit on iOS 
and Android platforms.

example:

```csharp
// Set "MyToken" field to "123abc" in a web view. It will be used for all following requests.
webView.SetHeaderField("MyToken", "123abc");

// Unset it
webView.SetHeaderField("MyToken", null);
```

[[Methods.parameters]]
name: key
type: string
summary: The key of customized header field.
[[Methods.parameters]]
name: value
type: string
summary: The value of customized header field. `null` if you want to unset the field.

[[Methods]]
name: SetUserAgent
syntax: SetUserAgent(string agent)
returnType: void
summary: Sets the user agent used in the web view. If the string is null or empty, the system default value will be used.
example:

```csharp
// Set the user agent string sent in request header.
webView.SetUserAgent("My-App/1.0.0 (iOS 10.3, iPhone 7)");

// => In request header:
// User-Agent = "My-App/1.0.0 (iOS 10.3, iPhone 7)"
```

[[Methods.parameters]]
name: agent
type: string
summary: The new user agent string to use.

[[Methods]]
name: GetUserAgent
syntax: GetUserAgent()
returnType: string
returnValue: The user agent string in use.
summary: Gets the user agent string currently used in web view. If a customized user agent is not set, the default user agent in current platform will be returned.
example:

```csharp
// Gets the default user agent.
webView.GetUserAgent()
// => "Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 ..."
// This value varies in different platforms.

// Sets a user agent and then get it.
webView.SetUserAgent("My-App/1.0.0 (iOS 10.3, iPhone 7)");
webView.GetUserAgent()
// => "My-App/1.0.0 (iOS 10.3, iPhone 7)"
```

[[Methods]]
name: SetContentInsetAdjustmentBehavior
syntax: SetContentInsetAdjustmentBehavior(UniWebViewContentInsetAdjustmentBehavior behavior)
returnType: void

summary:

Sets the adjustment behavior which indicates how safe area insets 
are added to the adjusted content inset. It is a wrapper of [`contentInsetAdjustmentBehavior`](https://developer.apple.com/documentation/uikit/uiscrollview/2902261-contentinsetadjustmentbehavior) on iOS.

It only works on iOS 11 and above.

notice:

You need to call this method as soon as you create a web view,
before you call any other methods related to web view layout (like `Show` or `SetShowToolbar`).

example:

```csharp
var webView = gameObject.AddComponent<UniWebView>();
// Do not adjust the scroll view insets in the web view.
webView.SetContentInsetAdjustmentBehavior(UniWebViewContentInsetAdjustmentBehavior.Never);
```

[[Methods.parameters]]
name: behavior
type: UniWebViewContentInsetAdjustmentBehavior
summary: The behavior for determining the adjusted content offsets.
[[Methods.badges]]
name: iOS
color: orange

[[Methods]]
name: SetAllowAutoPlay
syntax: SetAllowAutoPlay(bool flag)
returnType: void

summary:

Sets allow auto-play for current web view. By default, 
users need to touch the play button to start playing a media resource.

By setting this to `true`, you can start the playing automatically through
corresponding media [tag attributes](https://www.w3schools.com/tags/att_video_autoplay.asp).

notice: You need to set it before creating a web view. Existing web views are not affected.
example:

```csharp
UniWebView.SetAllowAutoPlay(true);

// Create a new web view.
var webView = gameObject.AddComponent<UniWebView>();

// Now load and open a page which contains auto-started video to try
webView.Load("https://www.w3schools.com/tags/tryit.asp?filename=tryhtml5_video_autoplay");
webView.Show();
```

[[Methods.badges]]
name: static
color: blue

[[Methods.parameters]]
name: flag
type: bool
summary: A flag indicates whether auto-playing of media is allowed or not.

[[Methods]]
name: SetAllowInlinePlay
syntax: SetAllowInlinePlay(bool flag)
returnType: void
summary:

Sets allow inline play for current web view. By default, on iOS, the video 
can only be played in a new full screen view.

By setting this to `true`, you could play a video inline the page, instead of opening 
a new full-screen window.

This only works for iOS and macOS Editor. 
On Android, you could play videos inline by default and calling this method does nothing.

Remember you also need to add "playsinline" attribute to your video tag in the HTML page.

notice: You need to set it before creating a web view. Existing web views are not affected.
example:

```csharp
UniWebView.SetAllowInlinePlay(true);

// Create a new web view.
var webView = gameObject.AddComponent<UniWebView>();

// Now load and open a page which contains inline video to try:
// <video src="file.mp4" playsinline> or <video src="file.mp4" webkit-playsinline>
webView.Load("https://example.com/inline-video");
webView.Show();
```

[[Methods.badges]]
name: static
color: blue
[[Methods.badges]]
name: iOS
color: orange
[[Methods.parameters]]
name: flag
type: bool
summary: A flag indicates whether inline playing of media is allowed or not.

[[Methods]]
name: SetAllowFileAccess
syntax: SetAllowFileAccess(bool flag)
returnType: void
summary:

Sets whether loading a local file is allowed.

If set to `false`, any load from a file URL `file://` for `Load` method will be rejected and trigger an 
`OnLoadingErrorReceived` event. That means you cannot load a web page from any local file. If you are not going to 
load any local files, setting it to `false` helps to reduce the interface of web view and improve the security.

By default, it is `true` and the local file URL loading is allowed.

example:

```csharp
// Forbid file:// URL loading.
webView.SetAllowFileAccess(false);

// This won't load and trigger an error in OnLoadingErrorReceived.
var url = UniWebViewHelper.StreamingAssetURLForPath("www/index.html");
webView.Load(url);
```

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the local file access by web view loading is allowed or not.

[[Methods]]
name: SetAllowFileAccessFromFileURLs
syntax: SetAllowFileAccessFromFileURLs(bool flag)
returnType: void
summary:

Sets whether file access from file URLs is allowed.

By setting with `true`, access to file URLs inside the web view will be enabled and you could access 
sub-resources or make cross origin requests from local HTML files.

On iOS, it uses some "hidden" way by setting `allowFileAccessFromFileURLs` in config preferences for WebKit.
So it is possible that it stops working in a future version.

On Android, it sets the `WebSettings.setAllowFileAccessFromFileURLs` for the current web view.

notice:

By setting this to `true`, you will bring some potential security issue to your app. Some malicious script 
would be able to read your sandbox. So we DO NOT recommend to enable it before you realize and understand the risk.

example:

```csharp
webView.SetAllowFileAccessFromFileURLs(true);
```

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the file access inside web view from file URLs is allowed or not.

[[Methods]]
name: SetAcceptThirdPartyCookies
syntax: SetAcceptThirdPartyCookies(bool flag)
returnType: void
summary:

Sets whether the UniWebView should allow third party cookies to be set. 

By default, on Android, the third party
cookies are disallowed due to security reason. Setting this to `true` will allow the cookie manager to accept
third party cookies you set. 

This method only works for Android. On iOS, this method does nothing because WKWebView fundamentally does not 
support third party cookies. This is a deliberate architectural limitation of WKWebView for privacy and security 
reasons. Third party cookies are always blocked on iOS and cannot be enabled through any API.

If your application requires third party cookie support, consider using alternative authentication methods 
such as OAuth or JWT tokens.

notice:

**iOS 18 Changes**: Starting from iOS 18, the default SameSite cookie attribute changed from "None" to "Lax", 
which may affect cross-site cookie behavior even for first party cookies. If you need to set cookies with 
SameSite=None on iOS 18+, you must explicitly specify this along with the Secure attribute.

example:

```csharp
// This only works on Android
webView.SetAcceptThirdPartyCookies(true);

// For iOS applications that need cross-site authentication,
// consider using alternative approaches:
// 1. OAuth flow with redirect URIs
// 2. JWT tokens passed via URL parameters or postMessage
// 3. Server-side session management with first-party cookies
```

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: flag
type: bool
summary: Whether the third party cookies should be allowed (Android only).

[[Methods]]
name: SetAllowUniversalAccessFromFileURLs
syntax: SetAllowUniversalAccessFromFileURLs(bool flag)
returnType: void
summary:

Sets allow universal access from file URLs. By default, on iOS, the `WKWebView` forbids any load of local files
through AJAX even when opening a local HTML file. It checks the CORS rules and fails at web view level. 
This is useful when you want access these files by setting the `allowUniversalAccessFromFileURLs` key of web view
configuration.

On iOS and macOS Editor. It uses some "hidden" way by setting `allowUniversalAccessFromFileURLs` in config 
for WebKit. So it is possible that it stops working in a future version.

On Android, it sets the `WebSettings.setAllowUniversalAccessFromFileURLs` and any later-created web views uses
that value.

notice:

You need to set it before creating a web view. Existing web views are not affected.

By setting this to `true`, you will bring some potential security issue to your app. Some malicious script 
would be able to read your sandbox. So we DO NOT recommend to enable it before you realize and understand the risk.

example:

```csharp
UniWebView.SetAllowUniversalAccessFromFileURLs(true);

// Create a new web view.
var webView = gameObject.AddComponent<UniWebView>();
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: flag
type: bool
summary: A flag indicates whether the universal access for files are allowed or not.

[[Methods]]
name: SetEnableKeyboardAvoidance
syntax: SetEnableKeyboardAvoidance(bool flag)
returnType: void
summary:

Sets whether the web view area should avoid soft keyboard. If `true`, when the keyboard shows up, the web views
content view will resize itself to avoid keyboard overlap the web content. Otherwise, the web view will not resize
and just leave the content below under the soft keyboard.

Default is `true`.

notice:

This method is only for Android. On iOS, the keyboard avoidance is built into the system directly and there is 
no way to change its behavior.

You need to set it before creating a web view. Existing web views are not affected.

example:

```csharp
UniWebView.SetEnableKeyboardAvoidance(false);

// Create a new web view.
var webView = gameObject.AddComponent<UniWebView>();
```

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the keyboard should avoid web view content.
[[Methods.badges]]
name: static
color: blue
[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: SetJavaScriptEnabled
syntax: SetJavaScriptEnabled(bool enabled)
returnType: void
summary:

Sets whether JavaScript should be enabled in current web view. Default is enabled.

For a modern page, you may always want JavaScript enabled. However, if you could confirm that you are
not using any JavaScript in your page, you could turn it off to get better performance and safety.

notice: You need to set it before creating a web view. Existing web views are not affected.
example:

```csharp
// Disable JavaScript in web views created later.
UniWebView.SetJavaScriptEnabled(false);

// JavaScript is disabled in this web view.
var webView = gameObject.AddComponent<UniWebView>();
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether JavaScript should be enabled.

[[Methods]]
name: SetLimitsNavigationsToAppBoundDomains
syntax: SetLimitsNavigationsToAppBoundDomains(bool flag)
returnType: void
summary:

Sets whether the web view limits navigation to pages within the app’s domain.

This only works on iOS 14.0+. For more information, refer to the [Apple's documentation](https://developer.apple.com/documentation/webkit/wkwebviewconfiguration/3585117-limitsnavigationstoappbounddomai)
and the [App-Bound Domains](https://webkit.org/blog/10882/app-bound-domains/) page. This requires additional setup in `WKAppBoundDomains` key in the Info.plist file.

On Android, this method does nothing.

notice: You need to set it before creating a web view. Existing web views are not affected.
example:

```csharp
// Enable navigation limitation in web views created later.
UniWebView.SetLimitsNavigationsToAppBoundDomains(true);

// This config is applied in this web view.
var webView = gameObject.AddComponent<UniWebView>();
```

[[Methods.badges]]
name: static
color: blue
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether limiting navigation should be enabled.

[[Methods]]
name: SetAllowJavaScriptOpenWindow
syntax: SetAllowJavaScriptOpenWindow(bool flag)
returnType: void
summary: Sets whether JavaScript can open windows without user interaction.\n\nBy setting this to `true`, an automatically JavaScript navigation will be allowed in the web view.
notice: You need to set it before creating a web view. Existing web views are not affected.
example:

```csharp
// Allow JavaScript open window automatically.
UniWebView.SetAllowJavaScriptOpenWindow(true);

var webView = gameObject.AddComponent<UniWebView>();

// Now, the following JavaScript code could navigate to 
// "example.com" without user interaction in `webView`.
setTimeout(function() {
    window.location.href = 'https://example.com';
}, 300);
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: flag
type: bool
summary: Whether JavaScript could open window automatically.

[[Methods]]
name: SetCalloutEnabled
syntax: SetCalloutEnabled(bool enabled)
returnType: void
summary:

Sets whether a callout (context) menu should be displayed when user long tapping on certain web view content.

When enabled, when user long presses an image or link in the web page, a context menu would be show up to ask 
user's action. On iOS, it is a action sheet to ask whether opening the target link or saving the image. On 
Android it is a pop up dialog to ask whether saving the image to local disk. On iOS, the preview page triggered 
by force touch on iOS is also considered as a callout menu.

Default is `true`, means that the callout menu will be displayed. Call this method with `false` to disable it 
on the web view.

example:

```csharp
// Disable callout menu in the web view.
webView.SetCalloutEnabled(false);
```

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether a callout menu should be displayed when user long pressing or force touching a certain web page element.

[[Methods]]
name: SetSupportMultipleWindows
syntax: SetSupportMultipleWindows(bool enabled, bool allowJavaScriptOpening)
returnType: void
summary:

Sets whether the web view should support a pop up web view triggered by user in a new tab.

In a general web browser (such as Google Chrome or Safari), a URL with `target="_blank"` attribute is intended 
to be opened in a new tab. However, in the context of web view, there is no way to handle new tabs without 
proper configurations. Due to that, by default UniWebView will ignore the `target="_blank"` and try to open 
the page in the same web view if that kind of link is pressed.

It works for most cases, but if this is a problem to your app logic, you can change this behavior by calling 
this method with `true`. It enables the "opening in new tab" behavior in a limited way, by adding the new tab 
web view above to the current web view, with the same size and position. When the opened new tab is closed, 
it will be removed from the view hierarchy automatically.

By default, only user triggered action is allowed to open a new window for security reason. That means, if you 
are using some JavaScript like `window.open`, unless you set `allowJavaScriptOpening` to `true`, it won't work. 
This default behavior prevents any other third party JavaScript code from opening a window arbitrarily.

[[Methods.parameters]]
name: enabled
type: bool
summary:

Whether to support multiple windows. If `true`, the `target="_blank"` link will be opened in a new web view. 
Default is `false`.

[[Methods.parameters]]
name: allowJavaScriptOpening
type: bool
summary:

Whether to support open the new window with JavaScript by `window.open`. Setting this to `true` means any JavaScript
code, even from third party (in an iframe or a library on the page), can open a new window. Use it as your risk.

Usually, when passing `true` to this parameter, you may also want to call `SetAllowJavaScriptOpenWindow` with `true`
before creating the web view.

[[Methods]]
name: SetDefaultFontSize
syntax: SetDefaultFontSize(int size)
returnType: void
summary:

Sets the default font size used in the web view.

On Android, the web view font size can be affected by the system font scale setting. Use this method to set the 
font size in a more reasonable way, by giving the web view another default font size with the system font scale 
considered. It can removes or reduces the effect of system font scale when displaying the web content.

This method only works on Android. On iOS, this method does nothing since the web view will respect the font 
size setting in your CSS styles.

[[Methods.parameters]]
name: size
type: int
summary:

The target default font size set to the web view.

[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: SetTextZoom
syntax: SetTextZoom(int textZoom)
returnType: void
summary:

Sets the text zoom used in the web view.

On Android, this method call [`WebSettings.setTextZoom`](https://developer.android.com/reference/android/webkit/WebSettings#setTextZoom(int)) 
to the the text zoom used in the web view.

This method only works on Android.

[[Methods.parameters]]
name: textZoom
type: int
summary:

The text zoom in percent.

[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: SetDragInteractionEnabled
syntax: SetDragInteractionEnabled(bool enabled)
returnType: void
summary:

Sets whether the drag interaction should be enabled on iOS.

From iOS 11, the web view on iOS supports the drag interaction when user long presses an image, link or text.
Setting this to `false` would disable the drag feather on the web view.

On Android, there is no direct native way to disable drag only. This method instead disables the long touch
event, which is used as a trigger for drag interaction. So, setting this to `false` would disable the long
touch gesture as a side effect. 

It does nothing on macOS editor. Default is `true`, which means drag interaction is enabled if the device and
system version supports it.

example:

```csharp
// Disable the drag interaction in the web view.
webView.SetDragInteractionEnabled(false);
```

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the drag interaction should be enabled.

[[Methods]]
name: SetCacheMode
syntax: SetCacheMode(UniWebViewCacheMode mode)
returnType: void
summary:

Sets the way of how the cache is used when loading a request.

This controls the loading behavior of whether the cache should be used or how to use it for the first request of the 
`Load` method. The default value is `UniWebViewCacheMode.Default`. See the [`UniWebViewCacheMode`](/api/UniWebViewCacheMode.html) enum for more.

example:

```csharp
// Set the cache mode to only load from cache but not from network.
// If no cache is available, the loading will fail.
webView.SetCacheMode(UniWebViewCacheMode.CacheOnly);
webView.Load("https://example.com");
```

[[Methods.parameters]]
name: mode
type: UniWebViewCacheMode
summary: The desired cache mode that the request loading should be used in this web view.

[[Methods]]
name: CleanCache
syntax: CleanCache(bool includeStorage, Action completionHandler)
returnType: void
summary:

Cleans web view cache. This removes cached local data of web view.
By default, the `includeStorage` is `false`, which means the local database on the page will not be removed.
If you want to remove the local database as well, set `includeStorage` to `true`.

If you need to clear all cookies, use `ClearCookies` instead.

[[Methods.parameters]]
name: includeStorage
type: bool
summary: Whether the local database storage should be removed or not. Default is `false`.
[[Methods.parameters]]
name: completionHandler
type: Action
summary:

The cache cleaning can be an async operation according to the platform. This action is called when the cache cleaning 
operation finishes.

[[Methods]]
name: SetForwardWebConsoleToNativeOutput
syntax: SetForwardWebConsoleToNativeOutput(bool flag)
returnType: void
summary:

Sets whether the web page console output should be forwarded to native console.

By setting this to `true`, UniWebView will try to intercept the web page console output methods and forward
them to the native console, for example, Xcode console on iOS, Android logcat on Android and Unity Console when
using Unity Editor on macOS. It provides a way to debug the web page by using the native console without opening
the web inspector. The forwarded logs in native side contains a "&lt;UniWebView-Web&gt;" tag. 

Logs from the methods below will be forwarded:

- console.log
- console.warn
- console.error
- console.debug

notice:

Default is `false`. You need to set it before you create a web view instance to apply this setting. Any existing
web views are not affected.

example:

```csharp
// Do it before you create the web view.
UniWebView.SetForwardWebConsoleToNativeOutput(true);

// Create a new web view.
var webView = gameObject.AddComponent<UniWebView>();
// ...

// Later, in the web page JavaScript.
function sayHello() {
  console.log("Hello from web page!");
}

// "Hello from web page!" will be printed in the native console.
```

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the web page console output should be forwarded to native output.
[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: SetCookie
syntax: SetCookie(string url, string cookie, bool skipEncoding, Action handler)
returnType: void
summary:

Sets a cookie for a certain url. When it finishes, the `handler` will be called.

The `cookie` string supports all available cookie properties as well as multiple cookies. See [RFC6265bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03) for detail.

UniWebView respects the server cookie header by default. Generally, you do not need to set the cookie from client manually. However, if you have to pass your server a manually set cookie, 
use this method.

This performs an asynchronous operation. The `handler` will be called when the operation finishes and it is the safe time to find the cookie in the storage.

example:

```csharp
// Set a cookie "testCookie=1" to some url.
UniWebView.SetCookie(someUrl, "testCookie=1", () => {
    Debug.Log("Cookie is set.");
    // Now the testCookie is contained in the request header.
    webView.Load(someUrl);
});

// Set a full properties specified cookie.
UniWebView.SetCookie("https://example.com", "sessionToken=abc123; Expires=Wed, 09 Jun 2021 10:18:14 GMT", () => {
    Debug.Log("Cookie is set.");
});
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: url
type: string
summary: The url to which cookie will be set.
[[Methods.parameters]]
name: cookie
type: string
summary: The cookie string to set. Need more information on cookie? See the [HTTP cookie](https://en.wikipedia.org/wiki/HTTP_cookie) page.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the url or not. If set to `false`, UniWebView will try to encode the url parameter before using it. Otherwise, your original url string will be used to set the cookie if it is valid. Default is `false`.

[[Methods]]
name: GetCookie
syntax: GetCookie(string url, string key, bool skipEncoding, Action<string> handler)
returnType: void
summary: Gets the cookie value under a given url and key. When it finishes, the `handler` will be called with the cookie value if exists.
example:

```csharp
UniWebView.GetCookie("https://example.com", "testCookie", (value) => {
    // => The corresponding cookie value. Or "" if there is no such cookie.
});
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: url
type: string
summary: The url (domain) where the target cookie is.
[[Methods.parameters]]
name: key
type: string
summary: The key for target cookie value.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the url or not. If set to `false`, UniWebView will try to encode the url parameter before using it. Otherwise, your original url string will be used to get the cookie if it is valid. Default is `false`.

[[Methods]]
name: RemoveCookies
syntax: RemoveCookies(string url, bool skipEncoding, Action handler)
returnType: void
summary: Removes all the cookies under a url. When it finishes, the `handler` will be called.
example:

```csharp
UniWebView.RemoveCookies("https://example.com", () => {
    Debug.Log("Cookies under `example.com` are removed.");
});
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: url
type: string
summary: The url (domain) where the target cookie is.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the url or not. If set to `false`, UniWebView will try to encode the url parameter before using it. Otherwise, your original url string will be used to get the cookie if it is valid. Default is `false`.

[[Methods]]
name: RemoveCookie
syntax: RemoveCookie(string url, string key, bool skipEncoding, Action handler)
returnType: void
summary: Removes the certain cookie under a url for the specified key. When it finishes, the `handler` will be called.
example:

```csharp
UniWebView.RemoveCookie("https://example.com", "SID", () => {
    Debug.Log("Cookie `SID` under `example.com` is removed.");
});
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: url
type: string
summary: The url (domain) where the target cookie is.
[[Methods.parameters]]
name: key
type: string
summary: The key for target cookie.
[[Methods.parameters]]
name: skipEncoding
type: bool
summary: Whether UniWebView should skip encoding the url or not. If set to `false`, UniWebView will try to encode the url parameter before using it. Otherwise, your original url string will be used to get the cookie if it is valid. Default is `false`.

[[Methods]]
name: ClearCookies
syntax: ClearCookies(Action handler)
returnType: void
summary: Clears all cookies from web view. When it finishes, the `handler` will be called.
notice: This will clear cookies from all domains in the web view and previous. If you only need to remove cookies from a certain domain, use `RemoveCookies` instead.
example:

```csharp
UniWebView.ClearCookies(() => {
    Debug.Log("Cookies are cleared.");
});
```

[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: ClearHttpAuthUsernamePassword
syntax: ClearHttpAuthUsernamePassword(string host, string realm)
returnType: void
summary:
Clears any saved credentials for HTTP authentication for both Basic and Digest.

On both iOS and Android, the user input credentials will be stored permanently across the session.
It could prevent your users to input username and password again until they changed. If you need the 
credentials only living in a shorter lifetime, call this method at proper timing.

On iOS, it will clear the credentials immediately and completely from both disk and network cache. 
On Android, it only clears from disk database, the authentication might be still cached in the network stack and will not be removed until next session (app restarting). 

The client logout mechanism should be implemented by the Web site designer (such as server sending an HTTP 401 for invalidating credentials).

example:

```csharp
UniWebView.ClearHttpAuthUsernamePassword("uniwebview.com", "UniWebViewUserRealm");
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: host
type: string
summary: The host to which the credentials apply. It should not contain any thing like scheme or path part.
[[Methods.parameters]]
name: realm
type: string
summary: The realm to which the credentials apply.

[[Methods]]
name: SetShowSpinnerWhileLoading
syntax: SetShowSpinnerWhileLoading(bool flag)
returnType: void
summary:

Sets whether to show a loading indicator while the loading is in progress.

[[Methods.parameters]]
name: flag
type: bool
summary: Whether an indicator should show.

[[Methods]]
name: SetSpinnerText
syntax: SetSpinnerText(string text)
returnType: void
summary: Sets the text displayed in the loading indicator, if `SetShowSpinnerWhileLoading` is set to `true`.
[[Methods.parameters]]
name: text
type: string
summary: The text to display while loading indicator visible. Default is \Loading...\""

[[Methods]]
name: SetAllowUserDismissSpinner
syntax: SetAllowUserDismissSpinner(bool flag)
returnType: void
summary:

Sets whether the user can dismiss the loading indicator by tapping on it or the greyed-out background around.

By default, when the loading spinner is shown, the user can dismiss it by a single tapping. Call this method
with `false` to disable this behavior.

[[Methods.parameters]]
name: flag
type: bool
summary: Whether the user can dismiss the loading indicator.

[[Methods]]
name: ShowSpinner
syntax: ShowSpinner()
returnType: void
summary:

Shows the loading spinner.

Calling this method will show the loading spinner, regardless if the `SetShowSpinnerWhileLoading` is set to
`true` or `false`. However, if `SetShowSpinnerWhileLoading` was called with `true`, UniWebView will still hide
the spinner when the loading finishes.

[[Methods]]
name: HideSpinner
syntax: HideSpinner()
returnType: void
summary:

Hides the loading spinner.

Calling this method will hide the loading spinner, regardless if the `SetShowSpinnerWhileLoading` is set to
`true` or `false`. However, if `SetShowSpinnerWhileLoading` was called with `false`, UniWebView will still show
the spinner when the loading starts.

[[Methods]]
name: SetHorizontalScrollBarEnabled
syntax: SetHorizontalScrollBarEnabled(bool enabled)
returnType: void
summary:

Sets whether the horizontal scroll bar should show when the web content beyonds web view bounds.

This only works on mobile platforms. It will do nothing on macOS Editor.

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether enable the scroll bar or not.

[[Methods]]
name: SetVerticalScrollBarEnabled
syntax: SetVerticalScrollBarEnabled(bool enabled)
returnType: void
summary:

Sets whether the vertical scroll bar should show when the web content beyonds web view bounds.

This only works on mobile platforms. It will do nothing on macOS Editor.

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether enable the scroll bar or not.

[[Methods]]
name: SetBouncesEnabled
syntax: SetBouncesEnabled(bool enabled)
returnType: void
summary:

Sets whether the web view should show with a bounces effect when scrolling to page edge.

This only works on mobile platforms. It will do nothing on macOS Editor.

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether enable the bounces effect should be applied or not.

[[Methods]]
name: SetZoomEnabled
syntax: SetZoomEnabled(bool enabled)
returnType: void
summary: Sets whether the web view supports zoom gesture to change content size. Default is `false`, which means the zoom gesture is not supported.
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the zoom gesture is allowed or not.

[[Methods]]
name: AddPermissionTrustDomain
syntax: AddPermissionTrustDomain(string domain)
returnType: void
summary:

Adds a trusted domain to white list and allow permission requests from the domain.

You need this on Android devices when a site needs the location or camera  permission. It will allow the
permission gets approved so you could access the corresponding devices.

notice:

Deprecated. Use `RegisterOnRequestMediaCapturePermission` instead, which works for both Android and iOS. It also 
provides a more flexible way to handle the permission requests. By default, if neither this method and
`RegisterOnRequestMediaCapturePermission` is called, the permission request will trigger a grant alert to ask
the user to decide whether to allow or deny the permission.

example:

```csharp
// Deprecated. Do not do it anymore.
webView.AddPermissionTrustDomain("my-own-site.com");

// Instead, use this:
webView.RegisterOnRequestMediaCapturePermission((request) => {
    if (request.Host == "my-own-site.com") {
        return UniWebViewMediaCapturePermissionDecision.Grant;
    } else {
        return UniWebViewMediaCapturePermissionDecision.Prompt;
    }
});
```

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: domain
type: string
summary: The domain to add to the white list.

[[Methods]]
name: RemovePermissionTrustDomain
syntax: RemovePermissionTrustDomain(string domain)
returnType: void
summary: Removes a trusted domain from white list.
notice:

Deprecated. If you previously registered a media capture permission request handler through 
`RegisterOnRequestMediaCapturePermission`, use `UnregisterOnRequestMediaCapturePermission` to cancel it.

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: domain
type: string
summary: The domain to remove from white list.

[[Methods]]
name: SetBackButtonEnabled
syntax: SetBackButtonEnabled(bool enabled)
returnType: void
summary:

Sets whether the device back button should be enabled to execute \"go back\" or \"closing\" operation.

On Android, the device back button in navigation bar will navigate users to a back page. If there is no any back page available, the back button clicking will try to raise an `OnShouldClose` event and try to close the web view if `true` is return from the event. If the `OnShouldClose` event is not listened to,  the web view will be closed and the UniWebView component will be destroyed to release any resource in use.

Listen to `OnKeyCodeReceived` if you need to disable the back button, but still, want to get the back button key pressing event.

This method is only for Android. On iOS, you could show a toolbar with navigation and Done buttons for 
similar purpose or call `SetAllowBackForwardNavigationGestures` to enable gesture based navigation on iOS.

The default is enabled.

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the back button should perform go back or closing operation to web view.

[[Methods]]
name: SetUseWideViewPort
syntax: SetUseWideViewPort(bool flag)
returnType: void
summary:

Sets whether the web view should enable support for the \"viewport\" HTML meta tag or should use a wide viewport.

This method is only for Android. The default is disabled.

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: flag
type: bool
summary: Whether to enable support for the viewport meta tag.

[[Methods]]
name: SetLoadWithOverviewMode
syntax: SetLoadWithOverviewMode(bool flag)
returnType: void
summary:

Sets whether the web view loads pages in overview mode, that is, zooms out the content to fit on screen by width.

This method is only for Android. The default is disabled.

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: flag
type: bool
summary: Whether to enable support for the overview mode.

[[Methods]]
name: SetImmersiveModeEnabled
syntax: SetImmersiveModeEnabled(bool enabled)
returnType: void
summary:

Sets whether the web view should behave in immersive mode, that is, 
hides the status bar and navigation bar with a sticky style.

If disabled, the navigation bar will always show up while the web view is visible.

This method is only for Android. The default is enabled.

[[Methods.badges]]
name: Android
color: green
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether to enable immersive mode when web view is showing up.

[[Methods]]
name: SetShowToolbar
syntax: SetShowToolbar(bool show, bool animated, bool onTop, bool adjustInset)
returnType: void
summary:

Sets whether to show a toolbar which contains navigation buttons and Done button.

You could choose to show or hide the toolbar. By configuring the `animated` and `onTop` 
parameters, you can control the animating and position of the toolbar. If the toolbar is overlapping with some part of your web view, pass `adjustInset` with `true` to have the web view relocating itself to avoid the overlap.

This method is only for iOS. The toolbar is hidden by default.

notice:

This method is deprecated. Use `EmbeddedToolbar.Show()` or `EmbeddedToolbar.Hide()` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

example:

```csharp
// Show a toolbar at top of screen with animation.
webView.SetShowToolbar(true, true, true);

// Hide the tool bar without animation. At the same time, make 
// the web view snap to screen top if there was overlapping between 
// the web view and toolbar.
webView.SetShowToolbar(false, false, true, true);
```

[[Methods.badges]]
name: iOS
color: orange
[[Methods.parameters]]
name: show
type: bool
summary: Whether the toolbar should show or hide.
[[Methods.parameters]]
name: animated
type: bool
summary: Whether the toolbar state changing should be with animation. Default is `false`.
[[Methods.parameters]]
name: onTop
type: bool
summary: Whether the toolbar should snap to top of screen or to bottom of screen. Default is `true`
[[Methods.parameters]]
name: adjustInset
type: bool
summary: Whether the toolbar transition should also adjust web view position and size if overlapped. Default is `false`

[[Methods]]
name: SetToolbarDoneButtonText
syntax: SetToolbarDoneButtonText(string text)
returnType: void
summary:

Sets the done button text in toolbar.

By default, UniWebView will show a "Done" button at bottom-right corner in the toolbar. You could change its title by passing a text.

This method is only for iOS since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.SetDoneButtonText` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

example:

```csharp
webView.SetToolbarDoneButtonText("关闭");
```

[[Methods.badges]]
name: iOS
color: orange
[[Methods.parameters]]
name: text
type: string
summary: The text needed to be set as done button title.

[[Methods]]
name: SetToolbarGoBackButtonText
syntax: SetToolbarGoBackButtonText(string text)
returnType: void
summary:

Sets the go back button text in toolbar.

By default, UniWebView will show a back arrow at the left side in the toolbar. You could change its text.

This method is only for iOS and macOS Editor, since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.SetGoBackButtonText` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

example:

```csharp
webView.SetToolbarGoBackButtonText("返回");
```

[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple
[[Methods.parameters]]
name: text
type: string
summary: The text needed to be set as go back button.

[[Methods]]
name: SetToolbarGoForwardButtonText
syntax: SetToolbarGoForwardButtonText(string text)
returnType: void
summary:

Sets the go forward button text in toolbar.

By default, UniWebView will show a forward arrow at the left side in the toolbar. You could change its text.

This method is only for iOS and macOS Editor, since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.SetGoForwardButtonText` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

example:

```csharp
webView.SetToolbarGoForwardButtonText("前进");
```

[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple
[[Methods.parameters]]
name: text
type: string
summary: The text needed to be set as go forward button.

[[Methods]]
name: SetShowToolbarNavigationButtons
syntax: SetShowToolbarNavigationButtons(bool show)
returnType: void
summary:

Sets the visibility of navigation buttons, such as "Go Back" and "Go Forward", on toolbar.

By default, UniWebView will show the "Go Back" and "Go Forward" navigation buttons on the toolbar.
Users can use these buttons to perform go back or go forward action just like in a browser. If the navigation
model is not for your case, call this method with `false` as `show` parameter to hide them.

This method is only for iOS, since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.ShowNavigationButtons` or `EmbeddedToolbar.HideNavigationButtons` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple
[[Methods.parameters]]
name: show
type: bool
summary: Whether the navigation buttons on the toolbar should show or hide.

[[Methods]]
name: SetToolbarTintColor
syntax: SetToolbarTintColor(Color color)
returnType: void
summary:

Sets the background tint color for the toolbar.

By default, UniWebView uses a default half-transparent iOS standard background for toolbar.
You can change it by setting a new opaque color.

This method is only for iOS, since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.SetBackgroundColor` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

[[Methods.badges]]
name: iOS
color: orange
[[Methods.parameters]]
name: color
type: Color
summary: The color should be used for the background tint of the toolbar.

[[Methods]]
name: SetToolbarTextColor
syntax: SetToolbarTextColor(Color color)
returnType: void
summary:

Sets the button text color for the toolbar.

By default, UniWebView uses the default text color on iOS, which is blue for most cases.
You can change it by setting a new opaque color.

This method is only for iOS, since there is no toolbar on Android.

notice:

This method is deprecated. Use `EmbeddedToolbar.SetButtonTextColor` or `EmbeddedToolbar.SetTitleTextColor` instead. See [EmbeddedToolbar](/guide/embedded-toolbar.html) for more information.

[[Methods.badges]]
name: iOS
color: orange
[[Methods.parameters]]
name: color
type: Color
summary: The color should be used for the button text of the toolbar.

[[Methods]]
name: SetUserInteractionEnabled
syntax: SetUserInteractionEnabled(bool enabled)
returnType: void
summary:

Sets whether the web view can receive user interaction or not.

By setting this to `false`, the web view will not accept any user touch event so your users cannot tap links or
scroll the page.

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the user interaction should be enabled or not.

[[Methods]]
name: SetTransparencyClickingThroughEnabled
syntax: SetTransparencyClickingThroughEnabled(bool enabled)
returnType: void
summary:

Sets whether the web view should pass through clicks at its clear pixels to Unity scene.

Setting this method is a pre-condition for the whole passing-through feature to work. To allow your touch passing through
to Unity scene, the following conditions should be met at the same time:

1. This method is called with `true`. It enables the web view to check every touch on the web view.
2. The web view has a transparent background in body style for its content by CSS.
3. The web view itself has a transparent background color by setting `BackgroundColor` with a clear color.

Then, when user clicks on the clear pixel on the web view, the touch events will not be handled by the web view.
Instead, these events are passed to Unity scene. By using this feature, it is possible to create a UI for your game 
with the web view.

Only clicks on transparent part on the web view will be delivered to Unity scene. The web view still intercepts
and handles other touches on visible pixels on the web view.

example:

```csharp
// Allow transparency clicking through.
webView.SetTransparencyClickingThroughEnabled(true);

// Make Unity scene visible.
webView.BackgroundColor = Color.clear;

// Disable the scrolling bounces effect to fix the web UI.
webView.SetBouncesEnabled(false);

// Other configuration, usually handle some messages from web view.
webView.OnMessageReceived += (view, message) => {
    // ...
};
```

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the transparency clicking through feature should be enabled in this web view.

[[Methods]]
name: SetWebContentsDebuggingEnabled
syntax: SetWebContentsDebuggingEnabled(bool enabled)
returnType: void
summary:

Enables debugging of web contents. You could inspect of the content of a 
web view by using a browser development tool of Chrome for Android or Safari for macOS.

This method is only for Android and macOS Editor. On iOS, you do not need an additional step. 
You could open Safari's developer tools to debug a web view on iOS.

notice:
Due to a memory bug under WebKit and Unity, it might crash your macOS Editor when you stop playing with an inspector showing embedded in a web view. You could close the inspector first or use it as a standalone window to avoid this. It will only happen in the editor and never affect real devices. 

Please remember to disable this in your product build. This should be only used while development.

[[Methods.badges]]
name: Android
color: green
[[Methods.badges]]
name: macOS
color: purple
[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the content debugging should be enabled.

[[Methods]]
name: SetWindowUserResizeEnabled
syntax: SetWindowUserResizeEnabled(bool enabled)
returnType: void
summary:

Enables user resizing for web view window. By default, you can only set the window size by setting its frame on mac Editor. 
By enabling user resizing, you would be able to resize the window by dragging its border as a normal macOS window.

notice: This method only works for macOS for debugging purpose. It does nothing on iOS and Android.
[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the window could be able to be resized by the cursor.
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: SetAllowBackForwardNavigationGestures
syntax: SetAllowBackForwardNavigationGestures(bool flag)
returnType: void
summary:

Sets whether horizontal swipe gestures should trigger back-forward list navigation.

By setting with `true`, users can swipe from screen edge to perform a back or forward navigation.
This method only works on iOS and macOS Editor. Default is `false`. 
 
On Android, the screen navigation gestures are simulating the traditional back button and it is enabled by 
default. To disable gesture navigation on Android, you have to also disable the device back button. See 
`SetBackButtonEnabled` for that purpose.

example:

```csharp
webView.SetAllowBackForwardNavigationGestures(true);
```

[[Methods.parameters]]
name: flag
type: bool
summary: The value indicates whether a swipe gestures driven navigation should be allowed. Default is `false`.
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: SetAllowHTTPAuthPopUpWindow
syntax: SetAllowHTTPAuthPopUpWindow(bool flag)
returnType: void
summary:

Sets whether a prompt alert should be displayed for collection username and password when the web view receives an
HTTP authentication challenge (HTTP Basic or HTTP Digest) from server.
    
By setting with `false`, no prompt will be shown and the user cannot login with input credentials. In this case,
you can only access this page by providing username and password through the URL like: "http://username:password@example.com".
If the username and password does not match, normally an error with 401 as status code would be returned (this behavior depends
on the server implementation). If set with `true`, a prompt will be shown when there is no credentials provided or it is not
correct in the URL.
    
Default is `true`.

example:

```csharp
// This URL requires HTTP Basic authentication.
var url = "https://example.com/auth/http-basic";

// A prompt alert will be shown and user has a chance to input their username/password.
webView.Load(url);

// Setting to false, this will use "username" and "password" to response server challenge.
webView.SetAllowHTTPAuthPopUpWindow(false);
webView.Load("https://username:password@example.com/auth/http-basic");

// Loading a URL but not providing credentials and no chance for user to input.
// An error might be raised according to your server implementation.
webView.SetAllowHTTPAuthPopUpWindow(false);
webView.Load(url);
```

[[Methods.parameters]]
name: flag
type: bool
summary: Whether a prompt alert should be shown for HTTP authentication challenge or not.

[[Methods]]
name: GetHTMLContent
syntax: GetHTMLContent(Action<string> handler)
returnType: void
summary: Gets the HTML content from current page by accessing its `outerHTML` with JavaScript.
example:

```csharp
webView.GetHTMLContent((content)=>{
    print(content);
    // => "<html><head> ... </html>"
});
```

[[Methods.parameters]]
name: handler
type: Action<string>
summary: Called after the JavaScript executed. The parameter `string` is the content read from page.

[[Methods]]
name: Print
syntax: Print()
returnType: void
summary:
Prints current page.

By calling this method, a native print preview panel will be brought up on iOS and Android. 
This method does nothing on macOS editor.

notice: On iOS and Android, the web view does not support JavaScript (window.print()), you can only initialize a print job from Unity by this method.
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: CaptureSnapshot
syntax: CaptureSnapshot(string fileName)
returnType: void
summary:

Capture the content of web view and store it to the cache path on disk with the given file name.

When the capturing finishes, `OnCaptureSnapshotFinished` event will be raised, with an error code to indicate
whether the operation succeeded and an accessible disk path of the image. 

The captured image will be stored as a PNG file under the `fileName` in app's cache folder. If a file with the 
same file name already exists, it will be overridden by the new captured image.

example:

```csharp
webView.OnCaptureSnapshotFinished += (view, errorCode, filePath) => {
    if (errorCode != 0) { return; } 
    byte[] bytes = File.ReadAllBytes(filePath);
    Texture2D texture = new Texture2D(2, 2, TextureFormat.RGB24, false);
    texture.LoadImage(bytes);
    
    // Use the texture.
};
webView.CaptureSnapshot("sample.png");
```

[[Methods.parameters]]
name: fileName
type: string
summary:

The file name to which the captured image is stored to, for example "screenshot.png". If empty, UniWebView will pick a 
random UUID with "png" file extension as the file name.

[[Methods]]
name: StartSnapshotForRendering
syntax: StartSnapshotForRendering(Rect? rect = null, Action<Texture> onStarted = null)
returnType: void
summary:

Starts the process of continually rendering the snapshot.

You take the responsibility of calling this method before you use either `GetRenderedData` or
`CreateRenderedTexture(Rect?)` to get the rendered data or texture. It prepares a render buffer for the image
data and performs the initial rendering for later use.

notice:

If this method is not called, the related data or texture methods will not work and will only return `null`. Once you
no longer need the web view to be rendered as a texture, you should call `StopSnapshotForRendering` to clean up
the associated resources.

[[Methods.parameters]]
name: rect
type: Rect?
summary:

The optional rectangle to specify the area for rendering. If `null` (by default), the entire view is rendered.

[[Methods.parameters]]
name: onStarted
type: Action<Texture>
summary:

An optional callback to execute when rendering has started. The callback receives a `Texture2D` parameter
representing the rendered texture. This is useful if you want to perform a one-time rendering of the web view.

[[Methods]]
name: StopSnapshotForRendering
syntax: StopSnapshotForRendering()
returnType: void
summary:

Stops the process of continually rendering the snapshot.

You should call this method when you no longer need any further data or texture from the
`GetRenderedData` or `CreateRenderedTexture` methods. This helps in releasing
resources and terminating the rendering process.

[[Methods]]
name: GetRenderedData
syntax: GetRenderedData(Rect? rect = null)
returnType: byte[]
summary:

Gets the data of the rendered image for the current web view.

This method provides you with the raw bytes of the rendered image data in PNG format. To successfully retrieve the
current rendered data, you should first call `StartSnapshotForRendering` to initiate the rendering process.
If `StartSnapshotForRendering` has not been called, this method will return `null`.

The rendering area specified by the `rect` parameter is based on the local coordinates of the web view.
For example, `new Rect(webView.frame.width / 2, webView.frame.height / 2, 100, 100)` means setting the origin to the
center of the web view and taking a 100x100 square as the snapshot area.

returnValue:

An array of raw bytes representing the rendered image data in PNG format, or `null` if the rendering process fails
or if the data is not prepared.

notice:

Please note that this method supports only software-rendered content. Content rendered by hardware, such as videos
and WebGL content, will appear as a black rectangle in the rendered image.

[[Methods.parameters]]
name: rect
type: Rect?
summary:

The desired rectangle within which the snapshot rendering should occur in the web view. If default value `null` is used,
the whole web view frame will be used as the snapshot area.

[[Methods]]
name: CreateRenderedTexture
syntax: CreateRenderedTexture(Rect? rect = null)
returnType: Texture2D
summary:

Creates a rendered texture for the current web view.

You should destroy the returned texture using the `Destroy` method when you no longer need it to free up resources.

This method provides you with a texture of the rendered image for the web view, which you can use in your 3D game world.
To obtain the current rendered data, you should call `StartSnapshotForRendering` before using this method.
If `StartSnapshotForRendering` has not been called, this method will return `null`.

This method returns a plain `Texture2D` object. The texture is not user interactive and can only be used for
display purposes. It is your responsibility to call the `Destroy` method on this texture when you no longer need it.

Check the [Render as Texture](/guide/render-as-texture.html) guide for more.

notice:

You need to destroy the returned texture when you do not need it anymore.

Please note that this method supports only software-rendered content. Content rendered by hardware, such as videos
and WebGL content, will appear as a black rectangle in the rendered image.

returnValue:

A rendered texture of the current web view, or `null` if the rendering process fails or the data is not prepared.

[[Methods.parameters]]
name: rect
type: Rect?
summary:

The desired rectangle within which the snapshot rendering should occur in the web view. If default value `null` is used,
the whole web view frame will be used as the snapshot area.

[[Methods]]
name: ScrollTo
syntax: ScrollTo(int x, int y, bool animated)
returnType: void
summary:
Scrolls the web view to a certain point.

Use 0 for both `x` and `y` value to scroll the web view to its origin. In a normal vertical web page, it is equivalent as scrolling to top.

You can use the `animated` parameter to control whether scrolling the page with or without animation.
This parameter only works on iOS and Android. On macOS editor, the scrolling always happens without animation.

example:

```csharp
// Scroll the web page to top with animation.
webView.ScrollTo(0, 0, true);
```

[[Methods.parameters]]
name: x
type: int
summary: X value of the target scrolling point.
[[Methods.parameters]]
name: y
type: int
summary: Y value of the target scrolling point.
[[Methods.parameters]]
name: animated
type: bool
summary: If `true`, the scrolling happens with animation. Otherwise, it happens without animation and the content is set directly.

[[Methods]]
name: AddDownloadURL
syntax: AddDownloadURL(string urlString, UniWebViewDownloadMatchingType type)
returnType: void
summary:

Adds the URL to download inspecting list.

If a response is received in main frame and its URL is already in the inspecting list, a download task will be 
triggered. Check "Download Files" guide for more.

This method only works on iOS and macOS Editor.

example:

```csharp
// On iOS, access to "https://example.com/file.pdf" will trigger a download task instead of being rendered in place.
webView.AddDownloadURL("https://example.com/file.pdf");

// You can also use a regular expression.
webView.AddDownloadURL("^https://example\\.com/file\\.pdf.*$", UniWebViewDownloadMatchingType.RegularExpression);
```

[[Methods.parameters]]
name: urlString
type: string
summary: The inspected URL string or a regular expression.
[[Methods.parameters]]
name: type
type: UniWebViewDownloadMatchingType
summary: The download matching type used to match the URL. Default is `ExactValue`.
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: RemoveDownloadURL
syntax: RemoveDownloadURL(string urlString, UniWebViewDownloadMatchingType type)
returnType: void
summary:

Removes the URL from download inspecting list.

If a response is received in main frame and its URL is already in the inspecting list, a download task will be 
triggered. Check "Download Files" guide for more.

This method only works on iOS and macOS Editor.

example:

```csharp
// On iOS, access to "https://example.com/file.pdf" will be rendered in place.
webView.RemoveDownloadURL("https://example.com/file.pdf");
```

[[Methods.parameters]]
name: urlString
type: string
summary: The inspected URL string or a regular expression.
[[Methods.parameters]]
name: type
type: UniWebViewDownloadMatchingType
summary: The download matching type used to match the URL. Default is `ExactValue`.
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: AddDownloadMIMEType
syntax: AddDownloadMIMEType(string MIMEType, UniWebViewDownloadMatchingType type)
returnType: void
summary:

Adds the MIME type to download inspecting list.

If a response is received in main frame and its MIME type is already in the inspecting list, a 
download task will be triggered. Check "Download Files" guide for more.

This method only works on iOS and macOS Editor.

example:

```csharp
// On iOS, access to any PDF files will trigger a download task instead of being rendered in place.
webView.AddDownloadMIMEType("application/pdf");

// You can also use a regular expression.
webView.AddDownloadMIMEType("^image/.*$", UniWebViewDownloadMatchingType.RegularExpression);
```

[[Methods.parameters]]
name: MIMEType
type: string
summary: The inspected MIME type of the response.
[[Methods.parameters]]
name: type
type: UniWebViewDownloadMatchingType
summary: The download matching type used to match the MIME type. Default is `ExactValue`
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: RemoveDownloadMIMETypes
syntax: RemoveDownloadMIMETypes(string MIMEType, UniWebViewDownloadMatchingType type)
returnType: void
summary:

Removes the MIME type from download inspecting list.

If a response is received in main frame and its MIME type is already in the inspecting list, a 
download task will be triggered. Check "Download Files" guide for more.

This method only works on iOS and macOS Editor.

example:

```csharp
// On iOS, access to any PDF files will be rendered in place.
webView.RemoveDownloadMIMETypes("application/pdf");
```

[[Methods.parameters]]
name: MIMEType
type: string
summary: The inspected MIME type of the response.
[[Methods.parameters]]
name: type
type: UniWebViewDownloadMatchingType
summary: The download matching type used to match the MIME type. Default is `ExactValue`
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: SetAllowUserEditFileNameBeforeDownloading
syntax: SetAllowUserEditFileNameBeforeDownloading(bool allowed)
returnType: void
summary:

Sets whether allowing users to edit the file name before downloading. Default is `true`.

If `true`, when a download task is triggered, a dialog will be shown to ask user to edit the file name and the
user has a chance to choose if the they actually want to download the file. If `false`, the file download will
start immediately without asking user to edit the file name. The file name is generated by guessing from the
content disposition header and the MIME type. If the guessing of the file name fails, a random string will be
used.

[[Methods.parameters]]
name: allowed
type: bool
summary: Whether the user can edit the file name and determine whether actually starting the downloading.

[[Methods]]
name: SetAllowUserChooseActionAfterDownloading
syntax: SetAllowUserChooseActionAfterDownloading(bool allowed)
returnType: void
summary:

Sets whether allowing users to choose the way to handle the downloaded file. Default is `true`.

On iOS, the downloaded file will be stored in a temporary folder. Setting this to `true` will show a system 
default share sheet and give the user a chance to send and store the file to another location (such as the 
File app or iCloud).

On macOS Editor, setting this to `true` will allow UniWebView to open the file in Finder.

This method does not have any effect on Android. On Android, the file is downloaded to the app's Download folder.

[[Methods.parameters]]
name: allowed
type: bool
summary: Whether the user can choose the way to handle the downloaded file.
[[Methods.badges]]
name: iOS
color: orange
[[Methods.badges]]
name: macOS
color: purple

[[Methods]]
name: SetDownloadEventForContextMenuEnabled
syntax: SetDownloadEventForContextMenuEnabled(bool enabled)
returnType: void
summary:

Sets whether the `OnFileDownloadStarted` and `OnFileDownloadFinished` events should be raised even for an image
saving action triggered by the callout (context) menu on Android.

By default, the image saving goes through a different route and it does not trigger the `OnFileDownloadStarted` 
and `OnFileDownloadFinished` events like other normal download tasks. Setting this with enabled with `true` if
you also need to get notified when user long-presses on the image and taps "Save Image" button. By default, the
image will be saved to the Downloads directory and you can get the path from the parameter 
of `OnFileDownloadFinished` event.

notice:

This only works on Android. On iOS, there is no way to get a callback or any event from the "Add to Photos"
button in the callout menu.

example:

```csharp
webView.SetDownloadEventForContextMenuEnabled(true);
```

[[Methods.parameters]]
name: enabled
type: bool
summary: Whether the context menu image saving action triggers the download related events.
[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: RegisterShouldHandleRequest
syntax: RegisterShouldHandleRequest(Func<UniWebViewChannelMethodHandleRequest, bool> handler)
returnType: void
summary:

Registers a method handler for deciding whether UniWebView should handle the request received by the web view.

The handler is called before the web view actually starts to load the new request. You can check the request
properties, such as the URL, to decide whether UniWebView should continue to handle the request or not. If you
return `true` from the handler function, UniWebView will continue to load the request. Otherwise, UniWebView
will stop the loading.

example:

```csharp
webView.RegisterShouldHandleRequest(request => {
  // Stop loading if the URL contains `example.com`.
  if (request.Url.Contains("example.com")) {
    return false;
  }

  // For other URLs, return `true` and UniWebView can continue to load as usual.
  return true;
});
```

[[Methods.parameters]]
name: handler
type: Func<UniWebViewChannelMethodHandleRequest, bool>
summary:

A handler you can implement your own logic against the input request value. You need to return a boolean value
to indicate whether UniWebView should continue to load the request or not as soon as possible.

[[Methods]]
name: UnregisterShouldHandleRequest
syntax: UnregisterShouldHandleRequest()
returnType: void
summary:

Unregisters the method handler for handling request received by the web view.

This clears the handler registered by `RegisterHandlingRequest` method.

[[Methods]]
name: RegisterOnRequestMediaCapturePermission
syntax: RegisterOnRequestMediaCapturePermission(Func<UniWebViewChannelMethodMediaCapturePermission, UniWebViewMediaCapturePermissionDecision> handler)
returnType: void
summary:

Registers a method handler for deciding whether UniWebView should allow a media request from the web page or
not.

The handler is called when the web view receives a request to capture media, such as camera or microphone. It
usually happens when the web view is trying to access the camera or microphone by using the "getUserMedia" APIs
in WebRTC. You can check the request properties in the input `UniWebViewChannelMethodMediaCapturePermission`
instance, which contains information like the media type, the request origin (protocol and host), then decide
whether this media request should be allowed or not.

According to the `UniWebViewMediaCapturePermissionDecision` value you return from the handler function,
UniWebView behaves differently:
 
- `Grant`: UniWebView allows the access without asking the user.
- `Deny`: UniWebView forbids the access and the web page will receive an error.
- `Prompt`: UniWebView asks the user for permission. The web page will receive a prompt to ask the user if they
allow the access to the requested media resources (camera or/and microphone).

If this method is never called or the handler is unregistered, UniWebView will prompt the user for the
permission.

On iOS, this method is available from iOS 15.0 or later. On earlier version of iOS, the handler will be ignored
and the web view will always prompt the user for the permission.

example:

```csharp
using System.Linq;

webView.RegisterOnRequestMediaCapturePermission((permission) => {
    // Allow the access without asking, if it is from "https://my-domain.com", and only trying to access the camera.
    string[] expected = {"VIDEO"};
    if (permission.Protocol == "https" && 
        permission.Host == "my-domain.com" && 
        permission.Resources.SequenceEqual(expected)
    ) {
        return UniWebViewMediaCapturePermissionDecision.Grant;
    } else {
        // Otherwise, prompt the user for the permission. (This is also the default behavior.)
        return UniWebViewMediaCapturePermissionDecision.Prompt;
    }
});
```

[[Methods.parameters]]
name: handler
type: Func<UniWebViewChannelMethodMediaCapturePermission, UniWebViewMediaCapturePermissionDecision>
summary:

A handler you can implement your own logic to decide whether UniWebView should allow, deny or prompt the media
resource access request.

The parameter of the handler is a value of [`UniWebViewChannelMethodMediaCapturePermission`](/api/UniWebViewChannelMethodMediaCapturePermission.html),
which contains information like the media type, the request origin (protocol and host).

You need to return a [`UniWebViewMediaCapturePermissionDecision`](/api/UniWebViewMediaCapturePermissionDecision.html) value to indicate the decision as soon as
possible.

[[Methods]]
name: UnregisterOnRequestMediaCapturePermission
syntax: UnregisterOnRequestMediaCapturePermission()
returnType: void
summary:

Unregisters the method handler for handling media capture permission request.

This clears the handler registered by `RegisterOnRequestMediaCapturePermission` method.

[[Events]]
name: OnPageStarted
syntax: OnPageStarted(UniWebView webView, string url)
returnType: void
summary:

Raised when the web view starts loading a url.

This event will be invoked for both URL loading with `Load` method or by a link navigating from a page.

example:

```csharp
webView.OnPageStarted += (view, url) => {
    print("Loading started for url: " + url);
};
webView.Load("https://example.com");

// => "Loading started for url: https://example.com/"
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: url
type: string
summary: The url which the web view is about to load.

[[Events]]
name: OnPageCommitted
syntax: OnPageCommitted(UniWebView webView, string url)
returnType: void
summary:

Raised when the web view receives response from the server and starts receiving web content.

This event will be invoked when the web view has confirmed the response is a web page and has started to receive and process the web content. This happens after `OnPageStarted` but before `OnPageFinished`.

This is an ideal place to inject JavaScript code at the earliest possible moment when a page starts loading. Note that JavaScript execution is asynchronous - it may complete after the page finishes loading. For most cases, it is recommended to use `OnPageFinished` event instead, which ensures the page is fully loaded.

example:

```csharp
webView.OnPageCommitted += (view, url) => {
    Debug.Log("Web View starts receiving content, URL: " + url);
    // Inject JavaScript code at early stage
    view.EvaluateJavaScript("console.log('Early stage injection');", null);
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: url
type: string
summary: The url which the web view has started receiving content for.

[[Events]]
name: OnPageFinished
syntax: OnPageFinished(UniWebView webView, int statusCode, string url)
returnType: void
summary:

Raised when the web view finished to load a url successfully.

This method will be invoked when a valid response received from the URL, regardless of the response status.
If a URL loading fails before reaching to the server and getting a response, `OnLoadingErrorReceived` will be 
raised instead.

notice:

Android did not provide a way to get the HTTP status code until API Level 23 (Android 6). 
The `statusCode` is not trustable and will be always 200 on Android devices running a system before Android 6.

example:

```csharp
// A sample for checking status code
webView.OnPageFinished += (view, statusCode, url) => {
    print(statusCode);
    print("Web view loading finished for: " + url);
};

webView.Load("https://example.com");
// => "200"
// => "Web view loading finished for: https://example.com"

webView.Load("https://some_domain.com/404");
// => "404"
// => "Web view loading finished for: https://example.com"

// A sample for JavaScript injection
webView.OnPageFinished += (view, statusCode, url) => {
    // Inject JavaScript code with full DOM available
    view.EvaluateJavaScript("console.log('JavaScript injection');", null);
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: statusCode
type: int
summary: HTTP status code received from response.
[[Events.parameters]]
name: url
type: string
summary: The url which the web view begins to load.

[[Events]]
name: OnPageProgressChanged
syntax: OnPageProgressChanged(UniWebView webView, float progress)
returnType: void
summary:

Raised when the loading progress value changes in current web view.

example:

```csharp
webView.OnPageProgressChanged += (view, progress) => {
    Debug.Log("Progress: " + progress);
};

webView.Load("https://uniwebview.com/");

// => "Progress: 0.1"
// => "Progress: 0.3"
// => "Progress: 0.52"
// => "Progress: 0.87"
// => "Progress: 1.0"
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: progress
type: float
summary: A value indicates the loading progress of current page. It is a value between 0.0f and 1.0f.

[[Events]]
name: OnPageErrorReceived
syntax: OnPageErrorReceived(UniWebView webView, int errorCode, string errorMessage)
returnType: void
notice:

This event is deprecated. Use `OnLoadingErrorReceived` instead.
If both `OnPageErrorReceived` and `OnLoadingErrorReceived` are listened, only the new `OnLoadingErrorReceived` will be 
raised, `OnPageErrorReceived` will not be called.

summary:

Raised when an error encountered during the loading process. 
Such as the "host not found" error or "no Internet connection" error will raise this event.

example:

```csharp
webView.OnPageErrorReceived += (view, error, message) => {
    print("Error.");
};

webView.Load("https://site-not-existing.com/");
// => "Error."

webView.Load("unknown://host?param1=value1&param2=value2");
// => "Error."

webView.Load("https://self-signed.badssl.com");
// => "Error."
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: errorCode
type: int
summary: The error code which indicates the error type. It can be different from systems and platforms.
[[Events.parameters]]
name: errorMessage
type: string
summary: The error message which describes the detail of error.

[[Events]]
name: OnLoadingErrorReceived
syntax: OnLoadingErrorReceived(UniWebView webView, int errorCode, string errorMessage, UniWebViewNativeResultPayload payload)
returnType: void
summary:

Raised when an error encountered during the loading process.
Such as the "host not found" error or "no Internet connection" error will raise this event.

example:

```csharp
webView.OnLoadingErrorReceived += (view, error, message, payload) => {
    print("Error.");
    if (payload.Extra != null && 
        payload.Extra.TryGetValue(UniWebViewNativeResultPayload.ExtraFailingURLKey, out var value)) 
    {
        var url = value as string
        // The `url` contains the failing URL causes the error, if available.
    }
};

webView.Load("https://site-not-existing.com/");
// => "Error."

webView.Load("unknown://host?param1=value1&param2=value2");
// => "Error."

webView.Load("https://self-signed.badssl.com");
// => "Error."
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: errorCode
type: int
summary: The error code which indicates the error type. It can be different from systems and platforms.
[[Events.parameters]]
name: errorMessage
type: string
summary: The error message which describes the detail of error.
[[Events.parameters]]
name: payload
type: UniWebViewNativeResultPayload
summary: The payload received from native side, which contains the error information, such as the failing URL, in its `Extra`.

[[Events]]
name: OnCaptureSnapshotFinished
syntax: OnCaptureSnapshotFinished(UniWebView webView, int errorCode, string diskPath)
returnType: void
summary:

Raised when an image captured and stored in a cache path on disk.

example:

```csharp
webView.OnCaptureSnapshotFinished += (view, errorCode, filePath) => {
    if (errorCode != 0) { return; }
    byte[] bytes = File.ReadAllBytes(filePath);
    Texture2D texture = new Texture2D(2, 2, TextureFormat.RGB24, false);
    texture.LoadImage(bytes);
    
    // Use the texture.
};
webView.CaptureSnapshot("sample.png");
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: errorCode
type: int
summary:

The error code of the event. If the snapshot is captured and stored without a problem, the error code is 0. 
Any other number indicates an error happened. In most cases, the screenshot capturing only fails due to lack
of disk storage.

[[Events.parameters]]
name: diskPath
type: string
summary: An accessible disk path to the captured snapshot image. If an error happens, it is an empty string.

[[Events]]
name: OnFileDownloadStarted
syntax: OnFileDownloadStarted(UniWebView webView, string remoteUrl, string fileName)
returnType: void
summary:

Raised when a file download task starts.

example:

```csharp
webView.OnFileDownloadStarted += (view, remoteUrl, fileName) => {
    print(string.Format("Download Started. From '{0}', file name '{1}'", remoteUrl, fileName));
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: remoteUrl
type: string
summary: The remote URL of this download task. This is also the download URL for the task.
[[Events.parameters]]
name: fileName
type: string
summary: The file name which user chooses to use.

[[Events]]
name: OnFileDownloadFinished
syntax: OnFileDownloadFinished(UniWebView webView, int errorCode, string remoteUrl, string diskPath)
returnType: void
summary:

Raised when a file download task finishes with either an error or success.

example:

```csharp
webView.OnFileDownloadFinished += (view, errorCode, remoteUrl, diskPath) => {
    if (errorCode == 0) { // Success
        print(string.Format("Download Finished. From '{0}', to '{1}'", remoteUrl, diskPath));
    } else {
        print("Download error: " + errorCode);
    }
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: errorCode
type: int
summary:

The error code of the download task result. Value `0` means the download finishes without a problem. 
Any other non-`0` value indicates an issue. The detail meaning of the error code depends on system. 
On iOS, it is usually the `errorCode` of the received `NSURLError`. On Android, the value usually represents
an `ERROR_*` value in `DownloadManager`.

[[Events.parameters]]
name: remoteUrl
type: string
summary: The remote URL of this download task.
[[Events.parameters]]
name: diskPath
type: string
summary:

The file path of the downloaded file. On iOS, the downloader file is in a temporary folder of your app sandbox.
On Android, it is in the "Download" folder of your app.

[[Events]]
name: OnMessageReceived
syntax: OnMessageReceived(UniWebView webView, UniWebViewMessage message)
returnType: void
summary:

Raised when a message from web view is received. 

Generally, the message comes from a navigation to a scheme which is observed by current web view. You could use `AddUrlScheme` and 
`RemoveUrlScheme` to manipulate the scheme list.

"uniwebview://" scheme is default in the list, so a clicking on link starting with "uniwebview://"
will raise this event, if it is not removed.

example:

```csharp
webView.OnMessageReceived += (view, message) => {
    print(message.Scheme);
    print(message.Path);
    print(message.Args["param1"]);
    print(message.Args["param2"]);
}
// Run the JavaScript below in the web page:
// location.href = "uniwebview://host?param1=value1&param2=value2"

// => "uniwebview", "host", "value1", "value2"

anotherWebView.OnMessageReceived += (view, message) => {
    print(message.RawMessage);
}
anotherWebView.AddUrlScheme("myscheme");

// Click the link "myscheme://action" in a web page.
// <a href="myscheme://action">Click Me</a>

// => "myscheme://action"
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: message
type: UniWebViewMessage
summary: The message object which contains information like message path and arguments.

[[Events]]
name: OnShouldClose
syntax: OnShouldClose(UniWebView webView)
returnType: bool
summary:

Raised when the web view is about to close itself.

This event is raised when the users close the web view by the Back button on Android, 
the Done button on iOS, or the Close button on Unity Editor. It gives a chance to make 
a final decision whether the web view should be closed and destroyed. You can also clean 
all related resources you created (such as a reference to the web view) in this event.

If this event is not listened and implemented, the web view will be closed and destroyed by default when
it needed.

returnValue: Whether the web view should be closed and destroyed.
example:

```csharp
// Clean webView field when 
public class MyBehaviour : MonoBehaviour {
    var webView;

    void Start() {
        webView = gameObject.AddComponent<UniWebView>();
        webView.OnShouldClose += (view) => {
            webView = null;
            return true;
        };
    }
}

// Make the web view there without being closed
webView.OnShouldClose += (view) => {
    return false;
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.

[[Events]]
name: OnOrientationChanged
syntax: OnOrientationChanged(UniWebView webView, ScreenOrientation orientation)
returnType: void
summary:

Raised when the screen orientation is changed. It is a good time to set the web view frame if you 
need to support multiple orientations in your game.

example:

```csharp
// Keep the web view full screen on both portrait and landscape mode.
webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
webView.OnOrientationChanged += (view, orientation) => {
    webView.Frame = new Rect(0, 0, Screen.width, Screen.height);
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: orientation
type: ScreenOrientation
summary: The screen orientation for current state.

[[Events]]
name: OnWebContentProcessTerminated
syntax: OnWebContentProcessTerminated(UniWebView webView)
returnType: void
summary:

On iOS, raise when the system calls `webViewWebContentProcessDidTerminate` method. On Android, raise when the
system calls `onRenderProcessGone` method.

It is usually due to a low memory or the render process crashes when loading the web content. When this happens,
the web view will leave you a blank white screen.

Usually you should close the web view and clean all the resource since there is no good way to restore. In some
cases, you can also try to free as much as memory and do a page `Reload`.

example:

```csharp
// Clean memory and reload current page
webView.OnWebContentProcessTerminated += (view) => {
    // Free memory
    // unusedAssets.Clean();

    webView.Reload();
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.

[[Events]]
name: OnMultipleWindowOpened
syntax: OnMultipleWindowOpened(UniWebView webView, string multipleWindowId)
returnType: void
summary:

Raised when a new window is opened. This happens when you enable the `SetSupportMultipleWindows` and open a
new pop-up window.

example:

```csharp
string newWindow = "";
webView.OnMultipleWindowOpened += (view, windowId) => {
    // A new window with identifier "windowId" is opened.
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which opens the new multiple (pop-up) window.
[[Events.parameters]]
name: multipleWindowId
type: string
summary: The identifier of the opened new window.

[[Events]]
name: OnMultipleWindowClosed
syntax: OnMultipleWindowClosed(UniWebView webView, string multipleWindowId)
returnType: void
summary:

Raised when the multiple window is closed. This happens when the pop-up window is closed by navigation operation
or by a invocation of `close()` on the page.

example:

```csharp
webView.OnMultipleWindowClosed += (view, windowId) => {
    // The opened window with identifier "windowId" is closed.
};
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which closes the multiple window.
[[Events.parameters]]
name: multipleWindowId
type: string
summary: The identifier of the closed new window.

[[Events]]
name: OnKeyCodeReceived
syntax: OnKeyCodeReceived(UniWebView webView, int keyCode)
returnType: void
summary:

Raised when a key (like back button or volume up) on the device is pressed.

This event only raised on Android. It is useful when you disabled the back button but still need to get the back button event. On iOS, user's key action is not available and this event will never be 
raised.

notice:

This event is deprecated from version 4.0. Now UniWebView never intercepts device key code events. 
So this event will be never raise anymore. Check `Input.GetKeyUp` in `Update()` instead.

example:

```csharp
// DON'T DO IT.
// webView.OnKeyCodeReceived += (view, keyCode) => {
//     if (keyCode == 4) {
//         Debug.Log("Back Button was clicked.");
//     }
// };

// Check Input in Update():
void Update() {
    if (Input.GetKeyUp(KeyCode.Escape)) {
        Debug.Log("Back Button was clicked.");
    }
}
```

[[Events.badges]]
name: Android
color: green
[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: keyCode
type: int
summary: The key code of pressed key. See [Android API for keycode](https://developer.android.com/reference/android/view/KeyEvent.html#KEYCODE_0) to know the possible values.

[[Events]]
name: OnChannelMessageReceived
syntax: OnChannelMessageReceived(UniWebView webView, UniWebViewChannelMessage message)
returnType: UniWebViewChannelMessageResponse
summary:

Raised when a channel message from JavaScript Bridge is received.

This event is triggered when JavaScript code calls `window.uniwebview.send()`,
`window.uniwebview.call()`, or `window.uniwebview.request()`. The handler should
return a `UniWebViewChannelMessageResponse` for sync calls or when immediate response
is needed. For async messages that need delayed response, use `message.Respond()` method.

The Channel Message system provides structured data communication between web content and Unity,
supporting three communication patterns: Send (fire-and-forget), Call (synchronous), and Request (asynchronous).

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    // Handle different message types
    switch (message.action) {
        case "updateScore":
            var scoreData = message.GetData<ScoreData>();
            UpdateGameScore(scoreData.score, scoreData.level);

            // For Send messages, return null (fire-and-forget)
            if (message.isFireAndForget) {
                return null;
            }

            // For Call messages, return immediate response
            if (message.isSyncCall) {
                return UniWebViewChannelMessageResponse.Success("Score updated");
            }

            // For Request messages, respond asynchronously
            if (message.isAsyncRequest) {
                StartCoroutine(UpdateScoreAsync(message, scoreData));
                return null; // Return null, use message.Respond() later
            }
            break;

        case "getUserInfo":
            var userInfo = GetCurrentUserInfo();
            return UniWebViewChannelMessageResponse.Success(userInfo);

        default:
            return UniWebViewChannelMessageResponse.Error("Unknown action");
    }

    return null;
};

private IEnumerator UpdateScoreAsync(UniWebViewChannelMessage message, ScoreData data) {
    // Simulate async operation
    yield return new WaitForSeconds(1f);

    bool success = SaveScoreToCloud(data);
    if (success) {
        message.Respond("Score saved to cloud");
    } else {
        message.RespondError("Failed to save score");
    }
}

### System.Serializable

public class ScoreData {
    public int score;
    public int level;
}
```

[[Events.parameters]]
name: webView
type: UniWebView
summary: The web view component which raises this event.
[[Events.parameters]]
name: message
type: UniWebViewChannelMessage
summary: The channel message received from JavaScript Bridge containing action, data, and metadata.

---

### UniWebViewChannelMessage

# UniWebViewChannelMessage
file: UniWebViewChannelMessage

summary:
A channel message received from the web view's JavaScript Bridge.

Channel messages provide structured, bidirectional communication between web content and Unity.
They support three communication patterns: Send (fire-and-forget), Call (synchronous), and Request (asynchronous).
Each message contains an action identifier, optional JSON data, and metadata for proper routing and response handling.

[[Properties]]
name: id
returnType: string
hasSetter: false
summary:

Unique identifier for this message.

This ID is automatically generated when the message is created and is used internally for response routing.
For asynchronous Request messages, this ID links the original message to its response.

[[Properties]]
name: timestamp
returnType: long
hasSetter: false
summary:

Timestamp when the message was created (Unix milliseconds).

This value represents the time when the message was created on the JavaScript side,
measured in milliseconds since the Unix epoch (January 1, 1970, 00:00:00 UTC).

[[Properties]]
name: action
returnType: string
hasSetter: false
summary:

The action type for this message (required).

This is the primary identifier for determining how to handle the message.
Action names should follow a consistent naming convention in your application.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    switch (message.action) {
        case "getUserInfo":
            // Handle user info request
            break;
        case "saveScore":
            // Handle score saving
            break;
        default:
            Debug.LogWarning($"Unknown action: {message.action}");
            break;
    }
    return null;
};
```

[[Properties]]
name: data
returnType: string
hasSetter: false
summary:

The message data as a JSON string (optional).

This property contains the raw JSON string sent from JavaScript.
Use `GetData<T>()` or `TryGetData<T>()` methods to parse this data into strongly-typed objects.

[[Properties]]
name: messageType
returnType: int
hasSetter: false
summary:

The type of this channel message as an integer.

- 0: Send (fire-and-forget)
- 1: Call (synchronous)
- 2: Request (asynchronous)

Use the `MessageType` property for a strongly-typed enum value instead of this raw integer.

[[Properties]]
name: MessageType
returnType: UniWebViewChannelMessageType
hasSetter: false
summary:

Gets the strongly-typed message type.

This property converts the internal `messageType` integer to the corresponding enum value
for easier type checking and handling.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    switch (message.MessageType) {
        case UniWebViewChannelMessageType.Send:
            // Handle fire-and-forget message
            ProcessSendMessage(message);
            return null;

        case UniWebViewChannelMessageType.Call:
            // Handle synchronous call
            return ProcessCallMessage(message);

        case UniWebViewChannelMessageType.Request:
            // Handle asynchronous request
            ProcessRequestMessage(message);
            return null;
    }
    return null;
};
```

[[Properties]]
name: isFireAndForget
returnType: bool
hasSetter: false
summary:

True if this is a fire-and-forget message (Send).

Send messages don't expect any response and should return null from the message handler.
They are used for notifications and one-way data transfer.

[[Properties]]
name: isSyncCall
returnType: bool
hasSetter: false
summary:

True if this is a synchronous call (Call).

Call messages expect an immediate response that will be returned directly to the JavaScript caller.
The message handler should return a `UniWebViewChannelMessageResponse` object.

[[Properties]]
name: isAsyncRequest
returnType: bool
hasSetter: false
summary:

True if this is an asynchronous request (Request).

Request messages support delayed responses using the `Respond()` method.
The message handler should return null and call `message.Respond()` when the operation completes.

[[Methods]]
name: GetData
syntax: GetData<T>()
returnType: T
summary:

Parses the message data as the specified type.

This method deserializes the JSON data into the specified type using an internal UniWebView JSON utility.
If parsing fails, it returns the default value for the type and logs an error.
For safer parsing with error handling, use `TryGetData<T>()` instead.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "updateScore") {
        // Direct parsing - may return default(T) if parsing fails
        var scoreData = message.GetData<ScoreData>();

        if (scoreData != null) {
            UpdateScore(scoreData.score, scoreData.level);
        }
    }
    return null;
};

### System.Serializable

public class ScoreData {
    public int score;
    public int level;
}
```

[[Methods]]
name: TryGetData
syntax: TryGetData<T>(out T result)
returnType: bool
summary:

Safely parses the message data as the specified type.

This method attempts to deserialize the JSON data into the specified type.
Returns true if parsing succeeds, false otherwise. Use this method when you need
explicit error handling for data parsing.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "processOrder") {
        // Safe parsing with error handling
        if (message.TryGetData<OrderData>(out var orderData)) {
            ProcessOrder(orderData);
            return UniWebViewChannelMessageResponse.Success("Order processed");
        } else {
            return UniWebViewChannelMessageResponse.Error("Invalid order data");
        }
    }
    return null;
};
```

[[Methods.parameters]]
name: result
type: T
summary: The parsed data object if successful, default(T) if parsing fails.

[[Methods]]
name: Respond
syntax: Respond(UniWebViewChannelMessageResponse response)
returnType: void
summary:

Sends an async response for this message.

This method can only be used with Request messages (asynchronous).
It sends the response back to the JavaScript Promise that's waiting for the result.
Calling this method on Send or Call messages will log an error and have no effect.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "loadGameData" && message.isAsyncRequest) {
        // Start async operation
        StartCoroutine(LoadGameDataAsync(message));
        return null; // Return null for async
    }
    return null;
};

private IEnumerator LoadGameDataAsync(UniWebViewChannelMessage message) {
    // Simulate loading delay
    yield return new WaitForSeconds(2f);

    var gameData = LoadGameFromFile();
    if (gameData != null) {
        // Send success response
        message.Respond(UniWebViewChannelMessageResponse.Success(gameData));
    } else {
        // Send error response
        message.Respond(UniWebViewChannelMessageResponse.Error("Failed to load game data"));
    }
}
```

[[Methods.parameters]]
name: response
type: UniWebViewChannelMessageResponse
summary: The response to send back to JavaScript.

[[Methods]]
name: Respond
syntax: Respond(object data)
returnType: void
summary:

Convenience method for success responses.

This is a shorthand for `Respond(UniWebViewChannelMessageResponse.Success(data))`.
Use this when you want to send a successful response without explicitly creating a response object.

example:

```csharp
private IEnumerator ProcessDataAsync(UniWebViewChannelMessage message, UserData userData) {
    // Process the data
    yield return ProcessUserData(userData);

    // Send simple success response
    message.Respond(new {
        success = true,
        message = "Data processed successfully",
        userId = userData.id
    });
}
```

[[Methods.parameters]]
name: data
type: object
summary: The data to send back as a successful response.

[[Methods]]
name: RespondError
syntax: RespondError(object errorData)
returnType: void
summary:

Convenience method for error responses.

This is a shorthand for `Respond(UniWebViewChannelMessageResponse.Error(errorData))`.
Use this when you want to send an error response without explicitly creating a response object.

example:

```csharp
private IEnumerator ValidateUserAsync(UniWebViewChannelMessage message, string userId) {
    bool isValid = yield return CheckUserValidity(userId);

    if (isValid) {
        message.Respond("User is valid");
    } else {
        // Send error response
        message.RespondError(new {
            code = 404,
            message = "User not found",
            userId = userId
        });
    }
}
```

[[Methods.parameters]]
name: errorData
type: object
summary: The error data to send back (supports any JSON-compatible type).

---

### UniWebViewChannelMessageResponse

# UniWebViewChannelMessageResponse
file: UniWebViewChannelMessageResponse

summary:
Represents a response for a channel message.

This class is used to send structured responses back to JavaScript from Unity.
It supports both success and error responses, with flexible data formats.
Response objects are typically created using the static factory methods `Success()` and `Error()`.

[[Properties]]
name: data
returnType: object
hasSetter: false
summary:

Response data for successful responses.

This property contains the data that will be sent back to JavaScript when the response represents success.
For error responses, this property is null.

[[Properties]]
name: hasError
returnType: bool
hasSetter: false
summary:

Whether this response represents an error.

When true, the response will be delivered to JavaScript as a Promise rejection or error.
When false, the response will be delivered as a successful result.

[[Properties]]
name: errorData
returnType: object
hasSetter: false
summary:

Error data if hasError is true.

This property contains the error information that will be sent back to JavaScript when the response represents an error.
For success responses, this property is null. Supports any JSON-compatible type.

[[Methods]]
name: Success
syntax: Success(object data)
returnType: UniWebViewChannelMessageResponse
summary:

Static factory method for success responses.

Creates a response object that represents a successful operation.
The provided data will be serialized to JSON and sent back to JavaScript.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "getUserInfo") {
        var userInfo = new {
            userId = 12345,
            userName = "Player1",
            level = 25,
            score = 150000
        };

        // Create success response
        return UniWebViewChannelMessageResponse.Success(userInfo);
    }

    if (message.action == "getSimpleValue") {
        // Success with simple value
        return UniWebViewChannelMessageResponse.Success("Hello from Unity!");
    }

    if (message.action == "getNumberValue") {
        // Success with numeric value
        return UniWebViewChannelMessageResponse.Success(42);
    }

    return null;
};
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: data
type: object
summary: The data to include in the response. Can be any JSON-serializable type.

[[Methods]]
name: Error
syntax: Error(object errorData)
returnType: UniWebViewChannelMessageResponse
summary:

Static factory method for error responses.

Creates a response object that represents an error condition.
The provided error data will be serialized to JSON and sent back to JavaScript as a rejection.

example:

```csharp
webView.OnChannelMessageReceived += (view, message) => {
    if (message.action == "processPayment") {
        if (!message.TryGetData<PaymentData>(out var paymentData)) {
            // Return error for invalid data
            return UniWebViewChannelMessageResponse.Error(new {
                code = "INVALID_DATA",
                message = "Payment data is malformed"
            });
        }

        if (paymentData.amount <= 0) {
            // Return error for invalid amount
            return UniWebViewChannelMessageResponse.Error(new {
                code = "INVALID_AMOUNT",
                message = "Payment amount must be greater than zero",
                providedAmount = paymentData.amount
            });
        }

        // Return error with simple string
        if (!IsPaymentMethodValid(paymentData.method)) {
            return UniWebViewChannelMessageResponse.Error("Invalid payment method");
        }

        // Process payment...
        return UniWebViewChannelMessageResponse.Success("Payment processed");
    }

    return null;
};
```

[[Methods.badges]]
name: static
color: blue
[[Methods.parameters]]
name: errorData
type: object
summary: The error data (supports any JSON-compatible type). Can be a string, object, or any serializable data.

---

### UniWebViewChannelMessageType

# UniWebViewChannelMessageType
file: UniWebViewChannelMessageType

summary:
Channel message types corresponding to different JavaScript call methods.

This enumeration defines the three communication patterns supported by the Channel Message system.
Each type has different characteristics regarding response handling and timing.

[[EnumValues]]
name: Send
value: 0
summary:

Fire-and-forget message (window.uniwebview.send).

Send messages are one-way communications that don't expect or wait for a response.
They are ideal for notifications, analytics events, and simple data transfer to Unity.
The message handler should return null for Send messages.

example:

```javascript
// JavaScript - Fire and forget
window.uniwebview.send('trackEvent', {
    eventName: 'level_completed',
    level: 5,
    score: 1500
});
```

```csharp
// Unity - Handle send message
webView.OnChannelMessageReceived += (view, message) => {
    if (message.MessageType == UniWebViewChannelMessageType.Send) {
        // Process the message but don't return a response
        ProcessFireAndForgetMessage(message);
        return null; // Always return null for Send messages
    }
    return null;
};
```

[[EnumValues]]
name: Call
value: 1
summary:

Synchronous call with immediate response (window.uniwebview.call).

Call messages expect an immediate response that is returned directly to the JavaScript caller.
The JavaScript execution blocks until Unity provides the response.
Use this for getting current state or performing quick operations.

example:

```javascript
// JavaScript - Synchronous call
const userInfo = window.uniwebview.call('getUserInfo', {
    userId: '12345'
});

console.log('User name:', userInfo.userName);
// JavaScript execution continues immediately with the result
```

```csharp
// Unity - Handle call message
webView.OnChannelMessageReceived += (view, message) => {
    if (message.MessageType == UniWebViewChannelMessageType.Call) {
        var userData = GetUserData(message.GetData<UserRequest>());
        // Return immediate response
        return UniWebViewChannelMessageResponse.Success(userData);
    }
    return null;
};
```

[[EnumValues]]
name: Request
value: 2
summary:

Asynchronous request with promise-based response (window.uniwebview.request).

Request messages support delayed responses and return a Promise to JavaScript.
Use this for operations that take time, such as file I/O, network requests, or database queries.
The message handler should return null and use `message.Respond()` when the operation completes.

example:

```javascript
// JavaScript - Asynchronous request
window.uniwebview.request('loadGameData', {
    saveSlot: 1
}).then(gameData => {
    console.log('Game loaded:', gameData);
    initializeGame(gameData);
}).catch(error => {
    console.error('Failed to load game:', error);
});

// With timeout (5 seconds)
window.uniwebview.request('syncToCloud', playerData, 5000)
    .then(() => console.log('Sync successful'))
    .catch(error => console.log('Sync failed or timed out'));
```

```csharp
// Unity - Handle request message
webView.OnChannelMessageReceived += (view, message) => {
    if (message.MessageType == UniWebViewChannelMessageType.Request) {
        // Start async operation
        StartCoroutine(ProcessRequestAsync(message));
        return null; // Return null immediately
    }
    return null;
};

private IEnumerator ProcessRequestAsync(UniWebViewChannelMessage message) {
    // Perform time-consuming operation
    yield return new WaitForSeconds(2f);

    var result = PerformLongOperation();
    if (result.success) {
        message.Respond(result.data);
    } else {
        message.RespondError(result.error);
    }
}
```

---

### UniWebViewContentInsetAdjustmentBehavior

# UniWebViewContentInsetAdjustmentBehavior
file: uniwebviewcontentinsetadjustmentbehavior

[[Properties]]
name: Automatic
returnType: UniWebViewContentInsetAdjustmentBehavior
hasSetter: false
summary: Automatically adjust the scroll view insets.

[[Properties]]
name: ScrollableAxes
returnType: UniWebViewContentInsetAdjustmentBehavior
hasSetter: false
summary: Adjust the insets only in the scroll-able directions.

[[Properties]]
name: Never
returnType: UniWebViewContentInsetAdjustmentBehavior
hasSetter: false
summary: Do not adjust the scroll view insets.

[[Properties]]
name: Always
returnType: UniWebViewContentInsetAdjustmentBehavior
hasSetter: false
summary: Always include the safe area insets in the content adjustment.

---

### UniWebViewDownloadMatchingType

# UniWebViewDownloadMatchingType
file: uniwebviewdownloadmatchingtype

[[Properties]]
name: ExactValue
returnType: UniWebViewDownloadMatchingType
hasSetter: false
summary: Matches exact the whole value.

[[Properties]]
name: RegularExpression
returnType: UniWebViewDownloadMatchingType
hasSetter: false
summary: Uses the value as a regular expression.

---

### UniWebViewHelper

# UniWebViewHelper
file: uniwebviewhelper

[[Methods]]
name: StreamingAssetURLForPath
syntax: StreamingAssetURLForPath(string path)
returnType: string
summary:

Get the local streaming asset path for a given file path related to the StreamingAssets folder.

This method will help you to create a URL string for a file under your StreamingAssets folder for different platforms.

example:

```csharp
var url = UniWebViewHelper.StreamingAssetURLForPath("www/localHTML.html");
webView.Load(url);
```

[[Methods.parameters]]
name: path
type: string
summary:

The relative path to the Assets/StreamingAssets of your file. 

For example, if you placed an HTML file under `Assets/StreamingAssets/www/index.html`, you should pass `www/index.html` as the parameter.

[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: PersistentDataURLForPath
syntax: PersistentDataURLForPath(string path)
returnType: string
summary:

Get the local persistent data path for a given file path related to the data folder of your host app.

This method will help you to create a URL string for a file under you stored in the `persistentDataPath`.

example:

```csharp
var url = UniWebViewHelper.PersistentDataURLForPath("www/index.html");
webView.Load(url);
```

[[Methods.parameters]]
name: path
type: string
summary:

The relative path to the Assets/StreamingAssets of your file.

[[Methods.badges]]
name: static
color: blue

---

### UniWebViewLogger

# UniWebViewLogger
file: uniwebviewlogger

[[Properties]]
name: Instance
returnType: UniWebViewLogger
hasSetter: false
summary:

An instance of the UniWebView logger across the process. Normally you should use this for logging purpose
in UniWebView, instead of creating a new logger yourself.

[[Properties.badges]]
name: static
color: blue

[[Properties]]
name: LogLevel
returnType: UniWebViewLogger.Level
hasSetter: true
summary:

Current level of this logger. All messages above current level will be logged out.

The default level is `Critical`, which means the logger only prints errors and exceptions.

[[Properties]]
name: Level.Verbose
returnType: UniWebViewLogger.Level
hasSetter: false
summary: Lowest level. When set to `Verbose`, the logger will log out all messages.

[[Properties]]
name: Level.Debug
returnType: UniWebViewLogger.Level
hasSetter: false
summary: Debug level. When set to `Debug`, the logger will log out most of messages up to this level.

[[Properties]]
name: Level.Info
returnType: UniWebViewLogger.Level
hasSetter: false
summary: Info level. When set to `Info`, the logger will log out up to info messages.

[[Properties]]
name: Level.Critical
returnType: UniWebViewLogger.Level
hasSetter: false
summary: Critical level. When set to `Critical`, the logger will only log out errors or exceptions.

[[Properties]]
name: Level.Off
returnType: UniWebViewLogger.Level
hasSetter: false
summary: Off level. When set to `Off`, the logger will log out nothing.

[[Methods]]
name: Verbose
syntax: Verbose(string message)
returnType: void
summary: Log a verbose message.
[[Methods.parameters]]
name: message
type: string
summary: The message to log

[[Methods]]
name: Debug
syntax: Debug(string message)
returnType: void
summary: Log a debug message.
[[Methods.parameters]]
name: message
type: string
summary: The message to log

[[Methods]]
name: Info
syntax: Info(string message)
returnType: void
summary: Log a info message.
[[Methods.parameters]]
name: message
type: string
summary: The message to log

[[Methods]]
name: Critical
syntax: Critical(string message)
returnType: void
summary: Log a critical message.
[[Methods.parameters]]
name: message
type: string
summary: The message to log

---

### UniWebViewMessage

# UniWebViewMessage
file: uniwebviewmessage

summary:

Represents a message sent from web content back to Unity. Whenever you want to send some information from web view and 
handle it in Unity script, you can navigate the user with a link started with "uniwebview://". `OnMessageReceived` event
will be fired for the web view with a `UniWebViewMessage` object. You can get the URL path and arguments from this
message object.

[[Properties]]
name: RawMessage
returnType: string
hasSetter: false
summary: Gets the raw message. It is the original url which initialized this message.
example:

```csharp
webView.OnMessageReceived += (view, message) => {
    print(message.RawMessage);
};
webView.Load("uniwebview://action?key=value&anotherKey=value");

// => "uniwebview://action?key=value&anotherKey=value"
```

[[Properties]]
name: Scheme
returnType: string
hasSetter: false
summary:

The url scheme of this UniWebViewMessage. "uniwebview" was added to message scheme list
by default. You can add your own scheme by using `UniWebView.AddUrlScheme`.

example:

```csharp
webView.OnMessageReceived += (view, message) => {
    print(message.Scheme);
};
webView.Load("uniwebview://action?key=value&anotherKey=value");

// => "uniwebview"

// Use a customized scheme.
anotherWebView.AddUrlScheme("myscheme");
anotherWebView.OnMessageReceived += (view, message) => {
    print(message.Scheme);
};
anotherWebView.Load("myscheme://action");

// => "myscheme"
```

[[Properties]]
name: Path
returnType: string
hasSetter: false
summary: The path of this UniWebViewMessage.
notice: This will be the decoded value for the path of original url.
example:

```csharp
webView.OnMessageReceived += (view, message) => {
    print(message.Path);
};
webView.Load("uniwebview://action?key=value&anotherKey=value");
// => "action"

// Encoded path
webView.OnMessageReceived += (view, message) => {
    print(message.Path);
};
webView.Load("uniwebview://%e8%b7%af%e5%be%84?key=value&anotherKey=value");
// => "路径"
```

[[Properties]]
name: Args
returnType: Dictionary<string, string>
hasSetter: false
summary:

The arguments of this UniWebViewMessage. UniWebView will try to parse the url query into 
a dictionary. 

When received url "uniwebview://yourPath?param1=value1&param2=value2", 
the args is a `Dictionary` with: Args["param1"] = value1, Args["param2"] = value2

notice: Both the key and value will be url decoded from the original url.
example:

```csharp
// Basic key-value args
webView.OnMessageReceived += (view, message) => {
    print(message.Args["key"]);
    print(message.Args["anotherKey"]);
};
webView.Load("uniwebview://action?key=value&anotherKey=anotherValue");
// => "value"
// => "anotherValue"

// With the same key
webView.OnMessageReceived += (view, message) => {
    print(message.Args["key"]);
};
var message = new UniWebViewMessage("uniwebview://sample_message?key=1&key=2");
// => "1,2"

// With encoded key and value
webView.OnMessageReceived += (view, message) => {
    print(message.Args["键"]);
};
var message = new UniWebViewMessage("uniwebview://sample_message?%E9%94%AE=%E5%80%BC);
// => "值"
```

[[Methods]]
name: UniWebViewMessage
syntax: UniWebViewMessage(string rawMessage)
returnType: 
summary: Initializes a new instance of the `UniWebViewMessage` struct.
[[Methods.parameters]]
name: rawMessage
type: string
summary: Raw message which will be parsed to a `UniWebViewMessage`.
[[Methods.badges]]
name: constructor
color: blue

---

### UniWebViewNativeListener

# UniWebViewNativeListener
file: uniwebviewnativelistener

[[Properties]]
name: webView
returnType: UniWebView
hasSetter: true
summary: The web view holder of this listener.
notice: It will be linked to original web view so you should never set it yourself.

[[Properties]]
name: Name
returnType: string
hasSetter: false
summary: Name of the current listener. This is a UUID string by which native side could use to find the message destination.

---

### UniWebViewNativeResultPayload

# UniWebViewNativeResultPayload
file: uniwebviewnativeresultpayload

[[Properties]]
name: identifier
returnType: string
hasSetter: false
summary: The identifier bound to this payload. It would be used internally to identify the callback.

[[Properties]]
name: resultCode
returnType: string
hasSetter: false
summary: The result code contained in this payload. Generally, \0\" means the operation finished without problem, while a non-zero value means somethings goes wrong."

[[Properties]]
name: data
returnType: string
hasSetter: false
summary: Return value or data from native. You should look at corresponding APIs to know what exactly contained in this.

---

### UniWebViewSafeBrowsing

# UniWebViewSafeBrowsing
file: uniwebviewsafebrowsing

summary:

UniWebView Safe Browsing provides a way for browsing the web content in a more browser-like way, such as Safari on 
iOS and Chrome on Android.

This class wraps `SFSafariViewController` on iOS and “Custom Tabs” on Android. Starting with iOS 11, this component no 
longer shares cookies with Safari in the same way as it did in iOS 9 or 10, due to design restrictions by Apple that 
cannot be bypassed. It still supports auto-fill completion and other data sharing with the browser on the device. Most 
permissions are also built-in. You can use this class for tasks that are limited for a normal web view, such as using 
Apple Pay or Progressive Web Apps (PWA).

You create a `UniWebViewSafeBrowsing` instance by calling the static `UniWebViewSafeBrowsing.Create` method with a
destination URL. You cannot change this URL once the instance is created. To show the safe browsing, call `Show` on
the instance. The web content will be displayed in full screen with a toolbar containing the loaded URL, as well
as some basic controls like Go Back, Go Forward and Done. 

Browsing web content in `UniWebViewSafeBrowsing` is only supported on iOS and Android. There is no such component in
Unity Editor. Creating and showing a `UniWebViewSafeBrowsing` on Unity Editor will fall back to open the URL in 
external browser by using Unity's `Application.OpenURL`.

[[Properties]]
name: IsSafeBrowsingSupported
returnType: bool
hasSetter: false
summary:

Whether the safe browsing mode is supported in current runtime or not.

If supported, the safe browsing mode will be used when `Show` is called on a `UniWebViewSafeBrowsing` instance.
Otherwise, the system default browser will be used to open the page when `Show` is called.

This property always returns `true` on iOS runtime platform. On Android, it depends on whether there is an Intent 
can handle the safe browsing request. Usually this ability is provided by Chrome, but there are also other browser app
might implement that. If there is no Intent can open the URL in safe browsing mode, or the handling app is set to 
disabled in Android system, this property returns `false`.

To use this API on Android when you set your Target SDK to Android 11 or later, you need to add the correct 
intent query explicitly in your AndroidManifest.xml, to follow the Package Visibility 
(https://developer.android.com/about/versions/11/privacy/package-visibility). Add `queries` as a subnode of the 
`manifest` tag:

example:

```csharp
<manifest>
  // ...

  </application>

  <queries>
    <intent>
      <action android:name="android.support.customtabs.action.CustomTabsService" />
    </intent>
  </queries>
</manifest>

// To use it:
if (UniWebViewSafeBrowsing.IsSafeBrowsingSupported) {
    // Safe Browsing Mode is available on current device.
}
```

[[Properties.badges]]
name: static
color: blue

[[Methods]]
name: Create
syntax: Create(string url)
returnType: UniWebViewSafeBrowsing
summary:

Creates a new `UniWebViewSafeBrowsing` instance with a given URL.

example:

```csharp
var safeBrowsing = UniWebViewSafeBrowsing.Create("https://uniwebview.com");
```

[[Methods.parameters]]
name: url
type: string
summary:

The URL to navigate to. The URL must use the `http` or `https` scheme.

[[Methods.badges]]
name: static
color: blue

[[Methods]]
name: SetPreferredCustomTabsBrowsers
syntax: SetPreferredCustomTabsBrowsers(string[] packages)
returnType: void
summary:

Sets the preferred browsers for Custom Tabs in order of preference.

This allows developers to specify which browsers should be preferred when multiple Custom Tabs providers are available on the device. This setting affects both SafeBrowsing and AuthenticationSession functionality.

**Browser Selection Priority (Android):**
1. **User-defined preferred packages** (highest priority) - checked in order
2. **Default browser if it's Chromium-based** (Chrome, Edge, etc.)
3. **Default browser if it supports Custom Tabs** (even non-Chromium)
4. **Any Chromium-based browser** (only when no user preference is set)
5. **Any available Custom Tabs provider** (last resort)

This prioritization helps avoid browsers with incomplete Custom Tabs implementations (such as Firefox, which may not trigger `onNavigationEvent` callbacks properly).

On iOS, this method has no effect as Safari is always used for safe browsing.

example:

```csharp
// Set Chrome and Brave as preferred browsers
UniWebViewSafeBrowsing.SetPreferredCustomTabsBrowsers(new string[] {
    "com.android.chrome",
    "com.brave.browser"
});

var safeBrowsing = UniWebViewSafeBrowsing.Create("https://uniwebview.com");
safeBrowsing.Show();
```

[[Methods.parameters]]
name: packages
type: string[]
summary:

Array of browser package names in order of preference. Common package names include:
- "com.android.chrome" (Chrome)
- "com.brave.browser" (Brave Browser) 
- "com.opera.browser" (Opera Browser)
- "com.microsoft.emmx" (Microsoft Edge)
- "com.sec.android.app.sbrowser" (Samsung Internet)

[[Methods.badges]]
name: static
color: blue
[[Methods.badges]]
name: Android
color: green

[[Methods]]
name: Show
syntax: Show()
returnType: void
summary:

Shows the safe browsing content above current screen.

example:

```csharp
var safeBrowsing = UniWebViewSafeBrowsing.Create("https://uniwebview.com");
safeBrowsing.Show();
```

[[Methods]]
name: Dismiss
syntax: Dismiss()
returnType: void
summary:

Dismisses the safe browsing component.

This method only works on iOS. On Android, there is no way to dismiss the safe browsing component 

[[Methods.badges]]
name: iOS
color: orange

[[Methods]]
name: SetToolbarColor
syntax: SetToolbarColor(Color color)
returnType: void
summary:

Sets the color for toolbar background in the safe browsing component. 

The changes are ignored after `Show` method is called.

example:

```csharp
safeBrowsing.SetToolbarColor(Color.blue);
```

[[Methods.parameters]]
name: color
type: Color
summary:

The color to tint the toolbar.

[[Methods]]
name: SetToolbarItemColor
syntax: SetToolbarItemColor(Color color)
returnType: void
summary:

Sets the color for toolbar controls in the safe browsing component. 

The changes are ignored after `Show` method is called.

This method only works on iOS. On Android, the controls color is determined by system to keep a reasonable 
contrast, based on the toolbar background color you provided in `SetToolbarColor`.

example:

```csharp
safeBrowsing.SetToolbarItemColor(Color.yellow);
```

[[Methods.parameters]]
name: color
type: Color
summary:

The color to tint the controls on toolbar.

[[Methods.badges]]
name: iOS
color: orange

[[Events]]
name: OnSafeBrowsingFinished
syntax: OnSafeBrowsingFinished(UniWebViewSafeBrowsing browsing)
returnType: event
summary:

Raised when user dismisses safe browsing by tapping the Done button or Back button.

The dismissed safe browsing instance will be invalid after this event being raised, and you should not use 
it for another browsing purpose. Instead, create a new one for a new browsing session.

notice:

This event will not happen in Unity Editor, because the whole `UniWebViewSafeBrowsing` will fall back to an 
external browser.

example:

```csharp
safeBrowsing.OnSafeBrowsingFinished += (browsing) => { 
    Debug.Log("UniWebViewSafeBrowsing closed.");
};
```

[[Events.parameters]]
name: browsing
type: UniWebViewSafeBrowsing
summary: The `UniWebViewSafeBrowsing` object raised this event.

---

### UniWebViewToolbarPosition

# UniWebViewToolbarPosition
file: uniwebviewtoolbarposition

[[Properties]]
name: Top
returnType: UniWebViewToolbarPosition
hasSetter: false
summary: Top screen edge.

[[Properties]]
name: Bottom
returnType: UniWebViewToolbarPosition
hasSetter: false
summary: Bottom screen edge.

---

### UniWebViewTransitionEdge

# UniWebViewTransitionEdge
file: uniwebviewtransitionedge

[[Properties]]
name: None
returnType: UniWebViewTransitionEdge
hasSetter: false
summary: No transition when showing or hiding.

[[Properties]]
name: Top
returnType: UniWebViewTransitionEdge
hasSetter: false
summary: Transit the web view from/to top.

[[Properties]]
name: Left
returnType: UniWebViewTransitionEdge
hasSetter: false
summary: Transit the web view from/to left.

[[Properties]]
name: Bottom
returnType: UniWebViewTransitionEdge
hasSetter: false
summary: Transit the web view from/to bottom.

[[Properties]]
name: Right
returnType: UniWebViewTransitionEdge
hasSetter: false
summary: Transit the web view from/to right.

---

